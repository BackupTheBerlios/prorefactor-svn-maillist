From johnallengreen at sheep.berlios.de  Tue Apr 19 23:54:46 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Tue, 19 Apr 2005 23:54:46 +0200
Subject: [Prorefactor-svn] r18 - in trunk: org.prorefactor.core org.prorefactor.doc org.prorefactor.eclipse/META-INF org.prorefactor.eclipse/src/org/prorefactor/eclipse org.prorefactor.feature org.prorefactor.javadoc org.prorefactor.refactor org.prorefactor.refactor/src/org/prorefactor/refactor/source org.prorefactor.update
Message-ID: <200504192154.j3JLskVB032756@sheep.berlios.de>

Author: johnallengreen
Date: 2005-04-19 23:54:45 +0200 (Tue, 19 Apr 2005)
New Revision: 18

Modified:
   trunk/org.prorefactor.core/plugin.xml
   trunk/org.prorefactor.doc/manual.xml
   trunk/org.prorefactor.doc/plugin.xml
   trunk/org.prorefactor.eclipse/META-INF/MANIFEST.MF
   trunk/org.prorefactor.eclipse/src/org/prorefactor/eclipse/ResourceUtil.java
   trunk/org.prorefactor.feature/feature.xml
   trunk/org.prorefactor.javadoc/plugin.xml
   trunk/org.prorefactor.refactor/plugin.xml
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/source/CompileUnit.java
   trunk/org.prorefactor.update/site.xml
Log:
Updated version to 1.2.4.
Fixed org.prorefactor.eclipse/plugin.xml, which was not exporting any packages.
Added a function for finding an IFile on the propath.
Added a simplified constructor for CompileUnit.

Modified: trunk/org.prorefactor.core/plugin.xml
===================================================================
--- trunk/org.prorefactor.core/plugin.xml	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.core/plugin.xml	2005-04-19 21:54:45 UTC (rev 18)
@@ -3,7 +3,7 @@
 <plugin
    id="org.prorefactor.core"
    name="ProRefactor Core"
-   version="1.2.3"
+   version="1.2.4"
    provider-name="ProRefactor.org"
    class="">
 

Modified: trunk/org.prorefactor.doc/manual.xml
===================================================================
--- trunk/org.prorefactor.doc/manual.xml	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.doc/manual.xml	2005-04-19 21:54:45 UTC (rev 18)
@@ -7,7 +7,7 @@
 
     <date>2005</date>
 
-    <releaseinfo>ProRefactor version 1.2.3</releaseinfo>
+    <pubdate>April 2005, ProRefactor version 1.2.4</pubdate>
 
     <author>
       <firstname>John</firstname>
@@ -1140,11 +1140,12 @@
       <para>From the Eclipse menu, choose <guimenuitem>File &gt; Import...
       &gt; Existing Project into Workspace</guimenuitem> for each of the
       <literal>org.prorefactor</literal> project directories in the following
-      order: <literal>antlr</literal>, <literal>core</literal>,
-      <literal>refactor</literal>, <literal>eclipse</literal>,
-      <literal>javadoc</literal>, <literal>doc</literal>,
-      <literal>feature</literal>, <literal>update</literal>. Eclipse will
-      automatically build (compile) each project as you import it.</para>
+      order: <literal>antlr</literal>, <literal>lib</literal>,
+      <literal>core</literal>, <literal>refactor</literal>,
+      <literal>eclipse</literal>, <literal>javadoc</literal>,
+      <literal>doc</literal>, <literal>feature</literal>,
+      <literal>update</literal>. Eclipse will automatically build (compile)
+      each project as you import it.</para>
 
       <para>In <guilabel>Window &gt; Preferences &gt; Java &gt; Installed
       JREs</guilabel>, edit your default JRE. Add:
@@ -1566,6 +1567,29 @@
 
     <variablelist>
       <varlistentry>
+        <term>Version 1.2.4</term>
+
+        <listitem>
+          <itemizedlist>
+            <listitem>
+              <para>No feature enhancements - just internal changes.</para>
+            </listitem>
+
+            <listitem>
+              <para>Added new sub-project named org.eclipse.lib, which
+              contains common third party libraries like Jakarta Commons and
+              Hibernate.</para>
+            </listitem>
+
+            <listitem>
+              <para>Fixed org.prorefactor.eclipse, which was not exporting any
+              run-time packages. (Needed for Prolint/Eclipse)</para>
+            </listitem>
+          </itemizedlist>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term>Version 1.2.3</term>
 
         <listitem>
@@ -1593,7 +1617,7 @@
 
                 <listitem>
                   <para>Install ProRefactor from ProRefactor.org, and restart
-                  Eclipse. </para>
+                  Eclipse.</para>
                 </listitem>
               </itemizedlist>
             </listitem>

Modified: trunk/org.prorefactor.doc/plugin.xml
===================================================================
--- trunk/org.prorefactor.doc/plugin.xml	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.doc/plugin.xml	2005-04-19 21:54:45 UTC (rev 18)
@@ -3,7 +3,7 @@
 <plugin
    id="org.prorefactor.doc"
    name="ProRefactor Documentation"
-   version="1.2.3"
+   version="1.2.4"
    provider-name="ProRefactor.org">
    <requires>
       <import plugin="org.eclipse.help"/>

Modified: trunk/org.prorefactor.eclipse/META-INF/MANIFEST.MF
===================================================================
--- trunk/org.prorefactor.eclipse/META-INF/MANIFEST.MF	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.eclipse/META-INF/MANIFEST.MF	2005-04-19 21:54:45 UTC (rev 18)
@@ -1,7 +1,7 @@
 Manifest-Version: 1.0
 Bundle-Name: ProRefactor
 Bundle-SymbolicName: org.prorefactor.eclipse; singleton=true
-Bundle-Version: 1.2.3
+Bundle-Version: 1.2.4
 Bundle-ClassPath: eclipse.jar
 Bundle-Activator: org.prorefactor.eclipse.Plugin
 Bundle-Vendor: ProRefactor.org
@@ -21,3 +21,11 @@
  org.prorefactor.doc,
  org.eclipse.help
 Eclipse-AutoStart: true
+Provide-Package: org.prorefactor.eclipse,
+ org.prorefactor.eclipse.actions,
+ org.prorefactor.eclipse.dialogs,
+ org.prorefactor.eclipse.messages,
+ org.prorefactor.eclipse.perspectives,
+ org.prorefactor.eclipse.preferences,
+ org.prorefactor.eclipse.properties,
+ org.prorefactor.eclipse.wizards

Modified: trunk/org.prorefactor.eclipse/src/org/prorefactor/eclipse/ResourceUtil.java
===================================================================
--- trunk/org.prorefactor.eclipse/src/org/prorefactor/eclipse/ResourceUtil.java	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.eclipse/src/org/prorefactor/eclipse/ResourceUtil.java	2005-04-19 21:54:45 UTC (rev 18)
@@ -11,6 +11,7 @@
 package org.prorefactor.eclipse;
 
 import java.io.ByteArrayInputStream;
+import java.io.File;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -22,6 +23,7 @@
 import org.eclipse.core.runtime.IProgressMonitor;
 import org.eclipse.core.runtime.Path;
 import org.eclipse.ui.actions.WorkspaceModifyOperation;
+import org.prorefactor.refactor.FileStuff;
 import org.prorefactor.refactor.messages.Message;
 
 
@@ -55,15 +57,26 @@
 
 
 	/** Find an IFile in the workspace that matches a full String pathname. */
-	public static IFile getIFile(String filename) {
-		Path temp = new Path(filename);
+	public static IFile getIFile(String fullPath) {
+		Path temp = new Path(fullPath);
 		if (! temp.toFile().exists() ) return null;
 		IFile tempIFile = Plugin.getWorkspace().getRoot().getFileForLocation(temp);
 		return tempIFile;
 	}
 
+	
+	
+	/** Find an IFile in the workspace for any relative or qualified file path.
+	 * Returns null if the file or resource is not found.
+	 */
+	private static IFile getIFileRelaxed(String filename) {
+		File file = FileStuff.findFile(filename);
+		if (file==null) return null;
+		return getIFile((FileStuff.fullpath(file)));
+	}
 
-
+	
+	
 	/** For an ArrayList of org.prorefactor.refactor.messages.Message objects,
 	 * create markers of type "org.prorefactor.markers.refactor".
 	 */

Modified: trunk/org.prorefactor.feature/feature.xml
===================================================================
--- trunk/org.prorefactor.feature/feature.xml	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.feature/feature.xml	2005-04-19 21:54:45 UTC (rev 18)
@@ -2,7 +2,7 @@
 <feature
       id="org.prorefactor"
       label="org.prorefactor"
-      version="1.2.3"
+      version="1.2.4"
       provider-name="ProRefactor.org"
       plugin="org.prorefactor.eclipse">
 

Modified: trunk/org.prorefactor.javadoc/plugin.xml
===================================================================
--- trunk/org.prorefactor.javadoc/plugin.xml	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.javadoc/plugin.xml	2005-04-19 21:54:45 UTC (rev 18)
@@ -3,7 +3,7 @@
 <plugin
    id="org.prorefactor.javadoc"
    name="ProRefactor Javadoc"
-   version="1.2.3"
+   version="1.2.4"
    provider-name="ProRefactor.org">
    <requires>
       <import plugin="org.eclipse.help"/>

Modified: trunk/org.prorefactor.refactor/plugin.xml
===================================================================
--- trunk/org.prorefactor.refactor/plugin.xml	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.refactor/plugin.xml	2005-04-19 21:54:45 UTC (rev 18)
@@ -3,7 +3,7 @@
 <plugin
    id="org.prorefactor.refactor"
    name="ProRefactor Refactorings"
-   version="1.2.3"
+   version="1.2.4"
    provider-name="ProRefactor.org"
    class="">
 

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/source/CompileUnit.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/source/CompileUnit.java	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/source/CompileUnit.java	2005-04-19 21:54:45 UTC (rev 18)
@@ -30,8 +30,17 @@
 /** A single point of reference for an AST, a macro tree, symbol tables, etc.
  */
 public class CompileUnit extends ParseUnit {
+	
+	/** Constructor with default values.
+	 * @param file The compile unit's source file - usually a ".p" or ".w".
+	 */
+	public CompileUnit(File file) {
+		this.file = file;
+		this.style = CompileUnit.DEFAULT;
+		this.sourceFilePool = new SourceFilePool();
+	}
 
-	/**
+	/** Constructor with specified SourceFilePool and connection style.
 	 * @param file The compile unit's source file - usually a ".p" or ".w".
 	 * @param pool Will create a new one if null.
 	 * @param style A bitset, use bitwise OR to combine flags. ex: CompileUnit.DEFAULT

Modified: trunk/org.prorefactor.update/site.xml
===================================================================
--- trunk/org.prorefactor.update/site.xml	2005-04-19 21:45:07 UTC (rev 17)
+++ trunk/org.prorefactor.update/site.xml	2005-04-19 21:54:45 UTC (rev 18)
@@ -4,7 +4,7 @@
    <description url="http://prorefactor.org/update/">
       ProRefactor Update Site
    </description>
-   <feature url="features/org.prorefactor_1.2.3.jar" id="org.prorefactor" version="1.2.3">
+   <feature url="features/org.prorefactor_1.2.4.jar" id="org.prorefactor" version="1.2.4">
       <category name="ProRefactor.org"/>
    </feature>
    <category-def name="ProRefactor.org" label="ProRefactor.org">



From johnallengreen at sheep.berlios.de  Tue Apr 19 23:45:08 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Tue, 19 Apr 2005 23:45:08 +0200
Subject: [Prorefactor-svn] r17 - in trunk: . org.prorefactor.lib org.prorefactor.lib/hibernate org.prorefactor.lib/hsqldb org.prorefactor.lib/jakarta org.prorefactor.lib/jakarta/commons-io-1.0 org.prorefactor.lib/jakarta/commons-io-1.0/src org.prorefactor.lib/jakarta/commons-io-1.0/src/conf org.prorefactor.lib/jakarta/commons-io-1.0/src/java org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output org.prorefactor.lib/jakarta/commons-io-1.0/src/test org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org org.prorefactor.lib/jakarta/commons-io-1.0/sr!
 c/test/org/apache org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/filefilter org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools org.prorefactor.lib/jakarta/commons-io-1.0/xdocs org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/style
Message-ID: <200504192145.j3JLj8DS031861@sheep.berlios.de>

Author: johnallengreen
Date: 2005-04-19 23:45:07 +0200 (Tue, 19 Apr 2005)
New Revision: 17

Added:
   trunk/org.prorefactor.lib/
   trunk/org.prorefactor.lib/.classpath
   trunk/org.prorefactor.lib/.project
   trunk/org.prorefactor.lib/build.properties
   trunk/org.prorefactor.lib/hibernate/
   trunk/org.prorefactor.lib/hibernate/apache.license.txt
   trunk/org.prorefactor.lib/hibernate/cglib-full-2.0.2.jar
   trunk/org.prorefactor.lib/hibernate/commons-collections-2.1.1.jar
   trunk/org.prorefactor.lib/hibernate/commons-lang-1.0.1.jar
   trunk/org.prorefactor.lib/hibernate/commons-logging-1.0.4.jar
   trunk/org.prorefactor.lib/hibernate/dom4j-1.4.jar
   trunk/org.prorefactor.lib/hibernate/ehcache-0.9.jar
   trunk/org.prorefactor.lib/hibernate/hibernate2.jar
   trunk/org.prorefactor.lib/hibernate/jdbc2_0-stdext.jar
   trunk/org.prorefactor.lib/hibernate/jdbc2_0-stdext.licence.txt
   trunk/org.prorefactor.lib/hibernate/jta.jar
   trunk/org.prorefactor.lib/hibernate/jta.licence.txt
   trunk/org.prorefactor.lib/hibernate/lgpl.txt
   trunk/org.prorefactor.lib/hibernate/odmg-3.0.jar
   trunk/org.prorefactor.lib/hibernate/readme.txt
   trunk/org.prorefactor.lib/hibernate/xerces-2.4.0.jar
   trunk/org.prorefactor.lib/hibernate/xml-apis.jar
   trunk/org.prorefactor.lib/hsqldb/
   trunk/org.prorefactor.lib/hsqldb/hsqldb.jar
   trunk/org.prorefactor.lib/hsqldb/hsqldb_lic.txt
   trunk/org.prorefactor.lib/hsqldb/readme.txt
   trunk/org.prorefactor.lib/jakarta/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/LICENSE.txt
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/NOTICE.txt
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/PROPOSAL.html
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/STATUS.html
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/build.xml
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/commons-io-1.0.jar
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/maven.xml
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/project.properties
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/project.xml
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/conf/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/conf/MANIFEST.MF
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/CopyUtils.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/EndianUtils.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/FileCleaner.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/FileUtils.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/HexDump.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/IOUtils.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/AbstractFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/AndFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/DelegateFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/FalseFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/FileFilterUtils.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/IOFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/NameFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/NotFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/OrFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/PrefixFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/SuffixFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/TrueFileFilter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/package.html
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/CountingInputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/DemuxInputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/ProxyInputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/ProxyReader.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/SwappedDataInputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/package.html
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ByteArrayOutputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/CountingOutputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/DeferredFileOutputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/DemuxOutputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/LockableFileWriter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/NullOutputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ProxyOutputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ProxyWriter.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/TeeOutputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ThresholdingOutputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/package.html
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/package.html
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/CopyUtilsTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/DemuxTestCase.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/EndianUtilsTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileCleanerTestCase.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsFileNewerTestCase.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsListFilesTestCase.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsTestCase.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/HexDumpTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/IOTestSuite.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/IOUtilsTestCase.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/filefilter/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/filefilter/FileFilterTestCase.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input/CountingInputStreamTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input/SwappedDataInputStreamTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/ByteArrayOutputStreamTestCase.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/CountingOutputStreamTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/DeferredFileOutputStreamTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/LockableFileWriterTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/NullOutputStreamTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/TeeOutputStreamTest.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/FileBasedTestCase.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/YellOnCloseInputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/YellOnFlushAndCloseOutputStream.java
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/bestpractices.xml
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/building.xml
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/changes.xml
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/io-logo-white.png
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/io-logo-white.xcf
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/logo.gif
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/index.xml
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/navigation.xml
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/proposal.xml
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/style/
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/style/project.css
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/tasks.xml
   trunk/org.prorefactor.lib/plugin.xml
   trunk/org.prorefactor.lib/readme.txt
Log:
Added org.prorefactor.lib.


Property changes on: trunk/org.prorefactor.lib
___________________________________________________________________
Name: svn:ignore
   + bin


Added: trunk/org.prorefactor.lib/.classpath
===================================================================
--- trunk/org.prorefactor.lib/.classpath	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/.classpath	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="jakarta/commons-io-1.0/src/java"/>
+	<classpathentry exported="true" kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/cglib-full-2.0.2.jar"/>
+	<classpathentry exported="true" kind="lib" path="hsqldb/hsqldb.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/commons-collections-2.1.1.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/commons-lang-1.0.1.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/commons-logging-1.0.4.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/dom4j-1.4.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/ehcache-0.9.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/jdbc2_0-stdext.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/jta.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/odmg-3.0.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/xerces-2.4.0.jar"/>
+	<classpathentry exported="true" kind="lib" path="hibernate/xml-apis.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: trunk/org.prorefactor.lib/.project
===================================================================
--- trunk/org.prorefactor.lib/.project	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/.project	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.prorefactor.lib</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: trunk/org.prorefactor.lib/build.properties
===================================================================
--- trunk/org.prorefactor.lib/build.properties	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/build.properties	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,36 @@
+bin.includes = plugin.xml,\
+               lib/,\
+               build.properties,\
+               .project,\
+               .classpath,\
+               src/,\
+               hibernate/,\
+               hsqldb/,\
+               jakarta/,\
+               readme.txt,\
+               bin/
+src.includes = .classpath,\
+               .project,\
+               build.properties,\
+               lib/,\
+               plugin.xml,\
+               src/,\
+               cglib-full-2.0.2.jar,\
+               commons-collections-2.1.1.jar,\
+               commons-lang-1.0.1.jar,\
+               commons-logging-1.0.4.jar,\
+               dom4j-1.4.jar,\
+               ehcache-0.9.jar,\
+               hibernate/,\
+               hibernate2.jar,\
+               hsqldb/,\
+               hsqldb.jar,\
+               jdbc2_0-stdext.jar,\
+               jta.jar,\
+               odmg-3.0.jar,\
+               xerces-2.4.0.jar,\
+               xml-apis.jar,\
+               readme.txt,\
+               jakarta/,\
+               bin/
+jars.compile.order = 

Added: trunk/org.prorefactor.lib/hibernate/apache.license.txt
===================================================================
--- trunk/org.prorefactor.lib/hibernate/apache.license.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/hibernate/apache.license.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,57 @@
+/*
+ *
+ * ====================================================================
+ *
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution, if
+ *    any, must include the following acknowlegement:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowlegement may appear in the software itself,
+ *    if and wherever such third-party acknowlegements normally appear.
+ *
+ * 4. The names "The Jakarta Project", "Commons", and "Apache Software
+ *    Foundation" must not be used to endorse or promote products derived
+ *    from this software without prior written permission. For written
+ *    permission, please contact apache at apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Group.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */

Added: trunk/org.prorefactor.lib/hibernate/cglib-full-2.0.2.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/cglib-full-2.0.2.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/commons-collections-2.1.1.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/commons-collections-2.1.1.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/commons-lang-1.0.1.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/commons-lang-1.0.1.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/commons-logging-1.0.4.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/commons-logging-1.0.4.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/dom4j-1.4.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/dom4j-1.4.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/ehcache-0.9.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/ehcache-0.9.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/hibernate2.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/hibernate2.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/jdbc2_0-stdext.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/jdbc2_0-stdext.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/jdbc2_0-stdext.licence.txt
===================================================================
--- trunk/org.prorefactor.lib/hibernate/jdbc2_0-stdext.licence.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/hibernate/jdbc2_0-stdext.licence.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,199 @@
+                Sun Microsystems, Inc.
+Binary Code License Agreement
+
+READ THE TERMS OF THIS AGREEMENT AND ANY PROVIDED
+SUPPLEMENTAL LICENSE TERMS (COLLECTIVELY
+"AGREEMENT") CAREFULLY BEFORE OPENING THE SOFTWARE
+MEDIA PACKAGE.  BY OPENING THE SOFTWARE MEDIA
+PACKAGE, YOU AGREE TO THE TERMS OF THIS AGREEMENT.
+IF YOU ARE ACCESSING THE SOFTWARE ELECTRONICALLY,
+INDICATE YOUR ACCEPTANCE OF THESE TERMS BY
+SELECTING THE "ACCEPT" BUTTON AT THE END OF THIS
+AGREEMENT.  IF YOU DO NOT AGREE TO ALL THESE
+TERMS, PROMPTLY RETURN THE UNUSED SOFTWARE TO YOUR
+PLACE OF PURCHASE FOR A REFUND OR, IF THE SOFTWARE
+IS ACCESSED ELECTRONICALLY, SELECT THE "DECLINE"
+BUTTON AT THE END OF THIS AGREEMENT.
+
+1.  LICENSE TO USE.  Sun grants you a
+non-exclusive and non-transferable license for the
+internal use only of the accompanying software and
+documentation and any error corrections provided
+by Sun (collectively "Software"), by the number of
+users and the class of computer hardware for which
+the corresponding fee has been paid.
+
+2.  RESTRICTIONS Software is confidential and
+copyrighted. Title to Software and all associated
+intellectual property rights is retained by Sun
+and/or its licensors.  Except as specifically
+authorized in any Supplemental License Terms, you
+may not make copies of Software, other than a
+single copy of Software for archival purposes.
+Unless enforcement is prohibited by applicable
+law, you may not modify, decompile, or reverse
+engineer Software.  Software is not designed or
+licensed for use in on-line control of aircraft,
+air traffic, aircraft navigation or aircraft
+communications; or in the design, construction,
+operation or maintenance of any nuclear facility.
+No right, title or interest in or to any
+trademark, service mark, logo or trade name of Sun
+or its licensors is granted under this Agreement.
+
+3. LIMITED WARRANTY.  Sun warrants to you that for
+a period of ninety (90) days from the date of
+purchase, as evidenced by a copy of the receipt,
+the media on which Software is furnished (if any)
+will be free of defects in materials and
+workmanship under normal use.  Except for the
+foregoing, Software is provided "AS IS".  Your
+exclusive remedy and Sun's entire liability under
+this limited warranty will be at Sun's option to
+replace Software media or refund the fee paid for
+Software.
+
+4.  DISCLAIMER OF WARRANTY.  UNLESS SPECIFIED IN
+THIS AGREEMENT, ALL EXPRESS OR IMPLIED CONDITIONS,
+REPRESENTATIONS AND WARRANTIES, INCLUDING ANY
+IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE OR NON-INFRINGEMENT ARE
+DISCLAIMED, EXCEPT TO THE EXTENT THAT THESE
+DISCLAIMERS ARE HELD TO BE LEGALLY INVALID.
+
+5.  LIMITATION OF LIABILITY.  TO THE EXTENT NOT
+PROHIBITED BY LAW, IN NO EVENT WILL SUN OR ITS
+LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT
+OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL,
+INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED
+REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT
+OF OR RELATED TO THE USE OF OR INABILITY TO USE
+SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.  In no event will
+Sun's liability to you, whether in contract, tort
+(including negligence), or otherwise, exceed the
+amount paid by you for Software under this
+Agreement.  The foregoing limitations will apply
+even if the above stated warranty fails of its
+essential purpose.
+
+6.  Termination.  This Agreement is effective
+until terminated.  You may terminate this
+Agreement at any time by destroying all copies of
+Software.  This Agreement will terminate
+immediately without notice from Sun if you fail to
+comply with any provision of this Agreement.  Upon
+Termination, you must destroy all copies of
+Software.
+
+7.  Export Regulations.  All Software and
+technical data delivered under this Agreement are
+subject to US export control laws and may be
+subject to export or import regulations in other
+countries.  You agree to comply strictly with all
+such laws and regulations and acknowledge that you
+have the responsibility to obtain such licenses to
+export, re-export, or import as may be required
+after delivery to you.
+
+8.  U.S. Government Restricted Rights.  If
+Software is being acquired by or on behalf of the
+U.S. Government or by a U.S. Government prime
+contractor or subcontractor (at any tier), then
+the Government's rights in Software and
+accompanying documentation will be only as set
+forth in this Agreement; this is in accordance
+with 48 CFR 227.7201 through 227.7202-4 (for
+Department of Defense (DOD) acquisitions) and with
+48 CFR 2.101 and 12.212 (for non-DOD
+acquisitions).
+
+9.  Governing Law.  Any action related to this
+Agreement will be governed by California law and
+controlling U.S. federal law.  No choice of law
+rules of any jurisdiction will apply.
+
+10.  Severability. If any provision of this
+Agreement is held to be unenforceable, this
+Agreement will remain in effect with the provision
+omitted, unless omission would frustrate the
+intent of the parties, in which case this
+Agreement will immediately terminate.
+
+11.  Integration.  This Agreement is the entire
+agreement between you and Sun relating to its
+subject matter.  It supersedes all prior or
+contemporaneous oral or written communications,
+proposals, representations and warranties and
+prevails over any conflicting or additional terms
+of any quote, order, acknowledgment, or other
+communication between the parties relating to its
+subject matter during the term of this Agreement.
+No modification of this Agreement will be binding,
+unless in writing and signed by an authorized
+representative of each party.
+
+For inquiries please contact: Sun Microsystems,
+Inc.  901 San Antonio Road, Palo Alto, California
+94303
+
+
+SUPPLEMENTAL LICENSE TERMS
+JDBCTM 2.0 INTERFACE CLASSES
+
+These supplemental license terms ("Supplement")
+add to or modify the terms of the Binary Code
+License Agreement (collectively, the
+"Agreement"). Capitalized terms not defined in
+this Supplement shall have the same meanings
+ascribed to them in the Agreement. These
+Supplement terms shall supersede any inconsistent
+or conflicting terms in the Agreement, or in any
+license contained within the Software.
+
+1. License to Distribute. Sun grants you a
+non-exclusive, non-transferable, limited license
+to reproduce and distribute the binary and/or
+source code form of the Software to third party
+end users through multiple tiers of distribution,
+provided that you: (i) distribute the Software
+complete and unmodified in its original Java
+Archive file, and only bundled as a part of your
+program that incorporates the Software
+("Program"); (ii) do not distribute additional
+software intended to replace any component(s) of
+the Software; (iii) agree to incorporate the most
+current version of the Software that was available
+from Sun no later than 180 days prior to each
+production release of the Program; (iv) do not
+remove or alter any proprietary legends or notices
+contained in or on the Software; (v) only
+distribute the Program pursuant to a license
+agreement that protects Sun's interest consistent
+with the terms contained in the Agreement; (vi)
+may not create, or authorize your licensees to cr!
+eate additional classes, interfaces, or
+subpackages that are contained in the "java"
+"javax" or "sun" packages or similar as specified
+by Sun in any class file naming convention; and
+(vii) agree to defend and indemnify Sun and its
+licensors from and against any damages, costs,
+liabilities, settlement amounts and/or expenses
+(including attorneys' fees) incurred in connection
+with any claim, lawsuit or action by any third
+party that arises or results from the use or
+distribution of any and all Programs.
+
+2. Trademarks and Logos. You acknowledge as
+between you and Sun that Sun owns the Java
+trademark and all Java-related trademarks, logos
+and icons including the Coffee Cup and Duke ("Java
+Marks") and agree to comply with the Java
+Trademark Guidelines at
+http://java.sun.com/trademarks.html.
+
+
+
+
+
+                
\ No newline at end of file

Added: trunk/org.prorefactor.lib/hibernate/jta.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/jta.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/jta.licence.txt
===================================================================
--- trunk/org.prorefactor.lib/hibernate/jta.licence.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/hibernate/jta.licence.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,49 @@
+  
+Sun Microsystems, Inc. 
+Binary Code License Agreement
+
+READ THE TERMS OF THIS AGREEMENT AND ANY PROVIDED SUPPLEMENTAL LICENSE TERMS (COLLECTIVELY "AGREEMENT") CAREFULLY BEFORE OPENING THE SOFTWARE MEDIA PACKAGE.  BY OPENING THE SOFTWARE MEDIA PACKAGE, YOU AGREE TO THE TERMS OF THIS AGREEMENT.  IF YOU ARE ACCESSING THE SOFTWARE ELECTRONICALLY, INDICATE YOUR ACCEPTANCE OF THESE TERMS BY SELECTING THE "ACCEPT" BUTTON AT THE END OF THIS AGREEMENT.  IF YOU DO NOT AGREE TO ALL THESE TERMS, PROMPTLY RETURN THE UNUSED SOFTWARE TO YOUR PLACE OF PURCHASE FOR A REFUND OR, IF THE SOFTWARE IS ACCESSED ELECTRONICALLY, SELECT THE "DECLINE" BUTTON AT THE END OF THIS AGREEMENT. 
+
+1.  LICENSE TO USE.  Sun grants you a non-exclusive and non-transferable license for the internal use only of the accompanying software and documentation and any error corrections provided by Sun (collectively "Software"), by the number of users and the class of computer hardware for which the corresponding fee has been paid. 
+
+2.  RESTRICTIONS.  Software is confidential and copyrighted. Title to Software and all associated intellectual property rights is retained by Sun and/or its licensors.  Except as specifically authorized in any Supplemental License Terms, you may not make copies of Software, other than a single copy of Software for archival purposes.  Unless enforcement is prohibited by applicable law, you may not modify, decompile, or reverse engineer Software.  Licensee acknowledges that Licensed Software is not designed or intended for use in the design, construction, operation or maintenance of any nuclear facility. Sun Microsystems, Inc. disclaims any express or implied warranty of fitness for such uses.   No right, title or interest in or to any trademark, service mark, logo or trade name of Sun or its licensors is granted under this Agreement. 
+
+3. LIMITED WARRANTY.  Sun warrants to you that for a period of ninety (90) days from the date of purchase, as evidenced by a copy of the receipt, the media on which Software is furnished (if any) will be free of defects in materials and workmanship under normal use.  Except for the foregoing, Software is provided "AS IS".  Your exclusive remedy and Sun's entire liability under this limited warranty will be at Sun's option to replace Software media or refund the fee paid for Software. 
+
+4.  DISCLAIMER OF WARRANTY.  UNLESS SPECIFIED IN THIS AGREEMENT, ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT ARE DISCLAIMED, EXCEPT TO THE EXTENT THAT THESE DISCLAIMERS ARE HELD TO BE LEGALLY INVALID. 
+
+5.  LIMITATION OF LIABILITY.  TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED TO THE USE OF OR INABILITY TO USE SOFTWARE, EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.  In no event will Sun's liability to you, whether in contract, tort (including negligence), or otherwise, exceed the amount paid by you for Software under this Agreement.  The foregoing limitations will apply even if the above stated warranty fails of its essential purpose. 
+
+6.  Termination.  This Agreement is effective until terminated.  You may terminate this Agreement at any time by destroying all copies of Software.  This Agreement will terminate immediately without notice from Sun if you fail to comply with any provision of this Agreement.  Upon Termination, you must destroy all copies of Software. 
+
+7. Export Regulations. All Software and technical data delivered under this Agreement are subject to US export control laws and may be subject to export or import regulations in other countries.  You agree to comply strictly with all such laws and regulations and acknowledge that you have the responsibility to obtain such licenses to export, re-export, or import as may be required after delivery to you. 
+
+8.   U.S. Government Restricted Rights.  If Software is being acquired by or on behalf of the U.S. Government or by a U.S. Government prime contractor or subcontractor (at any tier), then the Government's rights in Software and accompanying documentation will be only as set forth in this Agreement; this is in accordance with 48 CFR 227.7201 through 227.7202-4 (for Department of Defense (DOD) acquisitions) and with 48 CFR 2.101 and 12.212 (for non-DOD acquisitions). 
+
+9.  Governing Law.  Any action related to this Agreement will be governed by California law and controlling U.S. federal law.  No choice of law rules of any jurisdiction will apply. 
+
+10.  Severability. If any provision of this Agreement is held to be unenforceable, this Agreement will remain in effect with the provision omitted, unless omission would frustrate the intent of the parties, in which case this Agreement will immediately terminate. 
+
+11.  Integration.  This Agreement is the entire agreement between you and Sun relating to its subject matter.  It supersedes all prior or contemporaneous oral or written communications, proposals, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement.  No modification of this Agreement will be binding, unless in writing and signed by an authorized representative of each party. 
+
+JAVATM INTERFACE CLASSES 
+JAVA TRANSACTION API (JTA), VERSION 1.0.1B, MAINTENANCE RELEASE
+SUPPLEMENTAL LICENSE TERMS
+
+These supplemental license terms ("Supplemental Terms") add to or modify the terms of the Binary Code License Agreement (collectively, the "Agreement"). Capitalized terms not defined in these Supplemental Terms shall have the same meanings ascribed to them in the Agreement. These Supplemental Terms shall supersede any inconsistent or conflicting terms in the Agreement, or in any license contained within the Software. 
+
+1. Software Internal Use and Development License Grant. Subject to the terms and conditions of this Agreement, including, but not limited to Section 3 (Java Technology Restrictions) of these Supplemental Terms, Sun grants you a non-exclusive, non-transferable, limited license to reproduce internally and use internally the binary form of the Software, complete and unmodified, for the sole purpose of designing, developing and testing your Java applets and applications ("Programs"). 
+
+2. License to Distribute Software.  In addition to the license granted in Section 1 (Software Internal Use and Development License Grant) of these Supplemental Terms, subject to the terms and conditions of this Agreement, including but not limited to Section 3 (Java Technology Restrictions), Sun grants you a non-exclusive, non-transferable, limited license to reproduce and distribute the Software in binary form only, provided that you (i) distribute the Software complete and unmodified and only bundled as part of your Programs, (ii) do not distribute additional software intended to replace any component(s) of the Software, (iii) do not remove or alter any proprietary legends or notices contained in the Software, (iv) only distribute the Software subject to a license agreement that protects Sun's interests consistent with the terms contained in this Agreement, and (v) agree to defend and indemnify Sun and its licensors from and against any damages, costs, liabilities, settle!
 ment amounts and/or expenses (including attorneys' fees) incurred in connection with any claim, lawsuit or action by any third party that arises or results from the use or distribution of any and all Programs and/or Software. 
+
+3. Java Technology Restrictions. You may not modify the Java Platform Interface ("JPI", identified as classes contained within the "java" package or any subpackages of the "java" package), by creating additional classes within the JPI or otherwise causing the addition to or modification of the classes in the JPI.  In the event that you create an additional class and associated API(s) which (i) extends the functionality of the Java Platform, and (ii) is exposed to third party software developers for the purpose of developing additional software which invokes such additional API, you must promptly publish broadly an accurate specification for such API for free use by all developers. You may not create, or authorize your licensees to create additional classes, interfaces, or subpackages that are in any way identified as "java", "javax", "sun" or similar convention as specified by Sun in any naming convention designation. 
+
+4. Trademarks and Logos. You acknowledge and agree as between you and Sun that Sun owns the SUN, SOLARIS, JAVA, JINI, FORTE, and iPLANET trademarks and all SUN, SOLARIS, JAVA, JINI, FORTE, and iPLANET-related trademarks, service marks, logos and other brand designations ("Sun Marks"), and you agree to comply with the Sun Trademark and Logo Usage Requirements currently located at http://www.sun.com/policies/trademarks. Any use you make of the Sun Marks inures to Sun's benefit. 
+
+5. Source Code. Software may contain source code that is provided solely for reference purposes pursuant to the terms of this Agreement.  Source code may not be redistributed unless expressly provided for in this Agreement. 
+
+6. Termination for Infringement.  Either party may terminate this Agreement immediately should any Software become, or in either party's opinion be likely to become, the subject of a claim of infringement of any intellectual property right. 
+
+For inquiries please contact: Sun Microsystems, Inc. 4150 Network Circle, Santa Clara, California 95054. 
+
+ 

Added: trunk/org.prorefactor.lib/hibernate/lgpl.txt
===================================================================
--- trunk/org.prorefactor.lib/hibernate/lgpl.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/hibernate/lgpl.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+		     
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+

Added: trunk/org.prorefactor.lib/hibernate/odmg-3.0.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/odmg-3.0.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/readme.txt
===================================================================
--- trunk/org.prorefactor.lib/hibernate/readme.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/hibernate/readme.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,43 @@
+Hibernate - Relational Persistence for Idiomatic Java
+=====================================================
+version 2.1.8, 30.1.2004
+
+Latest Documentation:
+
+   http://hibernate.org
+
+Bug Reports:
+   
+   Hibernate JIRA (preferred)
+   hibernate-devel at lists.sourceforge.net
+
+Free Technical Support:
+
+   http://forum.hibernate.org
+
+Commercial Support & Training:
+
+   http://www.hibernate.org/SupportTraining
+   
+   
+Get Up And Running Quick
+------------------------
+Demo:
+
+   (1) copy your JDBC driver to the lib directory
+   (2) edit etc/hibernate.properties
+   (3) run "ant eg" or "build eg"
+   (4) browse the sourcecode in eg/org/hibernate/auction
+
+Tests:
+
+   (1) copy your JDBC driver to the lib directory
+   (2) edit etc/hibernate.properties
+   (3) run "ant junitreport" or "build junitreport"
+   (4) see testout/index.html
+
+Legal
+-----------
+This software is distributed under the terms of the FSF Lesser Gnu Public License (see lgpl.txt).
+
+This product includes software developed by the Apache Software Foundation (http://www.apache.org/).

Added: trunk/org.prorefactor.lib/hibernate/xerces-2.4.0.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/xerces-2.4.0.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hibernate/xml-apis.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hibernate/xml-apis.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hsqldb/hsqldb.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/hsqldb/hsqldb.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/hsqldb/hsqldb_lic.txt
===================================================================
--- trunk/org.prorefactor.lib/hsqldb/hsqldb_lic.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/hsqldb/hsqldb_lic.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,31 @@
+/* Copyright (c) 2001-2004, The HSQL Development Group
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of the HSQL Development Group nor the names of its
+ * contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL HSQL DEVELOPMENT GROUP, HSQLDB.ORG, 
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+

Added: trunk/org.prorefactor.lib/hsqldb/readme.txt
===================================================================
--- trunk/org.prorefactor.lib/hsqldb/readme.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/hsqldb/readme.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,18 @@
+Readme File
+
+Jan 2004
+
+This package contains the latest revision 2 of HSQLDB 1.7.3
+
+HSQLDB is a relational database engine and a set of tools written in Java.
+
+The file index.html in this directory contains the list of directories with their contents.
+
+Documentation and license information can be found in the /doc directory.
+
+Project home page: http://hsqldb.sourceforge.net
+
+HSQLDB 1.8.0 is due for release in February or March and features many enhancements
+over this release.
+
+Please check for availability and use the new version if possible.

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/LICENSE.txt
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/LICENSE.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/LICENSE.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,203 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/NOTICE.txt
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/NOTICE.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/NOTICE.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,3 @@
+This product includes software developed by
+The Apache Software Foundation (http://www.apache.org/).
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/PROPOSAL.html
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/PROPOSAL.html	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/PROPOSAL.html	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,62 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+  <title>Proposal for IO Package</title>
+</head>
+ <body bgcolor="white">
+  
+<div align="center"> 
+<h1>Proposal for <em>IO</em> Package</h1>
+ </div>
+  
+<h3>(0) Rationale</h3>
+  
+<p>Many software projects have a need to perform I/O in various ways, and
+the JDK class libraries provide a lot of functionality, but sometimes you
+need just a little bit more.  The io package seeks to  encapsulate some of
+the most popular i/o base classes into one easy to  use package.</p>
+   
+<h3>(1) Scope of the Package</h3>
+  
+<p>This proposal is to create a package of Java utility classes for  various
+types of i/o related activity.</p>
+   
+<h3>(1.5) Interaction With Other Packages</h3>
+  
+<p><em>IO</em> relies only on standard JDK 1.2 (or later) APIs for production
+deployment.  It utilizes the JUnit unit testing framework for developing
+and executing unit tests, but this is of interest only to developers of the
+component.  IO will be a dependency for several existing components in the
+open source world.</p>
+  
+<p>No external configuration files are utilized.</p>
+   
+<h3>(2) Initial Source of the Package</h3>
+  
+<p>The original Java classes are splashed around various Apache  subprojects.
+ We intend to seek them out and integrate them.</p>
+  
+<p>The proposed package name for the new component is <code>org.apache.commons.io</code>.</p>
+   
+<h3>(3)  Required Jakarta-Commons Resources</h3>
+  
+<ul>
+ <li>CVS Repository - New directory <code>io</code> in the     <code>jakarta-commons</code>
+CVS repository.</li>
+ <li>Mailing List - Discussions will take place on the general     <em>commons-dev at jakarta.apache.org</em>
+mailing list.  To help     list subscribers identify messages of interest,
+it is suggested that     the message subject of messages about this component
+be prefixed with     [IO].</li>
+ <li>Bugzilla - New component "IO" under the "Commons" product     category,
+with appropriate version identifiers as needed.</li>
+ <li>Jyve FAQ - New category "commons-io" (when available).</li>
+ 
+</ul>
+   
+<h3>(4) Initial Committers</h3>
+  
+<p>The initial committers on the IO component shall be Scott Sanders and
+Nicola Ken Barozzi and Henri Yandell</p>
+    <br>
+</body>
+</html>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/STATUS.html
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/STATUS.html	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/STATUS.html	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,65 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+  <title>Status File for Jakarta Commons "IO" Component</title>
+</head>
+ <body bgcolor="white">
+
+<div align="center">
+<h1>The Jakarta Commons <em>IO</em> Component</h1>
+ $Id: STATUS.html,v 1.14 2004/02/04 21:49:52 scolebourne Exp $<br>
+ <a href="#Introduction">[Introduction]</a> <a href="#Dependencies">[Dependencies]</a>
+<a href="#Release%20Info">[Release Info]</a> <a href="#Committers">[Committers]</a>
+<a href="#Action%20Items">[Action Items]</a> <br>
+<br>
+ </div>
+
+
+<a name="Introduction"></a>
+<h3>1.  INTRODUCTION</h3>
+
+<p>The <em>IO</em> Component contains a set of Java classes that provide I/O
+functionality above and beyond what the JDK provides out of the box.&nbsp;</p>
+
+<h3>2.  DEPENDENCIES</h3>
+
+<p>The <em>IO</em> component is dependent upon the following external components
+for development and use:</p>
+
+<ul>
+ <li><a href="http://java.sun.com/j2se">Java Development Kit</a>     (Version
+1.2 or later)</li>
+ <li><a href="http://www.junit.org">JUnit Testing Framework</a>     (Version
+3.7 or later) - for unit tests only, not required     for deployment</li>
+ <li>Apache Jakarta Commons Lang (latest CVS code)</li>
+</ul>
+
+
+<a name="Release Info"></a>
+<h3>3.  RELEASE INFO</h3>
+
+<p>Current Release: IO is yet to be released.  We hope it will be RSN.</p>
+
+<p>Planned Next Release:  Real Soon Now :)  See the <a
+ href="#Action%20Items">Action Items</a> list for tasks that need to be completed
+prior to this release.</p>
+
+
+<a name="Committers"></a>
+<h3>4.  COMMITTERS</h3>
+<p>
+  Please see <a href="http://jakarta.apache.org/commons/io/team-list.html">Team list</a>.
+</p>
+
+<a name="Action Items"></a>
+<h3>5.  ACTION ITEMS</h3>
+
+<p>
+  Please see 
+  <a href="http://jakarta.apache.org/commons/io/tasks.html">Tasks</a>
+  and
+  <a href="http://jakarta.apache.org/commons/io/changes-report.html">Changes</a>
+</p>
+
+</body>
+</html>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/build.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/build.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/build.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,163 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--build.xml generated by maven from project.xml version 1.0
+  on date May 2 2004, time 2227-->
+
+<project default="jar" name="commons-io" basedir=".">
+  <property name="defaulttargetdir" value="target">
+  </property>
+  <property name="libdir" value="target/lib">
+  </property>
+  <property name="classesdir" value="target/classes">
+  </property>
+  <property name="testclassesdir" value="target/test-classes">
+  </property>
+  <property name="testreportdir" value="target/test-reports">
+  </property>
+  <property name="distdir" value="dist">
+  </property>
+  <property name="javadocdir" value="dist/docs/api">
+  </property>
+  <property name="final.name" value="commons-io-1.0">
+  </property>
+  <target name="init" description="o Initializes some properties">
+    <mkdir dir="${libdir}">
+    </mkdir>
+    <condition property="noget">
+      <equals arg2="only" arg1="${build.sysclasspath}">
+      </equals>
+    </condition>
+  </target>
+  <target name="compile" description="o Compile the code" depends="get-deps">
+    <mkdir dir="${classesdir}">
+    </mkdir>
+    <javac destdir="${classesdir}" deprecation="true" debug="true" optimize="false" excludes="**/package.html">
+      <src>
+        <pathelement location="src/java">
+        </pathelement>
+      </src>
+      <classpath>
+        <fileset dir="${libdir}">
+          <include name="*.jar">
+          </include>
+        </fileset>
+      </classpath>
+    </javac>
+    <copy todir="${classesdir}">
+      <fileset dir=".">
+        <include name="NOTICE.txt">
+        </include>
+      </fileset>
+    </copy>
+  </target>
+  <target name="jar" description="o Create the jar" depends="compile,test">
+    <jar jarfile="target/${final.name}.jar" excludes="**/package.html" basedir="${classesdir}">
+    </jar>
+  </target>
+  <target name="clean" description="o Clean up the generated directories">
+    <delete dir="${defaulttargetdir}">
+    </delete>
+    <delete dir="${distdir}">
+    </delete>
+  </target>
+  <target name="dist" description="o Create a distribution" depends="jar, javadoc">
+    <mkdir dir="dist">
+    </mkdir>
+    <copy todir="dist">
+      <fileset dir="${defaulttargetdir}" includes="*.jar">
+      </fileset>
+      <fileset dir="${basedir}" includes="LICENSE*, README*">
+      </fileset>
+    </copy>
+  </target>
+  <target name="test" description="o Run the test cases" if="test.failure" depends="internal-test">
+    <fail message="There were test failures.">
+    </fail>
+  </target>
+  <target name="internal-test" depends="compile-tests">
+    <mkdir dir="${testreportdir}">
+    </mkdir>
+    <junit dir="./" failureproperty="test.failure" printSummary="yes" fork="true" haltonerror="true">
+      <sysproperty key="basedir" value=".">
+      </sysproperty>
+      <formatter type="xml">
+      </formatter>
+      <formatter usefile="false" type="plain">
+      </formatter>
+      <classpath>
+        <fileset dir="${libdir}">
+          <include name="*.jar">
+          </include>
+        </fileset>
+        <pathelement path="${testclassesdir}">
+        </pathelement>
+        <pathelement path="${classesdir}">
+        </pathelement>
+      </classpath>
+      <batchtest todir="${testreportdir}">
+        <fileset dir="src/test">
+          <include name="**/*Test*">
+          </include>
+          <exclude name="**/testtools/**">
+          </exclude>
+        </fileset>
+      </batchtest>
+    </junit>
+  </target>
+  <target name="compile-tests" depends="compile">
+    <mkdir dir="${testclassesdir}">
+    </mkdir>
+    <javac destdir="${testclassesdir}" deprecation="true" debug="true" optimize="false" excludes="**/package.html">
+      <src>
+        <pathelement location="src/test">
+        </pathelement>
+      </src>
+      <classpath>
+        <fileset dir="${libdir}">
+          <include name="*.jar">
+          </include>
+        </fileset>
+        <pathelement path="${classesdir}">
+        </pathelement>
+      </classpath>
+    </javac>
+  </target>
+  <target name="javadoc" description="o Generate javadoc" depends="jar">
+    <mkdir dir="${javadocdir}">
+    </mkdir>
+    <tstamp>
+      <format pattern="2002-yyyy" property="year">
+      </format>
+    </tstamp>
+    <property name="copyright" value="Copyright &amp;copy;  The Apache Software Foundation. All Rights Reserved.">
+    </property>
+    <property name="title" value="IO 1.0 API">
+    </property>
+    <javadoc use="true" private="true" destdir="${javadocdir}" author="true" version="true" sourcepath="src/java" packagenames="org.apache.commons.io.*">
+      <classpath>
+        <fileset dir="${libdir}">
+          <include name="*.jar">
+          </include>
+        </fileset>
+        <pathelement location="target/${final.name}.jar">
+        </pathelement>
+      </classpath>
+    </javadoc>
+  </target>
+  <target name="get-deps" unless="noget" depends="init">
+    <get dest="${libdir}/junit-3.8.1.jar" usetimestamp="true" ignoreerrors="true" src="http://www.ibiblio.org/maven/junit/jars/junit-3.8.1.jar">
+    </get>
+    <get dest="${libdir}/junit-3.8.1.jar" usetimestamp="true" ignoreerrors="true" src="http://www.ibiblio.org/maven/junit/jars/junit-3.8.1.jar">
+    </get>
+    <get dest="${libdir}/ant-1.5.jar" usetimestamp="true" ignoreerrors="true" src="http://www.ibiblio.org/maven/ant/jars/ant-1.5.jar">
+    </get>
+    <get dest="${libdir}/ant-optional-1.5.jar" usetimestamp="true" ignoreerrors="true" src="http://www.ibiblio.org/maven/ant/jars/ant-optional-1.5.jar">
+    </get>
+  </target>
+  <target name="install-maven">
+    <get dest="${user.home}/maven-install-latest.jar" usetimestamp="true" src="${repo}/maven/maven-install-latest.jar">
+    </get>
+    <unjar dest="${maven.home}" src="${user.home}/maven-install-latest.jar">
+    </unjar>
+  </target>
+</project>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/commons-io-1.0.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/commons-io-1.0.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/maven.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/maven.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/maven.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,83 @@
+ <!--
+   Copyright 2002-2004 The Apache Software Foundation
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+  -->
+<project
+    xmlns:j="jelly:core"
+    xmlns:ant="jelly:ant">
+
+  <!-- ============== DIST ================== -->
+  <!-- Copied from Commons-Collections        -->
+  <postGoal name="dist:prepare-bin-filesystem">
+    <j:set var="maven.dist.bin.assembly.dir" value="${pom.getPluginContext('maven-dist-plugin').getVariable('maven.dist.bin.assembly.dir')}" />
+    
+    <!-- Copy Files -->
+    <ant:copy todir="${maven.dist.bin.assembly.dir}">
+      <ant:fileset dir=".">
+        <ant:include name="RELEASE-NOTES.html"/>
+        <ant:include name="NOTICE.txt"/>
+      </ant:fileset>
+    </ant:copy>
+
+    <!-- Copy Jars -->
+    <ant:copy todir="${maven.dist.bin.assembly.dir}">
+      <ant:fileset dir="${maven.build.dir}">
+        <ant:include name="*.jar"/>
+      </ant:fileset>
+    </ant:copy>
+
+  </postGoal>
+  
+  <postGoal name="dist:prepare-src-filesystem">
+    <j:set var="maven.dist.src.assembly.dir" value="${pom.getPluginContext('maven-dist-plugin').getVariable('maven.dist.src.assembly.dir')}" />
+    
+    <!-- Copy Files -->
+    <ant:copy todir="${maven.dist.src.assembly.dir}">
+      <ant:fileset dir=".">
+        <ant:include name="RELEASE-NOTES.html"/>
+        <ant:include name="NOTICE.txt"/>
+        <ant:include name="PROPOSAL.html"/>
+        <ant:include name="STATUS.html"/>
+      </ant:fileset>
+    </ant:copy>
+
+    <!-- Copy Jars -->
+    <ant:copy todir="${maven.dist.src.assembly.dir}">
+      <ant:fileset dir="${maven.build.dir}">
+        <ant:include name="*.jar"/>
+      </ant:fileset>
+    </ant:copy>
+    
+    <!-- Copy XDocs -->
+    <ant:copy todir="${maven.dist.src.assembly.dir}/xdocs">
+      <ant:fileset dir="xdocs" />
+    </ant:copy>
+    
+  </postGoal>
+  
+  <postGoal name="dist:build-bin">
+    <j:set var="distDir" value="${pom.getPluginContext('maven-dist-plugin').getVariable('maven.dist.dir')}"/>
+    <j:set var="finalName" value="${pom.getPluginContext('maven-dist-plugin').getVariable('maven.final.name')}"/>
+    <ant:checksum file="${distDir}/${finalName}.tar.gz"/>
+    <ant:checksum file="${distDir}/${finalName}.zip"/>
+  </postGoal>
+  
+  <postGoal name="dist:build-src">
+    <j:set var="distDir" value="${pom.getPluginContext('maven-dist-plugin').getVariable('maven.dist.dir')}"/>
+    <j:set var="finalName" value="${pom.getPluginContext('maven-dist-plugin').getVariable('maven.final.name')}"/>
+    <ant:checksum file="${distDir}/${finalName}-src.tar.gz"/>
+    <ant:checksum file="${distDir}/${finalName}-src.zip"/>
+  </postGoal>
+  
+</project>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/project.properties
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/project.properties	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/project.properties	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,7 @@
+maven.xdoc.jsl=../commons-build/commons-site.jsl
+maven.xdoc.date=left
+maven.xdoc.version=${pom.currentVersion}
+maven.xdoc.developmentProcessUrl=http://jakarta.apache.org/commons/charter.html
+maven.xdoc.poweredby.image=maven-feather.png
+
+maven.javadoc.links=http://java.sun.com/j2se/1.3/docs/api/

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/project.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/project.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/project.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,215 @@
+<?xml version="1.0"?>
+<!--
+   Copyright 2001-2004 The Apache Software Foundation
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+-->
+<project>
+  <pomVersion>3</pomVersion>
+  
+  <name>IO</name>
+  <id>commons-io</id>
+  <currentVersion>1.0</currentVersion>
+  <inceptionYear>2002</inceptionYear>
+  <shortDescription>Commons IO</shortDescription>
+  <description>
+        Commons-IO contains utility classes, stream implementations, file filters, and endian classes.
+  </description>
+  <logo>/images/io-logo-white.png</logo>
+  
+  <url>http://jakarta.apache.org/commons/${pom.artifactId.substring(8)}/</url>
+  <package>org.apache.commons.${pom.artifactId.substring(8)}</package>
+
+  <organization>
+    <name>The Apache Software Foundation</name>
+    <url>http://jakarta.apache.org</url>
+    <logo>http://jakarta.apache.org/images/original-jakarta-logo.gif</logo>
+  </organization>
+
+  <licenses>
+	<license>
+    	<name>The Apache Software License, Version 2.0</name>
+    	<url>/LICENSE.txt</url>
+    	<distribution>repo</distribution>
+	</license>
+  </licenses>
+  
+  <gumpRepositoryId>jakarta</gumpRepositoryId>
+  <issueTrackingUrl>http://issues.apache.org/bugzilla/</issueTrackingUrl>
+  <siteAddress>jakarta.apache.org</siteAddress>
+  <siteDirectory>/www/jakarta.apache.org/commons/${pom.artifactId.substring(8)}/</siteDirectory>
+  <distributionDirectory>/www/jakarta.apache.org/builds/jakarta-commons/${pom.artifactId.substring(8)}/</distributionDirectory>
+  
+  <repository>
+    <connection>scm:cvs:pserver:anoncvs at cvs.apache.org:/home/cvspublic:jakarta-commons/${pom.artifactId.substring(8)}</connection>
+    <url>http://cvs.apache.org/viewcvs/jakarta-commons/${pom.artifactId.substring(8)}/</url>
+  </repository>
+  
+  <mailingLists>
+    <mailingList>
+      <name>Commons Dev List</name>
+      <subscribe>commons-dev-subscribe at jakarta.apache.org</subscribe>
+      <unsubscribe>commons-dev-unsubscribe at jakarta.apache.org</unsubscribe>
+      <archive>http://nagoya.apache.org/eyebrowse/SummarizeList?listName=commons-dev at jakarta.apache.org</archive>
+    </mailingList>
+    <mailingList>
+      <name>Commons User List</name>
+      <subscribe>commons-user-subscribe at jakarta.apache.org</subscribe>
+      <unsubscribe>commons-user-unsubscribe at jakarta.apache.org</unsubscribe>
+      <archive>http://nagoya.apache.org/eyebrowse/SummarizeList?listName=commons-user at jakarta.apache.org</archive>
+    </mailingList>
+  </mailingLists>
+  
+
+    <developers>
+        <developer>
+            <name>Scott Sanders</name>
+            <id>sanders</id>
+            <email>sanders at apache.org</email>
+            <organization></organization>
+            <roles>
+                <role>Java Developer</role>
+            </roles>
+        </developer>
+
+        <developer>
+            <name>dIon Gillard</name>
+            <id>dion</id>
+            <email>dion at apache.org</email>
+            <organization></organization>
+            <roles>
+                <role>Java Developer</role>
+            </roles>
+        </developer>
+
+        <developer>
+            <name>Nicola Ken Barozzi</name>
+            <id>nicolaken</id>
+            <email>nicolaken at apache.org</email>
+            <organization></organization>
+            <roles>
+                <role>Java Developer</role>
+            </roles>
+        </developer>
+
+        <developer>
+            <name>Henri Yandell</name>
+            <id>bayard</id>
+            <email>bayard at apache.org</email>
+            <organization></organization>
+            <roles>
+                <role>Java Developer</role>
+            </roles>
+        </developer>
+
+        <developer>
+            <name>Stephen Colebourne</name>
+            <id>scolebourne</id>
+            <organization>SITA ATS</organization>
+            <roles>
+                <role>Java Developer</role>
+            </roles>
+        </developer>
+
+        <developer>
+            <name>Jeremias Maerki</name>
+            <id>jeremias</id>
+            <email>jeremias at apache.org</email>
+            <organization/>
+            <roles>
+                <role>Java Developer</role>
+            </roles>
+            <url>http://nagoya.apache.org/wiki/apachewiki.cgi?JeremiasMaerki</url>
+            <timezone>+1</timezone>
+        </developer>
+
+        <developer>
+            <name>Matthew Hawthorne</name>
+            <id>matth</id>
+            <email>matth at apache.org</email>
+            <organization/>
+            <roles>
+                <role>Java Developer</role>
+            </roles>
+        </developer>
+
+        <developer>
+            <name>Martin Cooper</name>
+            <id>martinc</id>
+            <email>martinc at apache.org</email>
+            <organization/>
+            <roles>
+                <role>Java Developer</role>
+            </roles>
+        </developer>
+
+    </developers>
+
+    <contributors>
+        <contributor>
+            <name>Alban Peignier</name>
+            <email>alban.peignier at free.fr</email>
+        </contributor>
+    </contributors>
+
+    <dependencies>
+        <dependency>
+            <id>junit</id>
+            <version>3.8.1</version>
+        </dependency>
+    </dependencies>
+
+    <build>
+    	<nagEmailAddress>commons-dev at jakarta.apache.org</nagEmailAddress>
+    	<sourceDirectory>src/java</sourceDirectory>
+    	<unitTestSourceDirectory>src/test</unitTestSourceDirectory>
+        <!-- Unit test classes -->
+        <!-- TODO Organize test inclusions and exclusions -->
+        <unitTest>
+            <includes>
+                <include>**/*Test*</include>
+            </includes>
+            <excludes>
+                <exclude>**/testtools/**</exclude>
+            </excludes>
+        </unitTest>
+
+        <resources>
+            <resource>
+              <targetPath>META-INF</targetPath>
+              <includes>
+                <include>NOTICE.txt</include>
+              </includes>
+            </resource>
+        </resources>
+
+    </build>
+
+  <reports>
+     <report>maven-changelog-plugin</report>
+     <report>maven-changes-plugin</report>
+     <!--report>maven-checkstyle-plugin</report-->
+     <!--report>maven-clover-plugin</report-->
+     <report>maven-developer-activity-plugin</report>
+     <report>maven-file-activity-plugin</report>
+     <report>maven-javadoc-plugin</report>
+     <!--report>maven-jellydoc-plugin</report-->
+     <report>maven-junit-report-plugin</report>
+     <report>maven-jxr-plugin</report>
+     <report>maven-license-plugin</report>
+     <!--report>maven-linkcheck-plugin</report-->
+     <!--report>maven-statcvs-plugin</report-->
+     <!--report>maven-tasklist-plugin</report-->
+  </reports>
+
+</project>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/conf/MANIFEST.MF
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/conf/MANIFEST.MF	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/conf/MANIFEST.MF	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,5 @@
+Extension-Name: @package@
+Specification-Vendor: Apache Software Foundation
+Specification-Version: 1.0
+Implementation-Vendor: Apache Software Foundation
+Implementation-Version: @version@

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/CopyUtils.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/CopyUtils.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/CopyUtils.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,317 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.StringReader;
+import java.io.Writer;
+
+/**
+ * <p>
+ * This class provides static utility methods for buffered
+ * copying between sources (<code>InputStream</code>, <code>Reader</code>, <code>String</code> and
+ * <code>byte[]</code>) and destinations (<code>OutputStream</code>, <code>Writer</code>,
+ * <code>String</code> and <code>byte[]</code>).
+ * </p>
+ *
+ * <p>Unless otherwise noted, these <code>copy</code> methods do <em>not</em> flush or close the
+ * streams. Often doing so would require making non-portable assumptions about the streams' origin
+ * and further use. This means that both streams' <code>close()</code> methods must be called after
+ * copying. if one omits this step, then the stream resources (sockets, file descriptors) are
+ * released when the associated Stream is garbage-collected. It is not a good idea to rely on this
+ * mechanism. For a good overview of the distinction between "memory management" and "resource
+ * management", see <a href="http://www.unixreview.com/articles/1998/9804/9804ja/ja.htm">this
+ * UnixReview article</a>.</p>
+ *
+ * <p>For byte-to-char methods, a <code>copy</code> variant allows the encoding 
+ * to be selected (otherwise the platform default is used). We would like to 
+ * encourage you to always specify the encoding because relying on the platform
+ * default can lead to unexpected results.</p>
+ *
+ * <p>We don't provide special variants for the <code>copy</code> methods that
+ * let you specify the buffer size because in modern VMs the impact on speed
+ * seems to be minimal. We're using a default buffer size of 4 KB.</p>
+ *
+ * <p>The <code>copy</code> methods use an internal buffer when copying. It is therefore advisable
+ * <em>not</em> to deliberately wrap the stream arguments to the <code>copy</code> methods in
+ * <code>Buffered*</code> streams. For example, don't do the
+ * following:</p>
+ *
+ * <code>copy( new BufferedInputStream( in ), new BufferedOutputStream( out ) );</code>
+ *
+ * <p>The rationale is as follows:</p>
+ *
+ * <p>Imagine that an InputStream's read() is a very expensive operation, which would usually suggest
+ * wrapping in a BufferedInputStream. The BufferedInputStream works by issuing infrequent
+ * {@link java.io.InputStream#read(byte[] b, int off, int len)} requests on the underlying InputStream, to
+ * fill an internal buffer, from which further <code>read</code> requests can inexpensively get
+ * their data (until the buffer runs out).</p>
+ * <p>However, the <code>copy</code> methods do the same thing, keeping an internal buffer,
+ * populated by {@link InputStream#read(byte[] b, int off, int len)} requests. Having two buffers
+ * (or three if the destination stream is also buffered) is pointless, and the unnecessary buffer
+ * management hurts performance slightly (about 3%, according to some simple experiments).</p>
+ *
+ * <p>Behold, intrepid explorers; a map of this class:</p>
+ * <pre>
+ *       Method      Input               Output          Dependency
+ *       ------      -----               ------          -------
+ * 1     copy        InputStream         OutputStream    (primitive)
+ * 2     copy        Reader              Writer          (primitive)
+ *
+ * 3     copy        InputStream         Writer          2
+ *
+ * 4     copy        Reader              OutputStream    2
+ *
+ * 5     copy        String              OutputStream    2
+ * 6     copy        String              Writer          (trivial)
+ *
+ * 7     copy        byte[]              Writer          3
+ * 8     copy        byte[]              OutputStream    (trivial)
+ * </pre>
+ *
+ * <p>Note that only the first two methods shuffle bytes; the rest use these
+ * two, or (if possible) copy using native Java copy methods. As there are
+ * method variants to specify the encoding, each row may
+ * correspond to up to 2 methods.</p>
+ *
+ * <p>Origin of code: Apache Avalon (Excalibur)</p>
+ *
+ * @author Peter Donald
+ * @author Jeff Turner
+ * @author Matthew Hawthorne
+ * @version $Id: CopyUtils.java,v 1.6 2004/04/24 23:49:25 bayard Exp $
+ */
+public class CopyUtils {
+
+    /**
+     * The name says it all.
+     */
+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;
+
+    /**
+     * Instances should NOT be constructed in standard programming.
+     */
+    public CopyUtils() {}
+
+    // ----------------------------------------------------------------
+    // byte[] -> OutputStream
+    // ----------------------------------------------------------------
+
+    /**
+     * Copy bytes from a <code>byte[]</code> to an <code>OutputStream</code>.
+     * @param input the byte array to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @throws IOException In case of an I/O problem
+     */
+    public static void copy(byte[] input, OutputStream output)
+            throws IOException {
+        output.write(input);
+    }
+
+    // ----------------------------------------------------------------
+    // byte[] -> Writer
+    // ----------------------------------------------------------------
+
+    /**
+     * Copy and convert bytes from a <code>byte[]</code> to chars on a
+     * <code>Writer</code>.
+     * The platform's default encoding is used for the byte-to-char conversion.
+     * @param input the byte array to read from
+     * @param output the <code>Writer</code> to write to
+     * @throws IOException In case of an I/O problem
+     */
+    public static void copy(byte[] input, Writer output)
+            throws IOException {
+        ByteArrayInputStream in = new ByteArrayInputStream(input);
+        copy(in, output);
+    }
+
+
+    /**
+     * Copy and convert bytes from a <code>byte[]</code> to chars on a
+     * <code>Writer</code>, using the specified encoding.
+     * @param input the byte array to read from
+     * @param output the <code>Writer</code> to write to
+     * @param encoding The name of a supported character encoding. See the
+     * <a href="http://www.iana.org/assignments/character-sets">IANA
+     * Charset Registry</a> for a list of valid encoding types.
+     * @throws IOException In case of an I/O problem
+     */
+    public static void copy(
+            byte[] input,
+            Writer output,
+            String encoding)
+                throws IOException {
+        ByteArrayInputStream in = new ByteArrayInputStream(input);
+        copy(in, output, encoding);
+    }
+
+
+    // ----------------------------------------------------------------
+    // Core copy methods
+    // ----------------------------------------------------------------
+
+    /**
+     * Copy bytes from an <code>InputStream</code> to an <code>OutputStream</code>.
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @return the number of bytes copied
+     * @throws IOException In case of an I/O problem
+     */
+    public static int copy(
+            InputStream input,
+            OutputStream output)
+                throws IOException {
+        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
+        int count = 0;
+        int n = 0;
+        while (-1 != (n = input.read(buffer))) {
+            output.write(buffer, 0, n);
+            count += n;
+        }
+        return count;
+    }
+
+    // ----------------------------------------------------------------
+    // Reader -> Writer
+    // ----------------------------------------------------------------
+
+    /**
+     * Copy chars from a <code>Reader</code> to a <code>Writer</code>.
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @return the number of characters copied
+     * @throws IOException In case of an I/O problem
+     */
+    public static int copy(
+            Reader input,
+            Writer output)
+                throws IOException {
+        char[] buffer = new char[DEFAULT_BUFFER_SIZE];
+        int count = 0;
+        int n = 0;
+        while (-1 != (n = input.read(buffer))) {
+            output.write(buffer, 0, n);
+            count += n;
+        }
+        return count;
+    }
+
+    // ----------------------------------------------------------------
+    // InputStream -> Writer
+    // ----------------------------------------------------------------
+
+    /**
+     * Copy and convert bytes from an <code>InputStream</code> to chars on a
+     * <code>Writer</code>.
+     * The platform's default encoding is used for the byte-to-char conversion.
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @throws IOException In case of an I/O problem
+     */
+    public static void copy(
+            InputStream input,
+            Writer output)
+                throws IOException {
+        InputStreamReader in = new InputStreamReader(input);
+        copy(in, output);
+    }
+
+    /**
+     * Copy and convert bytes from an <code>InputStream</code> to chars on a
+     * <code>Writer</code>, using the specified encoding.
+     * @param input the <code>InputStream</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @param encoding The name of a supported character encoding. See the
+     * <a href="http://www.iana.org/assignments/character-sets">IANA
+     * Charset Registry</a> for a list of valid encoding types.
+     * @throws IOException In case of an I/O problem
+     */
+    public static void copy(
+            InputStream input,
+            Writer output,
+            String encoding)
+                throws IOException {
+        InputStreamReader in = new InputStreamReader(input, encoding);
+        copy(in, output);
+    }
+
+
+    // ----------------------------------------------------------------
+    // Reader -> OutputStream
+    // ----------------------------------------------------------------
+
+    /**
+     * Serialize chars from a <code>Reader</code> to bytes on an 
+     * <code>OutputStream</code>, and flush the <code>OutputStream</code>.
+     * @param input the <code>Reader</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @throws IOException In case of an I/O problem
+     */
+    public static void copy(
+            Reader input,
+            OutputStream output)
+                throws IOException {
+        OutputStreamWriter out = new OutputStreamWriter(output);
+        copy(input, out);
+        // XXX Unless anyone is planning on rewriting OutputStreamWriter, we have to flush here.
+        out.flush();
+    }
+
+    // ----------------------------------------------------------------
+    // String -> OutputStream
+    // ----------------------------------------------------------------
+
+    /**
+     * Serialize chars from a <code>String</code> to bytes on an <code>OutputStream</code>, and
+     * flush the <code>OutputStream</code>.
+     * @param input the <code>String</code> to read from
+     * @param output the <code>OutputStream</code> to write to
+     * @throws IOException In case of an I/O problem
+     */
+    public static void copy(
+            String input,
+            OutputStream output)
+                throws IOException {
+        StringReader in = new StringReader(input);
+        OutputStreamWriter out = new OutputStreamWriter(output);
+        copy(in, out);
+        // XXX Unless anyone is planning on rewriting OutputStreamWriter, we have to flush here.
+        out.flush();
+    }
+
+    // ----------------------------------------------------------------
+    // String -> Writer
+    // ----------------------------------------------------------------
+
+    /**
+     * Copy chars from a <code>String</code> to a <code>Writer</code>.
+     * @param input the <code>String</code> to read from
+     * @param output the <code>Writer</code> to write to
+     * @throws IOException In case of an I/O problem
+     */
+    public static void copy(String input, Writer output)
+                throws IOException {
+        output.write(input);
+    }
+
+} // CopyUtils

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/EndianUtils.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/EndianUtils.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/EndianUtils.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,483 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Utility code for dealing with different endian systems.
+ * <br>
+ * Origin of code: Apache Avalon (Excalibur)
+ *
+ * @author <a href="mailto:peter at apache.org">Peter Donald</a>
+ * @version CVS $Revision: 1.13 $ $Date: 2004/02/23 04:35:59 $
+ */
+public final class EndianUtils
+{
+
+    /**
+     * Instances should NOT be constructed in standard programming.
+     */
+    public EndianUtils() { }
+
+    // ========================================== Swapping routines
+
+    /**
+     * Converts a "short" value between endian systems.
+     * @param value value to convert
+     * @return the converted value
+     */
+    public static short swapShort( short value )
+    {
+        return (short)( ( ( ( value >> 0 ) & 0xff ) << 8 ) +
+            ( ( ( value >> 8 ) & 0xff ) << 0 ) );
+    }
+
+    /**
+     * Converts a "int" value between endian systems.
+     * @param value value to convert
+     * @return the converted value
+     */
+    public static int swapInteger( int value )
+    {
+        return
+            ( ( ( value >> 0 ) & 0xff ) << 24 ) +
+            ( ( ( value >> 8 ) & 0xff ) << 16 ) +
+            ( ( ( value >> 16 ) & 0xff ) << 8 ) +
+            ( ( ( value >> 24 ) & 0xff ) << 0 );
+    }
+
+    /**
+     * Converts a "long" value between endian systems.
+     * @param value value to convert
+     * @return the converted value
+     */
+    public static long swapLong( long value )
+    {
+        return
+            ( ( ( value >> 0 ) & 0xff ) << 56 ) +
+            ( ( ( value >> 8 ) & 0xff ) << 48 ) +
+            ( ( ( value >> 16 ) & 0xff ) << 40 ) +
+            ( ( ( value >> 24 ) & 0xff ) << 32 ) +
+            ( ( ( value >> 32 ) & 0xff ) << 24 ) +
+            ( ( ( value >> 40 ) & 0xff ) << 16 ) +
+            ( ( ( value >> 48 ) & 0xff ) << 8 ) +
+            ( ( ( value >> 56 ) & 0xff ) << 0 );
+    }
+
+    /**
+     * Converts a "float" value between endian systems.
+     * @param value value to convert
+     * @return the converted value
+     */
+    public static float swapFloat( float value )
+    {
+        return Float.intBitsToFloat( swapInteger( Float.floatToIntBits( value ) ) );
+    }
+
+    /**
+     * Converts a "double" value between endian systems.
+     * @param value value to convert
+     * @return the converted value
+     */
+    public static double swapDouble( double value )
+    {
+        return Double.longBitsToDouble( swapLong( Double.doubleToLongBits( value ) ) );
+    }
+
+    // ========================================== Swapping read/write routines
+
+    /**
+     * Writes a "short" value to a byte array at a given offset. The value is
+     * converted to the opposed endian system while writing.
+     * @param data target byte array
+     * @param offset starting offset in the byte array
+     * @param value value to write
+     */
+    public static void writeSwappedShort( byte[] data, int offset, short value )
+    {
+        data[ offset + 0 ] = (byte)( ( value >> 0 ) & 0xff );
+        data[ offset + 1 ] = (byte)( ( value >> 8 ) & 0xff );
+    }
+
+    /**
+     * Reads a "short" value from a byte array at a given offset. The value is
+     * converted to the opposed endian system while reading.
+     * @param data source byte array
+     * @param offset starting offset in the byte array
+     * @return the value read
+     */
+    public static short readSwappedShort( byte[] data, int offset )
+    {
+        return (short)( ( ( data[ offset + 0 ] & 0xff ) << 0 ) +
+            ( ( data[ offset + 1 ] & 0xff ) << 8 ) );
+    }
+
+    /**
+     * Reads an unsigned short (16-bit) value from a byte array at a given 
+     * offset. The value is converted to the opposed endian system while 
+     * reading.
+     * @param data source byte array
+     * @param offset starting offset in the byte array
+     * @return the value read
+     */
+    public static int readSwappedUnsignedShort( byte[] data, int offset )
+    {
+        return (int)( ( ( data[ offset + 0 ] & 0xff ) << 0 ) +
+            ( ( data[ offset + 1 ] & 0xff ) << 8 ) );
+    }
+
+    /**
+     * Writes a "int" value to a byte array at a given offset. The value is
+     * converted to the opposed endian system while writing.
+     * @param data target byte array
+     * @param offset starting offset in the byte array
+     * @param value value to write
+     */
+    public static void writeSwappedInteger( byte[] data, int offset, int value )
+    {
+        data[ offset + 0 ] = (byte)( ( value >> 0 ) & 0xff );
+        data[ offset + 1 ] = (byte)( ( value >> 8 ) & 0xff );
+        data[ offset + 2 ] = (byte)( ( value >> 16 ) & 0xff );
+        data[ offset + 3 ] = (byte)( ( value >> 24 ) & 0xff );
+    }
+
+    /**
+     * Reads a "int" value from a byte array at a given offset. The value is
+     * converted to the opposed endian system while reading.
+     * @param data source byte array
+     * @param offset starting offset in the byte array
+     * @return the value read
+     */
+    public static int readSwappedInteger( byte[] data, int offset )
+    {
+        return (int)( ( ( data[ offset + 0 ] & 0xff ) << 0 ) +
+            ( ( data[ offset + 1 ] & 0xff ) << 8 ) +
+            ( ( data[ offset + 2 ] & 0xff ) << 16 ) +
+            ( ( data[ offset + 3 ] & 0xff ) << 24 ) );
+    }
+
+    /**
+     * Reads an unsigned integer (32-bit) value from a byte array at a given 
+     * offset. The value is converted to the opposed endian system while 
+     * reading.
+     * @param data source byte array
+     * @param offset starting offset in the byte array
+     * @return the value read
+     */
+    public static long readSwappedUnsignedInteger( byte[] data, int offset )
+    {
+        return (long)( ( ( data[ offset + 0 ] & 0xff ) << 0 ) +
+            ( ( data[ offset + 1 ] & 0xff ) << 8 ) +
+            ( ( data[ offset + 2 ] & 0xff ) << 16 ) +
+            ( ( data[ offset + 3 ] & 0xff ) << 24 ) );
+    }
+
+    /**
+     * Writes a "long" value to a byte array at a given offset. The value is
+     * converted to the opposed endian system while writing.
+     * @param data target byte array
+     * @param offset starting offset in the byte array
+     * @param value value to write
+     */
+    public static void writeSwappedLong( byte[] data, int offset, long value )
+    {
+        data[ offset + 0 ] = (byte)( ( value >> 0 ) & 0xff );
+        data[ offset + 1 ] = (byte)( ( value >> 8 ) & 0xff );
+        data[ offset + 2 ] = (byte)( ( value >> 16 ) & 0xff );
+        data[ offset + 3 ] = (byte)( ( value >> 24 ) & 0xff );
+        data[ offset + 4 ] = (byte)( ( value >> 32 ) & 0xff );
+        data[ offset + 5 ] = (byte)( ( value >> 40 ) & 0xff );
+        data[ offset + 6 ] = (byte)( ( value >> 48 ) & 0xff );
+        data[ offset + 7 ] = (byte)( ( value >> 56 ) & 0xff );
+    }
+
+    /**
+     * Reads a "long" value from a byte array at a given offset. The value is
+     * converted to the opposed endian system while reading.
+     * @param data source byte array
+     * @param offset starting offset in the byte array
+     * @return the value read
+     */
+    public static long readSwappedLong( byte[] data, int offset )
+    {
+        long low = (long)( 
+            ( ( data[ offset + 0 ] & 0xff ) << 0 ) +
+            ( ( data[ offset + 1 ] & 0xff ) << 8 ) +
+            ( ( data[ offset + 2 ] & 0xff ) << 16 ) +
+            ( ( data[ offset + 3 ] & 0xff ) << 24 ) );
+        long high = (long)(
+            ( ( data[ offset + 4 ] & 0xff ) << 0 ) +
+            ( ( data[ offset + 5 ] & 0xff ) << 8 ) +
+            ( ( data[ offset + 6 ] & 0xff ) << 16 ) +
+            ( ( data[ offset + 7 ] & 0xff ) << 24 ) );
+        return low + (high << 32);
+    }
+
+    /**
+     * Writes a "float" value to a byte array at a given offset. The value is
+     * converted to the opposed endian system while writing.
+     * @param data target byte array
+     * @param offset starting offset in the byte array
+     * @param value value to write
+     */
+    public static void writeSwappedFloat( byte[] data, int offset, float value )
+    {
+        writeSwappedInteger( data, offset, Float.floatToIntBits( value ) );
+    }
+
+    /**
+     * Reads a "float" value from a byte array at a given offset. The value is
+     * converted to the opposed endian system while reading.
+     * @param data source byte array
+     * @param offset starting offset in the byte array
+     * @return the value read
+     */
+    public static float readSwappedFloat( byte[] data, int offset )
+    {
+        return Float.intBitsToFloat( readSwappedInteger( data, offset ) );
+    }
+
+    /**
+     * Writes a "double" value to a byte array at a given offset. The value is
+     * converted to the opposed endian system while writing.
+     * @param data target byte array
+     * @param offset starting offset in the byte array
+     * @param value value to write
+     */
+    public static void writeSwappedDouble( byte[] data, int offset, double value )
+    {
+        writeSwappedLong( data, offset, Double.doubleToLongBits( value ) );
+    }
+
+    /**
+     * Reads a "double" value from a byte array at a given offset. The value is
+     * converted to the opposed endian system while reading.
+     * @param data source byte array
+     * @param offset starting offset in the byte array
+     * @return the value read
+     */
+    public static double readSwappedDouble( byte[] data, int offset )
+    {
+        return Double.longBitsToDouble( readSwappedLong( data, offset ) );
+    }
+
+    /**
+     * Writes a "short" value to an OutputStream. The value is
+     * converted to the opposed endian system while writing.
+     * @param output target OutputStream
+     * @param value value to write
+     * @throws IOException in case of an I/O problem
+     */
+    public static void writeSwappedShort( OutputStream output, short value )
+        throws IOException
+    {
+        output.write( (byte)( ( value >> 0 ) & 0xff ) );
+        output.write( (byte)( ( value >> 8 ) & 0xff ) );
+    }
+
+    /**
+     * Reads a "short" value from an InputStream. The value is
+     * converted to the opposed endian system while reading.
+     * @param input source InputStream
+     * @return the value just read
+     * @throws IOException in case of an I/O problem
+     */
+    public static short readSwappedShort( InputStream input )
+        throws IOException
+    {
+        return (short)( ( ( read( input ) & 0xff ) << 0 ) +
+            ( ( read( input ) & 0xff ) << 8 ) );
+    }
+
+    /**
+     * Reads a unsigned short (16-bit) from an InputStream. The value is
+     * converted to the opposed endian system while reading.
+     * @param input source InputStream
+     * @return the value just read
+     * @throws IOException in case of an I/O problem
+     */
+    public static int readSwappedUnsignedShort( InputStream input )
+        throws IOException
+    {
+        int value1 = read( input );
+        int value2 = read( input );
+
+        return (int)( ( ( value1 & 0xff ) << 0 ) +
+            ( ( value2 & 0xff ) << 8 ) );
+    }
+
+    /**
+     * Writes a "int" value to an OutputStream. The value is
+     * converted to the opposed endian system while writing.
+     * @param output target OutputStream
+     * @param value value to write
+     * @throws IOException in case of an I/O problem
+     */
+    public static void writeSwappedInteger( OutputStream output, int value )
+        throws IOException
+    {
+        output.write( (byte)( ( value >> 0 ) & 0xff ) );
+        output.write( (byte)( ( value >> 8 ) & 0xff ) );
+        output.write( (byte)( ( value >> 16 ) & 0xff ) );
+        output.write( (byte)( ( value >> 24 ) & 0xff ) );
+    }
+
+    /**
+     * Reads a "int" value from an InputStream. The value is
+     * converted to the opposed endian system while reading.
+     * @param input source InputStream
+     * @return the value just read
+     * @throws IOException in case of an I/O problem
+     */
+    public static int readSwappedInteger( InputStream input )
+        throws IOException
+    {
+        int value1 = read( input );
+        int value2 = read( input );
+        int value3 = read( input );
+        int value4 = read( input );
+
+        return (int)( ( ( value1 & 0xff ) << 0 ) +
+            ( ( value2 & 0xff ) << 8 ) +
+            ( ( value3 & 0xff ) << 16 ) +
+            ( ( value4 & 0xff ) << 24 ) );
+    }
+
+    /**
+     * Reads a unsigned integer (32-bit) from an InputStream. The value is
+     * converted to the opposed endian system while reading.
+     * @param input source InputStream
+     * @return the value just read
+     * @throws IOException in case of an I/O problem
+     */
+    public static long readSwappedUnsignedInteger( InputStream input )
+        throws IOException
+    {
+        int value1 = read( input );
+        int value2 = read( input );
+        int value3 = read( input );
+        int value4 = read( input );
+
+        return (long)( ( ( value1 & 0xff ) << 0 ) +
+            ( ( value2 & 0xff ) << 8 ) +
+            ( ( value3 & 0xff ) << 16 ) +
+            ( ( value4 & 0xff ) << 24 ) );
+    }
+
+    /**
+     * Writes a "long" value to an OutputStream. The value is
+     * converted to the opposed endian system while writing.
+     * @param output target OutputStream
+     * @param value value to write
+     * @throws IOException in case of an I/O problem
+     */
+    public static void writeSwappedLong( OutputStream output, long value )
+        throws IOException
+    {
+        output.write( (byte)( ( value >> 0 ) & 0xff ) );
+        output.write( (byte)( ( value >> 8 ) & 0xff ) );
+        output.write( (byte)( ( value >> 16 ) & 0xff ) );
+        output.write( (byte)( ( value >> 24 ) & 0xff ) );
+        output.write( (byte)( ( value >> 32 ) & 0xff ) );
+        output.write( (byte)( ( value >> 40 ) & 0xff ) );
+        output.write( (byte)( ( value >> 48 ) & 0xff ) );
+        output.write( (byte)( ( value >> 56 ) & 0xff ) );
+    }
+
+    /**
+     * Reads a "long" value from an InputStream. The value is
+     * converted to the opposed endian system while reading.
+     * @param input source InputStream
+     * @return the value just read
+     * @throws IOException in case of an I/O problem
+     */
+    public static long readSwappedLong( InputStream input )
+        throws IOException
+    {
+        byte[] bytes = new byte[8];
+        input.read( bytes );
+        return readSwappedLong( bytes, 0 );
+    }
+
+    /**
+     * Writes a "float" value to an OutputStream. The value is
+     * converted to the opposed endian system while writing.
+     * @param output target OutputStream
+     * @param value value to write
+     * @throws IOException in case of an I/O problem
+     */
+    public static void writeSwappedFloat( OutputStream output, float value )
+        throws IOException
+    {
+        writeSwappedInteger( output, Float.floatToIntBits( value ) );
+    }
+
+    /**
+     * Reads a "float" value from an InputStream. The value is
+     * converted to the opposed endian system while reading.
+     * @param input source InputStream
+     * @return the value just read
+     * @throws IOException in case of an I/O problem
+     */
+    public static float readSwappedFloat( InputStream input )
+        throws IOException
+    {
+        return Float.intBitsToFloat( readSwappedInteger( input ) );
+    }
+
+    /**
+     * Writes a "double" value to an OutputStream. The value is
+     * converted to the opposed endian system while writing.
+     * @param output target OutputStream
+     * @param value value to write
+     * @throws IOException in case of an I/O problem
+     */
+    public static void writeSwappedDouble( OutputStream output, double value )
+        throws IOException
+    {
+        writeSwappedLong( output, Double.doubleToLongBits( value ) );
+    }
+
+    /**
+     * Reads a "double" value from an InputStream. The value is
+     * converted to the opposed endian system while reading.
+     * @param input source InputStream
+     * @return the value just read
+     * @throws IOException in case of an I/O problem
+     */
+    public static double readSwappedDouble( InputStream input )
+        throws IOException
+    {
+        return Double.longBitsToDouble( readSwappedLong( input ) );
+    }
+
+    private static int read( InputStream input )
+        throws IOException
+    {
+        int value = input.read();
+
+        if( -1 == value )
+        {
+            throw new EOFException( "Unexpected EOF reached" );
+        }
+
+        return value;
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/FileCleaner.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/FileCleaner.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/FileCleaner.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.File;
+import java.lang.ref.PhantomReference;
+import java.lang.ref.ReferenceQueue;
+import java.util.Collection;
+import java.util.Vector;
+
+/**
+ * Keeps track of files awaiting deletion, and deletes them when an associated
+ * marker object is reclaimed by the garbage collector.
+ *
+ * @author Noel Bergman
+ * @author Martin Cooper
+ *
+ * @version $Id: FileCleaner.java,v 1.1 2004/03/18 06:04:14 martinc Exp $
+ */
+public class FileCleaner {
+
+    /**
+     * Queue of <code>Tracker</code> instances being watched.
+     */
+    private static ReferenceQueue /* Tracker */ q = new ReferenceQueue();
+
+    /**
+     * Collection of <code>Tracker</code> instances in existence.
+     */
+    private static Collection /* Tracker */ trackers = new Vector();
+
+    /**
+     * The thread that will clean up registered files.
+     */
+    private static Thread reaper = new Thread("File Reaper") {
+
+        /**
+         * Run the reaper thread that will delete files as their associated
+         * marker objects are reclaimed by the garbage collector.
+         */
+        public void run() {
+            for (;;) {
+                Tracker tracker = null;
+                try {
+                    // Wait for a tracker to remove.
+                    tracker = (Tracker) q.remove();
+                } catch(Exception _) {
+                    continue;
+                }
+
+                tracker.delete();
+                tracker.clear();
+                trackers.remove(tracker);
+            }
+        }
+    };
+
+    /**
+     * The static initializer that starts the reaper thread.
+     */
+    static {
+        reaper.setPriority(Thread.MAX_PRIORITY);
+        reaper.setDaemon(true);
+        reaper.start();
+    }
+
+    /**
+     * Track the specified file, using the provided marker, deleting the file
+     * when the marker instance is garbage collected.
+     *
+     * @param file   The file to be tracked.
+     * @param marker The marker object used to track the file.
+     */
+    public static void track(File file, Object marker) {
+        trackers.add(new Tracker(file, marker, q));
+    }
+
+    /**
+     * Track the specified file, using the provided marker, deleting the file
+     * when the marker instance is garbage collected.
+     *
+     * @param path   The full path to the file to be tracked.
+     * @param marker The marker object used to track the file.
+     */
+    public static void track(String path, Object marker) {
+        trackers.add(new Tracker(path, marker, q));
+    }
+
+    /**
+     * Retrieve the number of files currently being tracked, and therefore
+     * awaiting deletion.
+     *
+     * @return the number of files being tracked.
+     */
+    public static int getTrackCount() {
+        return trackers.size();
+    }
+
+    /**
+     * Inner class which acts as the reference for a file pending deletion.
+     */
+    private static class Tracker extends PhantomReference {
+
+        /**
+         * The full path to the file being tracked.
+         */
+        private String path;
+
+        /**
+         * Constructs an instance of this class from the supplied parameters.
+         *
+         * @param file   The file to be tracked.
+         * @param marker The marker object used to track the file.
+         * @param q      The queue on to which the tracker will be pushed.
+         */
+        public Tracker(File file, Object marker, ReferenceQueue q) {
+            this(file.getPath(), marker, q);
+        }
+
+        /**
+         * Constructs an instance of this class from the supplied parameters.
+         *
+         * @param path   The full path to the file to be tracked.
+         * @param marker The marker object used to track the file.
+         * @param q      The queue on to which the tracker will be pushed.
+         */
+        public Tracker(String path, Object marker, ReferenceQueue q) {
+            super(marker, q);
+            this.path = path;
+        }
+
+        /**
+         * Deletes the file associated with this tracker instance.
+         *
+         * @return <code>true</code> if the file was deleted successfully;
+         *         <code>false</code> otherwise.
+         */
+        public boolean delete() {
+            return new File(path).delete();
+        }
+    }
+}
\ No newline at end of file

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/FileUtils.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/FileUtils.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/FileUtils.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,844 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.FileFilter;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.Collection;
+import java.util.Date;
+
+import org.apache.commons.io.filefilter.DirectoryFileFilter;
+import org.apache.commons.io.filefilter.FalseFileFilter;
+import org.apache.commons.io.filefilter.FileFilterUtils;
+import org.apache.commons.io.filefilter.IOFileFilter;
+import org.apache.commons.io.filefilter.SuffixFileFilter;
+import org.apache.commons.io.filefilter.TrueFileFilter;
+
+/**
+ * This class provides basic facilities for manipulating files and file paths.
+ *
+ * <h3>Path-related methods</h3>
+ *
+ * <p>Methods exist to retrieve the components of a typical file path. For example
+ * <code>/www/hosted/mysite/index.html</code>, can be broken into:
+ * <ul>
+ *   <li><code>/www/hosted/mysite/</code> -- retrievable through {@link #getPath}</li>
+ *   <li><code>index.html</code> -- retrievable through {@link #removePath}</li>
+ *   <li><code>/www/hosted/mysite/index</code> -- retrievable through {@link #removeExtension}</li>
+ *   <li><code>html</code> -- retrievable through {@link #getExtension}</li>
+ * </ul>
+ * There are also methods to {@link #catPath concatenate two paths}, {@link #resolveFile resolve a
+ * path relative to a File} and {@link #normalize} a path.
+ * </p>
+ *
+ * <h3>File-related methods</h3>
+ * <p>
+ * There are methods to  create a {@link #toFile File from a URL}, copy a
+ * {@link #copyFileToDirectory File to a directory},
+ * copy a {@link #copyFile File to another File},
+ * copy a {@link #copyURLToFile URL's contents to a File},
+ * as well as methods to {@link #deleteDirectory(File) delete} and {@link #cleanDirectory(File)
+ * clean} a directory.
+ * </p>
+ *
+ * Common {@link java.io.File} manipulation routines.
+ *
+ * <h3>Origin of code</h3>
+ * <ul>
+ *   <li>commons-utils repo</li>
+ *   <li>Alexandria's FileUtils.</li>
+ *   <li>Avalon Excalibur's IO.</li>
+ * </ul>
+ *
+ * @author <a href="mailto:burton at relativity.yi.org">Kevin A. Burton</A>
+ * @author <a href="mailto:sanders at apache.org">Scott Sanders</a>
+ * @author <a href="mailto:dlr at finemaltcoding.com">Daniel Rall</a>
+ * @author <a href="mailto:Christoph.Reck at dlr.de">Christoph.Reck</a>
+ * @author <a href="mailto:peter at apache.org">Peter Donald</a>
+ * @author <a href="mailto:jefft at apache.org">Jeff Turner</a>
+ * @author Matthew Hawthorne
+ * @author <a href="mailto:jeremias at apache.org">Jeremias Maerki</a>
+ * @version $Id: FileUtils.java,v 1.31 2004/04/24 19:46:16 jeremias Exp $
+ */
+public class FileUtils {
+
+    /**
+     * Instances should NOT be constructed in standard programming.
+     */
+    public FileUtils() { }
+
+    /**
+     * The number of bytes in a kilobyte.
+     */
+    public static final long ONE_KB = 1024;
+
+    /**
+     * The number of bytes in a megabyte.
+     */
+    public static final long ONE_MB = ONE_KB * ONE_KB;
+
+    /**
+     * The number of bytes in a gigabyte.
+     */
+    public static final long ONE_GB = ONE_KB * ONE_MB;
+
+    /**
+     * Returns a human-readable version of the file size (original is in
+     * bytes).
+     *
+     * @param size The number of bytes.
+     * @return     A human-readable display value (includes units).
+     * @todo need for I18N?
+     */
+    public static String byteCountToDisplaySize(long size) {
+        String displaySize;
+
+        if (size / ONE_GB > 0) {
+            displaySize = String.valueOf(size / ONE_GB) + " GB";
+        } else if (size / ONE_MB > 0) {
+            displaySize = String.valueOf(size / ONE_MB) + " MB";
+        } else if (size / ONE_KB > 0) {
+            displaySize = String.valueOf(size / ONE_KB) + " KB";
+        } else {
+            displaySize = String.valueOf(size) + " bytes";
+        }
+
+        return displaySize;
+    }
+
+
+    /**
+     * Implements the same behaviour as the "touch" utility on Unix. It creates
+     * a new file with size 0 or, if the file exists already, it is opened and
+     * closed without modifying it, but updating the file date and time.
+     * @param file the File to touch
+     * @throws IOException If an I/O problem occurs
+     */
+    public static void touch(File file) throws IOException {
+        OutputStream out = new java.io.FileOutputStream(file);
+        IOUtils.closeQuietly(out);
+    }
+
+
+    private static void innerListFiles(Collection files, File directory, IOFileFilter filter) {
+        File[] found = directory.listFiles((FileFilter)filter);
+        for (int i = 0; i < found.length; i++) {
+            if (found[i].isDirectory()) {
+                innerListFiles(files, found[i], filter);
+            } else {
+                files.add(found[i]);
+            }
+        }
+    }
+
+
+    /**
+     * Converts a Collection containing java.io.File instanced into array
+     * representation. This is to account for the difference between
+     * File.listFiles() and FileUtils.listFiles().
+     * @param files a Collection containing java.io.File instances
+     * @return an array of java.io.File
+     */
+    public static File[] convertFileCollectionToFileArray(Collection files) {
+         return (File[])files.toArray(new File[files.size()]);
+    }
+
+
+    /**
+     * <p>Finds files within a given directory (and optionally its 
+     * subdirectories). All files found are filtered by an IOFileFilter.
+     * </p>
+     * <p>If your search should recurse into subdirectories you can pass in 
+     * an IOFileFilter for directories. You don't need to bind a 
+     * DirectoryFileFilter (via logical AND) to this filter. This method does 
+     * that for you.
+     * </p>
+     * <p>An example: If you want to search through all directories called
+     * "temp" you pass in <code>FileFilterUtils.NameFileFilter("temp")</code>
+     * </p>
+     * <p>Another common usage of this method is find files in a directory
+     * tree but ignoring the directories generated CVS. You can simply pass
+     * in <code>FileFilterUtils.makeCVSAware(null)</code>.
+     * </p>  
+     * @param directory the directory to search in
+     * @param fileFilter filter to apply when finding files.
+     * @param dirFilter optional filter to apply when finding subdirectories. 
+     * If this parameter is null, subdirectories will not be included in the
+     * search. Use TrueFileFilter.INSTANCE to match all directories.
+     * @return an collection of java.io.File with the matching files
+     * @see org.apache.commons.io.filefilter.FileFilterUtils
+     * @see org.apache.commons.io.filefilter.NameFileFilter
+     */
+    public static Collection listFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) {
+        if (!directory.isDirectory()) {
+            throw new IllegalArgumentException("Parameter 'directory' is not a directory");
+        }
+        if (fileFilter == null) {
+            throw new NullPointerException("Parameter 'fileFilter' is null");
+        }
+        
+        //Setup effective file filter
+        IOFileFilter effFileFilter = FileFilterUtils.andFileFilter(fileFilter, 
+            FileFilterUtils.notFileFilter(DirectoryFileFilter.INSTANCE));
+            
+        //Setup effective directory filter
+        IOFileFilter effDirFilter;
+        if (dirFilter == null) {
+            effDirFilter = FalseFileFilter.INSTANCE;
+        } else {
+            effDirFilter = FileFilterUtils.andFileFilter(dirFilter,
+                DirectoryFileFilter.INSTANCE);
+        }
+        
+        //Find files
+        Collection files = new java.util.LinkedList();
+        innerListFiles(files, directory, 
+            FileFilterUtils.orFileFilter(effFileFilter, effDirFilter));
+        return files;
+    }
+    
+
+    /**
+     * Converts an array of file extensions to suffixes for use
+     * with IOFileFilters.
+     * @param extensions an array of extensions. Format: {"java", "xml"}
+     * @return an array of suffixes. Format: {".java", ".xml"}
+     */
+    private static String[] toSuffixes(String[] extensions) {
+        String[] suffixes = new String[extensions.length];
+        for (int i = 0; i < extensions.length; i++) {
+            suffixes[i] = "." + extensions[i];
+        }
+        return suffixes;
+    }
+
+
+    /**
+     * Finds files within a given directory (and optionally its subdirectories)
+     * which match an array of extensions. 
+     * @param directory the directory to search in
+     * @param extensions an array of extensions, ex. {"java","xml"}. If this
+     * parameter is null, all files are returned.
+     * @param recursive If true all subdirectories are searched, too.
+     * @return an collection of java.io.File with the matching files
+     */
+    public static Collection listFiles(File directory, String[] extensions, boolean recursive) {
+        IOFileFilter filter;
+        if (extensions == null) {
+            filter = TrueFileFilter.INSTANCE;
+        } else {
+            String[] suffixes = toSuffixes(extensions);
+            filter = new SuffixFileFilter(suffixes);
+        }
+        return listFiles(directory, filter, 
+            (recursive ? TrueFileFilter.INSTANCE : FalseFileFilter.INSTANCE));
+    }
+
+
+    /**
+     * <p>Compare the contents of two files to determine if they are equal or not.</p>
+     * <p>Code origin: Avalon</p>
+     *
+     * @param file1 the first file
+     * @param file2 the second file
+     * @return true if the content of the files are equal or they both don't exist, false otherwise
+     * @throws IOException in case of an I/O error
+     */
+    public static boolean contentEquals(File file1, File file2)
+            throws IOException {
+        boolean file1Exists = file1.exists();
+        if (file1Exists != file2.exists()) {
+            return false;
+        }
+
+        if (!file1Exists) {
+            // two not existing files are equal
+            return true;
+        }
+
+        if (file1.isDirectory() || file2.isDirectory()) {
+            // don't want to compare directory contents
+            throw new IOException("Can't compare directories, only files");
+        }
+
+        InputStream input1 = null;
+        InputStream input2 = null;
+        try {
+            input1 = new java.io.FileInputStream(file1);
+            input2 = new java.io.FileInputStream(file2);
+            return IOUtils.contentEquals(input1, input2);
+
+        } finally {
+            IOUtils.closeQuietly(input1);
+            IOUtils.closeQuietly(input2);
+        }
+    }
+
+    /**
+     * Convert from a <code>URL</code> to a <code>File</code>.
+     * @param url File URL.
+     * @return The equivalent <code>File</code> object, or <code>null</code> if the URL's protocol
+     * is not <code>file</code>
+     */
+    public static File toFile(URL url) {
+        if (url.getProtocol().equals("file") == false) {
+            return null;
+        } else {
+            String filename =
+                url.getFile().replace('/', File.separatorChar);
+            return new File(filename);
+        }
+    }
+
+    /**
+     * Convert the array of Files into a list of URLs.
+     *
+     * @param files the array of files
+     * @return the array of URLs
+     * @throws IOException if an error occurs
+     */
+    public static URL[] toURLs(File[] files) throws IOException {
+        URL[] urls = new URL[files.length];
+
+        for (int i = 0; i < urls.length; i++) {
+            urls[i] = files[i].toURL();
+        }
+
+        return urls;
+    }
+
+
+    /**
+     * Copy file from source to destination. If <code>destinationDirectory</code> does not exist, it
+     * (and any parent directories) will be created. If a file <code>source</code> in
+     * <code>destinationDirectory</code> exists, it will be overwritten.
+     * The copy will have the same file date as the original.
+     *
+     * @param source An existing <code>File</code> to copy.
+     * @param destinationDirectory A directory to copy <code>source</code> into.
+     *
+     * @throws FileNotFoundException if <code>source</code> isn't a normal file.
+     * @throws IllegalArgumentException if <code>destinationDirectory</code> isn't a directory.
+     * @throws IOException if <code>source</code> does not exist, the file in
+     * <code>destinationDirectory</code> cannot be written to, or an IO error occurs during copying.
+     */
+    public static void copyFileToDirectory(
+        File source,
+        File destinationDirectory)
+        throws IOException {
+        if (destinationDirectory.exists()
+            && !destinationDirectory.isDirectory()) {
+            throw new IllegalArgumentException("Destination is not a directory");
+        }
+
+        copyFile(source, new File(destinationDirectory, source.getName()), true);
+    }
+
+    /**
+     * Copy file from source to destination. The directories up to 
+     * <code>destination</code> will be created if they don't already exist. 
+     * <code>destination</code> will be overwritten if it already exists.
+     * The copy will have the same file date as the original.
+     *
+     * @param source An existing non-directory <code>File</code> to copy 
+     * bytes from.
+     * @param destination A non-directory <code>File</code> to write bytes to 
+     * (possibly overwriting).
+     *
+     * @throws IOException if <code>source</code> does not exist, <code>destination</code> cannot be
+     * written to, or an IO error occurs during copying.
+     *
+     * @throws FileNotFoundException if <code>destination</code> is a directory
+     * (use {@link #copyFileToDirectory}).
+     */
+    public static void copyFile(File source, File destination)
+                throws IOException {
+        copyFile(source, destination, true);
+    }
+                
+                
+    /**
+     * Copy file from source to destination. The directories up to 
+     * <code>destination</code> will be created if they don't already exist. 
+     * <code>destination</code> will be overwritten if it already exists.
+     *
+     * @param source An existing non-directory <code>File</code> to copy 
+     * bytes from.
+     * @param destination A non-directory <code>File</code> to write bytes to 
+     * (possibly overwriting).
+     * @param preserveFileDate True if the file date of the copy should be the
+     * same as the original.
+     *
+     * @throws IOException if <code>source</code> does not exist, <code>destination</code> cannot be
+     * written to, or an IO error occurs during copying.
+     *
+     * @throws FileNotFoundException if <code>destination</code> is a directory
+     * (use {@link #copyFileToDirectory}).
+     */
+    public static void copyFile(File source, File destination, boolean preserveFileDate)
+                throws IOException {
+        //check source exists
+        if (!source.exists()) {
+            String message = "File " + source + " does not exist";
+            throw new FileNotFoundException(message);
+        }
+
+        //does destinations directory exist ?
+        if (destination.getParentFile() != null
+            && !destination.getParentFile().exists()) {
+            destination.getParentFile().mkdirs();
+        }
+
+        //make sure we can write to destination
+        if (destination.exists() && !destination.canWrite()) {
+            String message =
+                "Unable to open file " + destination + " for writing.";
+            throw new IOException(message);
+        }
+
+        //makes sure it is not the same file        
+        if (source.getCanonicalPath().equals(destination.getCanonicalPath())) {
+            String message =
+                "Unable to write file " + source + " on itself.";
+            throw new IOException(message);
+        }
+
+        FileInputStream input = new FileInputStream(source);
+        try {
+            FileOutputStream output = new FileOutputStream(destination);
+            try {
+                CopyUtils.copy(input, output);
+            } finally {
+                IOUtils.closeQuietly(output);
+            }
+        } finally {
+            IOUtils.closeQuietly(input);
+        }
+
+        if (source.length() != destination.length()) {
+            String message =
+                "Failed to copy full contents from "
+                    + source
+                    + " to "
+                    + destination;
+            throw new IOException(message);
+        }
+        
+        if (preserveFileDate) {
+            //file copy should preserve file date
+            destination.setLastModified(source.lastModified());        
+        }
+    }
+
+    /**
+     * Copies bytes from the URL <code>source</code> to a file <code>destination</code>.
+     * The directories up to <code>destination</code> will be created if they don't already exist.
+     * <code>destination</code> will be overwritten if it already exists.
+     *
+     * @param source A <code>URL</code> to copy bytes from.
+     * @param destination A non-directory <code>File</code> to write bytes to (possibly
+     * overwriting).
+     *
+     * @throws IOException if
+     * <ul>
+     *  <li><code>source</code> URL cannot be opened</li>
+     *  <li><code>destination</code> cannot be written to</li>
+     *  <li>an IO error occurs during copying</li>
+     * </ul>
+     */
+    public static void copyURLToFile(URL source, File destination)
+                throws IOException {
+        //does destination directory exist ?
+        if (destination.getParentFile() != null
+            && !destination.getParentFile().exists()) {
+            destination.getParentFile().mkdirs();
+        }
+
+        //make sure we can write to destination
+        if (destination.exists() && !destination.canWrite()) {
+            String message =
+                "Unable to open file " + destination + " for writing.";
+            throw new IOException(message);
+        }
+
+        InputStream input = source.openStream();
+        try {
+            FileOutputStream output = new FileOutputStream(destination);
+            try {
+                CopyUtils.copy(input, output);
+            } finally {
+                IOUtils.closeQuietly(output);
+            }
+        } finally {
+            IOUtils.closeQuietly(input);
+        }
+    }
+
+
+    /**
+     * Recursively delete a directory.
+     * @param directory directory to delete
+     * @throws IOException in case deletion is unsuccessful
+     */
+    public static void deleteDirectory(File directory)
+        throws IOException {
+        if (!directory.exists()) {
+            return;
+        }
+
+        cleanDirectory(directory);
+        if (!directory.delete()) {
+            String message =
+                "Unable to delete directory " + directory + ".";
+            throw new IOException(message);
+        }
+    }
+
+    /**
+     * Clean a directory without deleting it.
+     * @param directory directory to clean
+     * @throws IOException in case cleaning is unsuccessful
+     */
+    public static void cleanDirectory(File directory)
+        throws IOException {
+        if (!directory.exists()) {
+            String message = directory + " does not exist";
+            throw new IllegalArgumentException(message);
+        }
+
+        if (!directory.isDirectory()) {
+            String message = directory + " is not a directory";
+            throw new IllegalArgumentException(message);
+        }
+
+        IOException exception = null;
+
+        File[] files = directory.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            File file = files[i];
+            try {
+                forceDelete(file);
+            } catch (IOException ioe) {
+                exception = ioe;
+            }
+        }
+
+        if (null != exception) {
+            throw exception;
+        }
+    }
+
+    /**
+     * Waits for NFS to propagate a file creation, imposing a timeout.
+     *
+     * @param file The file
+     * @param seconds The maximum time in seconds to wait.
+     * @return True if file exists.
+     * TODO Needs a clearer javadoc to see its real purpose for someone without
+     *       NFS-knowledge.
+     */
+    public static boolean waitFor(File file, int seconds) {
+        int timeout = 0;
+        int tick = 0;
+        while (!file.exists()) {
+            if (tick++ >= 10) {
+                tick = 0;
+                if (timeout++ > seconds) {
+                    return false;
+                }
+            }
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ignore) {} catch (Exception ex) {
+                break;
+            }
+        }
+        return true;
+    }
+
+
+    /**
+     * <p>
+     * Reads the contents of a file into a String.
+     * </p>
+     * <p>
+     * There is no readFileToString method without encoding parameter because
+     * the default encoding can differ between platforms and therefore results
+     * in inconsistent results.
+     * </p>
+     *
+     * @param file the file to read.
+     * @param encoding the encoding to use
+     * @return The file contents or null if read failed.
+     * @throws IOException in case of an I/O error
+     * @throws UnsupportedEncodingException if the encoding is not supported
+     *   by the VM
+     */
+    public static String readFileToString(
+            File file, String encoding) throws IOException {
+        InputStream in = new java.io.FileInputStream(file);
+        try {
+            return IOUtils.toString(in, encoding);
+        } finally {
+            IOUtils.closeQuietly(in);
+        }
+    }
+
+    /**
+     * <p>
+     * Writes data to a file. The file will be created if it does not exist.
+     * </p>
+     * <p>
+     * There is no readFileToString method without encoding parameter because
+     * the default encoding can differ between platforms and therefore results
+     * in inconsistent results.
+     * </p>
+     *
+     * @param file the file to write.
+     * @param data The content to write to the file.
+     * @param encoding encoding to use
+     * @throws IOException in case of an I/O error
+     * @throws UnsupportedEncodingException if the encoding is not supported
+     *   by the VM
+     */
+    public static void writeStringToFile(File file, 
+            String data, String encoding) throws IOException {
+        OutputStream out = new java.io.FileOutputStream(file);
+        try {
+            out.write(data.getBytes(encoding));
+        } finally {
+            IOUtils.closeQuietly(out);
+        }
+    }
+
+    /**
+     * <p>
+     * Delete a file. If file is a directory, delete it and all sub-directories.
+     * </p>
+     * <p>
+     * The difference between File.delete() and this method are:
+     * </p>
+     * <ul>
+     * <li>A directory to be deleted does not have to be empty.</li>
+     * <li>You get exceptions when a file or directory cannot be deleted. 
+     *      (java.io.File methods returns a boolean)</li>
+     * </ul>
+     * @param file file or directory to delete.
+     * @throws IOException in case deletion is unsuccessful
+     */
+    public static void forceDelete(File file) throws IOException {
+        if (file.isDirectory()) {
+            deleteDirectory(file);
+        } else {
+            if (!file.exists()) {
+                throw new FileNotFoundException("File does not exist: " + file);
+            }
+            if (!file.delete()) {
+                String message =
+                    "Unable to delete file: " + file;
+                throw new IOException(message);
+            }
+        }
+    }
+
+    /**
+     * Schedule a file to be deleted when JVM exits.
+     * If file is directory delete it and all sub-directories.
+     * @param file file or directory to delete.
+     * @throws IOException in case deletion is unsuccessful
+     */
+    public static void forceDeleteOnExit(File file) throws IOException {
+        if (file.isDirectory()) {
+            deleteDirectoryOnExit(file);
+        } else {
+            file.deleteOnExit();
+        }
+    }
+
+    /**
+     * Recursively schedule directory for deletion on JVM exit.
+     * @param directory directory to delete.
+     * @throws IOException in case deletion is unsuccessful
+     */
+    private static void deleteDirectoryOnExit(File directory)
+            throws IOException {
+        if (!directory.exists()) {
+            return;
+        }
+
+        cleanDirectoryOnExit(directory);
+        directory.deleteOnExit();
+    }
+
+    /**
+     * Clean a directory without deleting it.
+     * @param directory directory to clean.
+     * @throws IOException in case cleaning is unsuccessful
+     */
+    private static void cleanDirectoryOnExit(File directory)
+            throws IOException {
+        if (!directory.exists()) {
+            String message = directory + " does not exist";
+            throw new IllegalArgumentException(message);
+        }
+
+        if (!directory.isDirectory()) {
+            String message = directory + " is not a directory";
+            throw new IllegalArgumentException(message);
+        }
+
+        IOException exception = null;
+
+        File[] files = directory.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            File file = files[i];
+            try {
+                forceDeleteOnExit(file);
+            } catch (IOException ioe) {
+                exception = ioe;
+            }
+        }
+
+        if (null != exception) {
+            throw exception;
+        }
+    }
+
+
+    /**
+     * Make a directory. If there already exists a file with specified name or
+     * the directory cannot be created then an exception is thrown.
+     * @param directory directory to create
+     * @throws IOException if the directory cannot be created.
+     */
+    public static void forceMkdir(File directory) throws IOException {
+        if (directory.exists()) {
+            if (directory.isFile()) {
+                String message =
+                    "File "
+                        + directory
+                        + " exists and is "
+                        + "not a directory. Unable to create directory.";
+                throw new IOException(message);
+            }
+        } else {
+            if (false == directory.mkdirs()) {
+                String message =
+                    "Unable to create directory " + directory;
+                throw new IOException(message);
+            }
+        }
+    }
+
+    /**
+     * Recursively count size of a directory (sum of the length of all files).
+     *
+     * @param directory directory to inspect
+     * @return size of directory in bytes.
+     */
+    public static long sizeOfDirectory(File directory) {
+        if (!directory.exists()) {
+            String message = directory + " does not exist";
+            throw new IllegalArgumentException(message);
+        }
+
+        if (!directory.isDirectory()) {
+            String message = directory + " is not a directory";
+            throw new IllegalArgumentException(message);
+        }
+
+        long size = 0;
+
+        File[] files = directory.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            File file = files[i];
+
+            if (file.isDirectory()) {
+                size += sizeOfDirectory(file);
+            } else {
+                size += file.length();
+            }
+        }
+
+        return size;
+    }
+   
+     /**
+      * Tests if the specified <code>File</code> is newer than the reference 
+      * <code>File</code>.
+      *
+      * @param file the <code>File</code> of which the modification date must be compared
+      * @param reference the <code>File</code> of which the modification date is used 
+      * like reference
+      * @return true if the <code>File</code> exists and has been modified more recently
+      * than the reference <code>File</code>.
+      */
+     public static boolean isFileNewer(File file, File reference) {
+         if (reference == null) {
+             throw new IllegalArgumentException("No specified reference file");
+         }
+         if (!reference.exists()) {
+             throw new IllegalArgumentException("The reference file '" + file + "' doesn't exist");
+         }
+ 
+         return isFileNewer(file, reference.lastModified());
+     }
+ 
+     /**
+      * Tests if the specified <code>File</code> is newer than the specified 
+      * <code>Date</code>
+      *
+      * @param file the <code>File</code> of which the modification date must be compared
+      * @param date the date reference
+      * @return true if the <code>File</code> exists and has been modified after
+      * the given <code>Date</code>.
+      */
+     public static boolean isFileNewer(File file, Date date) {
+         if (date == null) {
+             throw new IllegalArgumentException("No specified date");
+         }
+         return isFileNewer(file, date.getTime());
+     }
+ 
+     /**
+      * Tests if the specified <code>File</code> is newer than the specified 
+      * time reference.
+      *
+      * @param file the <code>File</code> of which the modification date must be compared.
+      * @param timeMillis the time reference measured in milliseconds since the epoch 
+      * (00:00:00 GMT, January 1, 1970)
+      * @return true if the <code>File</code> exists and has been modified after
+      * the given time reference.
+      */
+     public static boolean isFileNewer(File file, long timeMillis) {
+         if (file == null) {
+             throw new IllegalArgumentException("No specified file");
+         }
+         if (!file.exists()) {
+             return false;
+         }
+ 
+         return file.lastModified() > timeMillis;
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/HexDump.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/HexDump.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/HexDump.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2002,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Dumps data in hexadecimal format.
+ *
+ * Derived from a HexDump utility I wrote in June 2001.
+ *
+ * Taken from the POI project.
+ *
+ * @author Scott Sanders (sanders at apache dot org)
+ * @author Marc Johnson
+ * @version $Revision: 1.8 $ $Date: 2004/02/23 04:35:59 $
+ */
+public class HexDump {
+
+    /**
+     * Instances should NOT be constructed in standard programming.
+     */
+    public HexDump() { }
+
+    /**
+     * dump an array of bytes to an OutputStream
+     *
+     * @param data the byte array to be dumped
+     * @param offset its offset, whatever that might mean
+     * @param stream the OutputStream to which the data is to be
+     *               written
+     * @param index initial index into the byte array
+     *
+     * @exception IOException is thrown if anything goes wrong writing
+     *            the data to stream
+     * @exception ArrayIndexOutOfBoundsException if the index is
+     *            outside the data array's bounds
+     * @exception IllegalArgumentException if the output stream is
+     *            null
+     */
+
+    public static void dump(byte[] data, long offset,
+                            OutputStream stream, int index)
+            throws IOException, ArrayIndexOutOfBoundsException,
+            IllegalArgumentException {
+        if ((index < 0) || (index >= data.length)) {
+            throw new ArrayIndexOutOfBoundsException(
+                    "illegal index: " + index + " into array of length "
+                    + data.length);
+        }
+        if (stream == null) {
+            throw new IllegalArgumentException("cannot write to nullstream");
+        }
+        long display_offset = offset + index;
+        StringBuffer buffer = new StringBuffer(74);
+
+        for (int j = index; j < data.length; j += 16) {
+            int chars_read = data.length - j;
+
+            if (chars_read > 16) {
+                chars_read = 16;
+            }
+            buffer.append(dump(display_offset)).append(' ');
+            for (int k = 0; k < 16; k++) {
+                if (k < chars_read) {
+                    buffer.append(dump(data[k + j]));
+                } else {
+                    buffer.append("  ");
+                }
+                buffer.append(' ');
+            }
+            for (int k = 0; k < chars_read; k++) {
+                if ((data[k + j] >= ' ') && (data[k + j] < 127)) {
+                    buffer.append((char) data[k + j]);
+                } else {
+                    buffer.append('.');
+                }
+            }
+            buffer.append(EOL);
+            stream.write(buffer.toString().getBytes());
+            stream.flush();
+            buffer.setLength(0);
+            display_offset += chars_read;
+        }
+    }
+
+    /** line-separator (initializes to "line.separator" system property. */
+    public static final String EOL =
+            System.getProperty("line.separator");
+    private static final StringBuffer _lbuffer = new StringBuffer(8);
+    private static final StringBuffer _cbuffer = new StringBuffer(2);
+    private static final char _hexcodes[] =
+            {
+                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D',
+                'E', 'F'
+            };
+    private static final int _shifts[] =
+            {
+                28, 24, 20, 16, 12, 8, 4, 0
+            };
+
+    private static StringBuffer dump(long value) {
+        _lbuffer.setLength(0);
+        for (int j = 0; j < 8; j++) {
+            _lbuffer
+                    .append(_hexcodes[((int) (value >> _shifts[j])) & 15]);
+        }
+        return _lbuffer;
+    }
+
+    private static StringBuffer dump(byte value) {
+        _cbuffer.setLength(0);
+        for (int j = 0; j < 2; j++) {
+            _cbuffer.append(_hexcodes[(value >> _shifts[j + 6]) & 15]);
+        }
+        return _cbuffer;
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/IOUtils.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/IOUtils.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/IOUtils.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,332 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.io.Writer;
+
+import org.apache.commons.io.output.ByteArrayOutputStream;
+
+/**
+ * General IO Stream manipulation.
+ * <p>
+ * This class provides static utility methods for input/output operations.
+ * </p>
+ * <p>The closeQuietly methods are expected to be used when an IOException 
+ * would be meaningless. This is usually when in a catch block for an 
+ * IOException. </p>
+ * <p>The toString and toByteArray methods all rely on CopyUtils.copy 
+ * methods in the current implementation. </p>
+ *
+ * <p>Origin of code: Apache Avalon (Excalibur)</p>
+ *
+ * @author <a href="mailto:peter at apache.org">Peter Donald</a>
+ * @author <a href="mailto:jefft at apache.org">Jeff Turner</a>
+ * @version CVS $Revision: 1.14 $ $Date: 2004/04/24 23:49:25 $
+ */
+public final class IOUtils
+{
+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;
+
+    /**
+     * Instances should NOT be constructed in standard programming.
+     */
+    public IOUtils() {}
+
+    /**
+     * Unconditionally close an <code>Reader</code>.
+     * Equivalent to {@link Reader#close()}, except any exceptions will be ignored.
+     *
+     * @param input A (possibly null) Reader
+     */
+    public static void closeQuietly( Reader input )
+    {
+        if( input == null )
+        {
+            return;
+        }
+
+        try
+        {
+            input.close();
+        }
+        catch( IOException ioe )
+        {
+        }
+    }
+
+    /**
+     * Unconditionally close an <code>Writer</code>.
+     * Equivalent to {@link Writer#close()}, except any exceptions will be ignored.
+     *
+     * @param output A (possibly null) Writer
+     */
+    public static void closeQuietly( Writer output )
+    {
+        if( output == null )
+        {
+            return;
+        }
+
+        try
+        {
+            output.close();
+        }
+        catch( IOException ioe )
+        {
+        }
+    }
+
+    /**
+     * Unconditionally close an <code>OutputStream</code>.
+     * Equivalent to {@link OutputStream#close()}, except any exceptions will be ignored.
+     * @param output A (possibly null) OutputStream
+     */
+    public static void closeQuietly( OutputStream output )
+    {
+        if( output == null )
+        {
+            return;
+        }
+
+        try
+        {
+            output.close();
+        }
+        catch( IOException ioe )
+        {
+        }
+    }
+
+    /**
+     * Unconditionally close an <code>InputStream</code>.
+     * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.
+     * @param input A (possibly null) InputStream
+     */
+    public static void closeQuietly( InputStream input )
+    {
+        if( input == null )
+        {
+            return;
+        }
+
+        try
+        {
+            input.close();
+        }
+        catch( IOException ioe )
+        {
+        }
+    }
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a String.
+     * The platform's default encoding is used for the byte-to-char conversion.
+     * @param input the <code>InputStream</code> to read from
+     * @return the requested <code>String</code>
+     * @throws IOException In case of an I/O problem
+     */
+    public static String toString( InputStream input )
+        throws IOException
+    {
+        StringWriter sw = new StringWriter();
+        CopyUtils.copy( input, sw );
+        return sw.toString();
+    }
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a String.
+     * @param input the <code>InputStream</code> to read from
+     * @param encoding The name of a supported character encoding. See the
+     *   <a href="http://www.iana.org/assignments/character-sets">IANA
+     *   Charset Registry</a> for a list of valid encoding types.
+     * @return the requested <code>String</code>
+     * @throws IOException In case of an I/O problem
+     */
+    public static String toString( InputStream input,
+                                   String encoding )
+        throws IOException
+    {
+        StringWriter sw = new StringWriter();
+        CopyUtils.copy( input, sw, encoding );
+        return sw.toString();
+    }
+
+    ///////////////////////////////////////////////////////////////
+    // InputStream -> byte[]
+
+    /**
+     * Get the contents of an <code>InputStream</code> as a <code>byte[]</code>.
+     * @param input the <code>InputStream</code> to read from
+     * @return the requested byte array
+     * @throws IOException In case of an I/O problem
+     */
+    public static byte[] toByteArray( InputStream input )
+        throws IOException
+    {
+        ByteArrayOutputStream output = new ByteArrayOutputStream();
+        CopyUtils.copy( input, output );
+        return output.toByteArray();
+    }
+
+
+    ///////////////////////////////////////////////////////////////
+    // Derived copy methods
+    // Reader -> *
+    ///////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////
+    // Reader -> String
+    /**
+     * Get the contents of a <code>Reader</code> as a String.
+     * @param input the <code>Reader</code> to read from
+     * @return the requested <code>String</code>
+     * @throws IOException In case of an I/O problem
+     */
+    public static String toString( Reader input )
+        throws IOException
+    {
+        StringWriter sw = new StringWriter();
+        CopyUtils.copy( input, sw );
+        return sw.toString();
+    }
+
+
+    ///////////////////////////////////////////////////////////////
+    // Reader -> byte[]
+    /**
+     * Get the contents of a <code>Reader</code> as a <code>byte[]</code>.
+     * @param input the <code>Reader</code> to read from
+     * @return the requested byte array
+     * @throws IOException In case of an I/O problem
+     */
+    public static byte[] toByteArray( Reader input )
+        throws IOException
+    {
+        ByteArrayOutputStream output = new ByteArrayOutputStream();
+        CopyUtils.copy( input, output );
+        return output.toByteArray();
+    }
+
+
+    ///////////////////////////////////////////////////////////////
+    // Derived copy methods
+    // String -> *
+    ///////////////////////////////////////////////////////////////
+
+
+    ///////////////////////////////////////////////////////////////
+    // String -> byte[]
+    /**
+     * Get the contents of a <code>String</code> as a <code>byte[]</code>.
+     * @param input the <code>String</code> to convert
+     * @return the requested byte array
+     * @throws IOException In case of an I/O problem
+     */
+    public static byte[] toByteArray( String input )
+        throws IOException
+    {
+        ByteArrayOutputStream output = new ByteArrayOutputStream();
+        CopyUtils.copy( input, output );
+        return output.toByteArray();
+    }
+
+
+    ///////////////////////////////////////////////////////////////
+    // Derived copy methods
+    // byte[] -> *
+    ///////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////
+    // byte[] -> String
+
+    /**
+     * Get the contents of a <code>byte[]</code> as a String.
+     * The platform's default encoding is used for the byte-to-char conversion.
+     * @param input the byte array to read from
+     * @return the requested <code>String</code>
+     * @throws IOException In case of an I/O problem
+     */
+    public static String toString( byte[] input )
+        throws IOException
+    {
+        StringWriter sw = new StringWriter();
+        CopyUtils.copy( input, sw );
+        return sw.toString();
+    }
+
+
+    /**
+     * Get the contents of a <code>byte[]</code> as a String.
+     * @param input the byte array to read from
+     * @param encoding The name of a supported character encoding. See the
+     *   <a href="http://www.iana.org/assignments/character-sets">IANA
+     *   Charset Registry</a> for a list of valid encoding types.
+     * @return the requested <code>String</code>
+     * @throws IOException In case of an I/O problem
+     */
+    public static String toString( byte[] input,
+                                   String encoding )
+        throws IOException
+    {
+        StringWriter sw = new StringWriter();
+        CopyUtils.copy( input, sw, encoding );
+        return sw.toString();
+    }
+
+
+    /**
+     * Compare the contents of two Streams to determine if they are equal or not.
+     *
+     * @param input1 the first stream
+     * @param input2 the second stream
+     * @return true if the content of the streams are equal or they both don't exist, false otherwise
+     * @throws IOException In case of an I/O problem
+     */
+    public static boolean contentEquals( InputStream input1,
+                                         InputStream input2 )
+        throws IOException
+    {
+        InputStream bufferedInput1 = new BufferedInputStream( input1 );
+        InputStream bufferedInput2 = new BufferedInputStream( input2 );
+
+        int ch = bufferedInput1.read();
+        while( -1 != ch )
+        {
+            int ch2 = bufferedInput2.read();
+            if( ch != ch2 )
+            {
+                return false;
+            }
+            ch = bufferedInput1.read();
+        }
+
+        int ch2 = bufferedInput2.read();
+        if( -1 != ch2 )
+        {
+            return false;
+        }
+        else
+        {
+            return true;
+        }
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/AbstractFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/AbstractFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/AbstractFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+
+/**
+ * An abstract class which implements the Java FileFilter and FilenameFilter 
+ * interfaces via the IOFileFilter interface.
+ * <p>
+ * Note that a subclass <b>must</b> override one of the accept methods,
+ * otherwise your class will infinitely loop.
+ *
+ * @since Commons IO 1.0
+ * @version $Revision: 1.9 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ */
+public abstract class AbstractFileFilter implements IOFileFilter {
+
+    /**
+     * Checks to see if the File should be accepted by this filter.
+     * 
+     * @param file  the File to check
+     * @return true if this file matches the test
+     */
+    public boolean accept(File file) {
+        return accept(file.getParentFile(), file.getName());
+    }
+
+    /**
+     * Checks to see if the File should be accepted by this filter.
+     * 
+     * @param dir  the directory File to check
+     * @param name  the filename within the directory to check
+     * @return true if this file matches the test
+     */
+    public boolean accept(File dir, String name) {
+        String filename = dir.getName() + File.separator + name;
+        return accept(new File(filename));
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/AndFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/AndFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/AndFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+
+/**
+ * This filter produces a logical AND of the two filters specified.
+ *
+ * @since Commons IO 1.0
+ * @version $Revision: 1.8 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Stephen Colebourne
+ */
+public class AndFileFilter extends AbstractFileFilter {
+    
+    /** The first filter */
+    private IOFileFilter filter1;
+    /** The second filter */
+    private IOFileFilter filter2;
+
+    /**
+     * Constructs a new file filter that ANDs the result of two other filters.
+     * 
+     * @param filter1  the first filter, must not be null
+     * @param filter2  the second filter, must not be null
+     * @throws IllegalArgumentException if either filter is null
+     */
+    public AndFileFilter(IOFileFilter filter1, IOFileFilter filter2) {
+        if (filter1 == null || filter2 == null) {
+            throw new IllegalArgumentException("The filters must not be null");
+        }
+        this.filter1 = filter1;
+        this.filter2 = filter2;
+    }
+
+    /**
+     * Checks to see if both filters are true.
+     * 
+     * @param file  the File to check
+     * @return true if both filters are true
+     */
+    public boolean accept(File file) {
+        return filter1.accept(file) && filter2.accept(file);
+    }
+    
+    /**
+     * Checks to see if both filters are true.
+     * 
+     * @param file  the File directory
+     * @param name  the filename
+     * @return true if both filters are true
+     */
+    public boolean accept(File file, String name) {
+        return filter1.accept(file, name) && filter2.accept(file, name);
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/DelegateFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/DelegateFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/DelegateFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FilenameFilter;
+
+/**
+ * This class turns a Java FileFilter or FilenameFilter into an IO FileFilter.
+ * 
+ * @since Commons IO 1.0
+ * @version $Revision: 1.8 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ */
+public class DelegateFileFilter extends AbstractFileFilter {
+
+    /** The Filename filter */
+    private FilenameFilter filenameFilter;
+    /** The File filter */
+    private FileFilter fileFilter;
+
+    /**
+     * Constructs a delegate file filter around an existing FilenameFilter.
+     * 
+     * @param filter  the filter to decorate
+     */
+    public DelegateFileFilter(FilenameFilter filter) {
+        if (filter == null) {
+            throw new IllegalArgumentException("The FilenameFilter must not be null");
+        }
+        this.filenameFilter = filter;
+    }
+
+    /**
+     * Constructs a delegate file filter around an existing FileFilter.
+     * 
+     * @param filter  the filter to decorate
+     */
+    public DelegateFileFilter(FileFilter filter) {
+        if (filter == null) {
+            throw new IllegalArgumentException("The FileFilter must not be null");
+        }
+        this.fileFilter = filter;
+    }
+
+    /**
+     * Checks the filter.
+     * 
+     * @param file  the file to check
+     * @return true if the filter matches
+     */
+    public boolean accept(File file) {
+        if (fileFilter != null) {
+            return fileFilter.accept(file);
+        } else {
+            return super.accept(file);
+        }
+    }
+
+    /**
+     * Checks the filter.
+     * 
+     * @param dir  the directory
+     * @param name  the filename in the directory
+     * @return true if the filter matches
+     */
+    public boolean accept(File dir, String name) {
+        if (filenameFilter != null) {
+            return filenameFilter.accept(dir, name);
+        } else {
+            return super.accept(dir, name);
+        }
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+
+/**
+ * This filter accepts <code>File</code>s that are directories.
+ * <p>
+ * For example, here is how to print out a list of the 
+ * current directory's subdirectories:
+ *
+ * <pre>
+ * File dir = new File(".");
+ * String[] files = dir.list( DirectoryFileFilter.INSTANCE );
+ * for ( int i = 0; i &lt; files.length; i++ ) {
+ *     System.out.println(files[i]);
+ * }
+ * </pre>
+ *
+ * @since Commons IO 1.0
+ * @version $Revision: 1.7 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ * @author Peter Donald
+ */
+public class DirectoryFileFilter extends AbstractFileFilter {
+    
+    /** Singleton instance of directory filter */
+    public static final IOFileFilter INSTANCE = new DirectoryFileFilter();
+    
+    /**
+     * Restrictive consructor.
+     */
+    protected DirectoryFileFilter() {
+    }
+    
+    /**
+     * Checks to see if the file is a directory.
+     * 
+     * @param file  the File to check
+     * @return true if the file is a directory
+     */
+    public boolean accept(File file) {
+        return file.isDirectory();
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/FalseFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/FalseFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/FalseFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+
+/**
+ * A file filter that always returns false.
+ * 
+ * @since Commons IO 1.0
+ * @version $Revision: 1.7 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ */
+public class FalseFileFilter implements IOFileFilter {
+    
+    /** Singleton instance of false filter */
+    public static final IOFileFilter INSTANCE = new FalseFileFilter();
+    
+    /**
+     * Restrictive consructor.
+     */
+    protected FalseFileFilter() {
+    }
+    
+    /**
+     * Returns false.
+     * 
+     * @param file  the file to check
+     * @return false
+     */
+    public boolean accept(File file) {
+        return false;
+    }
+    
+    /**
+     * Returns false.
+     * 
+     * @param dir  the directory to check
+     * @param name  the filename
+     * @return false
+     */
+    public boolean accept(File dir, String name) {
+        return false;
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/FileFilterUtils.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/FileFilterUtils.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/FileFilterUtils.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.FileFilter;
+import java.io.FilenameFilter;
+
+/**
+ * Useful utilities for working with file filters. It provides access to all
+ * file filter implementations in this package so you don't have to import
+ * every class you use.
+ * 
+ * @since Commons IO 1.0
+ * @version $Revision: 1.8 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ * @author Jeremias Maerki
+ */
+public class FileFilterUtils {
+    
+    /**
+     * FileFilterUtils is not normally instantiated.
+     */
+    public FileFilterUtils() {
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Returns a filter that returns true if the filename starts with the specified text.
+     * 
+     * @param prefix  the filename prefix
+     * @return a prefix checking filter
+     */
+    public static IOFileFilter prefixFileFilter(String prefix) {
+        return new PrefixFileFilter(prefix);
+    }
+
+    /**
+     * Returns a filter that returns true if the filename ends with the specified text.
+     * 
+     * @param suffix  the filename suffix
+     * @return a suffix checking filter
+     */
+    public static IOFileFilter suffixFileFilter(String suffix) {
+        return new SuffixFileFilter(suffix);
+    }
+
+    /**
+     * Returns a filter that returns true if the filename matches the specified text.
+     * 
+     * @param name  the filename
+     * @return a name checking filter
+     */
+    public static IOFileFilter nameFileFilter(String name) {
+        return new NameFileFilter(name);
+    }
+
+    /**
+     * Returns a filter that checks if the file is a directory.
+     * 
+     * @return directory file filter
+     */
+    public static IOFileFilter directoryFileFilter() {
+        return DirectoryFileFilter.INSTANCE;
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns a filter that ANDs the two specified filters.
+     * 
+     * @param filter1  the first filter
+     * @param filter2  the second filter
+     * @return a filter that ANDs the two specified filters
+     */
+    public static IOFileFilter andFileFilter(IOFileFilter filter1, IOFileFilter filter2) {
+        return new AndFileFilter(filter1, filter2);
+    }
+
+    /**
+     * Returns a filter that ORs the two specified filters.
+     * 
+     * @param filter1  the first filter
+     * @param filter2  the second filter
+     * @return a filter that ORs the two specified filters
+     */
+    public static IOFileFilter orFileFilter(IOFileFilter filter1, IOFileFilter filter2) {
+        return new OrFileFilter(filter1, filter2);
+    }
+
+    /**
+     * Returns a filter that NOTs the specified filter.
+     * 
+     * @param filter  the filter to invert
+     * @return a filter that NOTs the specified filter
+     */
+    public static IOFileFilter notFileFilter(IOFileFilter filter) {
+        return new NotFileFilter(filter);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Returns a filter that always returns true.
+     * 
+     * @return a true filter
+     */
+    public static IOFileFilter trueFileFilter() {
+        return TrueFileFilter.INSTANCE;
+    }
+
+    /**
+     * Returns a filter that always returns false.
+     * 
+     * @return a false filter
+     */
+    public static IOFileFilter falseFileFilter() {
+        return FalseFileFilter.INSTANCE;
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns an <code>IOFileFilter</code> that wraps the
+     * <code>FileFilter</code> instance.
+     * 
+     * @param filter  the filter to be wrapped
+     * @return a new filter that implements IOFileFilter
+     */
+    public static IOFileFilter asFileFilter(FileFilter filter) {
+        return new DelegateFileFilter(filter);
+    }
+
+    /**
+     * Returns an <code>IOFileFilter</code> that wraps the
+     * <code>FilenameFilter</code> instance.
+     * 
+     * @param filter  the filter to be wrapped
+     * @return a new filter that implements IOFileFilter
+     */
+    public static IOFileFilter asFileFilter(FilenameFilter filter) {
+        return new DelegateFileFilter(filter);
+    }
+
+    //-----------------------------------------------------------------------
+
+    /* Constructed on demand and then cached */
+    private static IOFileFilter cvsFilter = null;
+
+    /**
+     * Resturns an IOFileFilter that ignores CVS directories. You may optionally
+     * pass in an existing IOFileFilter in which case it is extended to exclude
+     * CVS directories.
+     * @param filter IOFileFilter to modify, null if a new IOFileFilter
+     * should be created
+     * @return the requested (combined) filter
+     */
+    public static IOFileFilter makeCVSAware(IOFileFilter filter) {
+        if (cvsFilter == null) {
+            cvsFilter = andFileFilter(directoryFileFilter(), 
+                notFileFilter(nameFileFilter("CVS")));
+        }
+        if (filter == null) {
+            return cvsFilter;
+        } else {
+            return andFileFilter(filter, cvsFilter);
+        }
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/IOFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/IOFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/IOFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FilenameFilter;
+
+/**
+ * An interface which brings the FileFilter and FilenameFilter 
+ * interfaces together.
+ * 
+ * @since Commons IO 1.0
+ * @version $Revision: 1.4 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ */
+public interface IOFileFilter extends FileFilter, FilenameFilter {
+
+    /**
+     * Checks to see if the File should be accepted by this filter.
+     * <p>
+     * Defined in {@link java.io.FileFilter}.
+     * 
+     * @param file  the File to check
+     * @return true if this file matches the test
+     */
+    public boolean accept(File file);
+
+    /**
+     * Checks to see if the File should be accepted by this filter.
+     * <p>
+     * Defined in {@link java.io.FilenameFilter}.
+     * 
+     * @param dir  the directory File to check
+     * @param name  the filename within the directory to check
+     * @return true if this file matches the test
+     */
+    public boolean accept(File dir, String name);
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/NameFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/NameFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/NameFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+import java.util.List;
+
+/**
+ * Filters filenames for a certain name.
+ * <p>
+ * For example, to print all files and directories in the 
+ * current directory whose name is <code>Test</code>:
+ *
+ * <pre>
+ * File dir = new File(".");
+ * String[] files = dir.list( new NameFileFilter("Test") );
+ * for ( int i = 0; i &lt; files.length; i++ ) {
+ *     System.out.println(files[i]);
+ * }
+ * </pre>
+ *
+ * @since Commons IO 1.0
+ * @version $Revision: 1.3 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ * @author Federico Barbieri
+ * @author Serge Knystautas
+ * @author Peter Donald
+ */
+public class NameFileFilter extends AbstractFileFilter {
+    
+    /** The filenames to search for */
+    private String[] names;
+
+    /**
+     * Constructs a new name file filter for a single name.
+     * 
+     * @param name  the name to allow, must not be null
+     * @throws IllegalArgumentException if the prefix is null
+     */
+    public NameFileFilter(String name) {
+        if (name == null) {
+            throw new IllegalArgumentException("The name must not be null");
+        }
+        this.names = new String[] {name};
+    }
+
+    /**
+     * Constructs a new name file filter for any of an array of names.
+     * <p>
+     * The array is not cloned, so could be changed after constructing the
+     * instance. This would be inadvisable however.
+     * 
+     * @param names  the names to allow, must not be null
+     * @throws IllegalArgumentException if the names array is null
+     */
+    public NameFileFilter(String[] names) {
+        if (names == null) {
+            throw new IllegalArgumentException("The array of names must not be null");
+        }
+        this.names = names;
+    }
+
+    /**
+     * Constructs a new name file filter for a list of names.
+     * 
+     * @param names  the names to allow, must not be null
+     * @throws IllegalArgumentException if the name list is null
+     * @throws ClassCastException if the list does not contain Strings
+     */
+    public NameFileFilter(List names) {
+        if (names == null) {
+            throw new IllegalArgumentException("The list of names must not be null");
+        }
+        this.names = (String[]) names.toArray(new String[names.size()]);
+    }
+
+    /**
+     * Checks to see if the filename matches.
+     * 
+     * @param file  the File to check
+     * @return true if the filename matches
+     */
+    public boolean accept(File file) {
+        String name = file.getName();
+        for (int i = 0; i < this.names.length; i++) {
+            if (name.equals(this.names[i])) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+    /**
+     * Checks to see if the filename matches.
+     * 
+     * @param file  the File directory
+     * @param name  the filename
+     * @return true if the filename matches
+     */
+    public boolean accept(File file, String name) {
+        for (int i = 0; i < this.names.length; i++) {
+            if (name.equals(this.names[i])) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/NotFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/NotFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/NotFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+
+/**
+ * This filter produces a logical NOT of the filters specified.
+ *
+ * @since Commons IO 1.0
+ * @version $Revision: 1.6 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Stephen Colebourne
+ */
+public class NotFileFilter extends AbstractFileFilter {
+    
+    /** The filter */
+    private IOFileFilter filter;
+
+    /**
+     * Constructs a new file filter that NOTs the result of another filters.
+     * 
+     * @param filter  the filter, must not be null
+     * @throws IllegalArgumentException if the filter is null
+     */
+    public NotFileFilter(IOFileFilter filter) {
+        if (filter == null) {
+            throw new IllegalArgumentException("The filter must not be null");
+        }
+        this.filter = filter;
+    }
+
+    /**
+     * Checks to see if both filters are true.
+     * 
+     * @param file  the File to check
+     * @return true if the filter returns false
+     */
+    public boolean accept(File file) {
+        return ! filter.accept(file);
+    }
+    
+    /**
+     * Checks to see if both filters are true.
+     * 
+     * @param file  the File directory
+     * @param name  the filename
+     * @return true if the filter returns false
+     */
+    public boolean accept(File file, String name) {
+        return ! filter.accept(file, name);
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/OrFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/OrFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/OrFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+
+/**
+ * This filter produces a logical OR of the two filters specified.
+ *
+ * @since Commons IO 1.0
+ * @version $Revision: 1.8 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Stephen Colebourne
+ */
+public class OrFileFilter extends AbstractFileFilter {
+    
+    /** The first filter */
+    private IOFileFilter filter1;
+    /** The second filter */
+    private IOFileFilter filter2;
+
+    /**
+     * Constructs a new file filter that ORs the result of two other filters.
+     * 
+     * @param filter1  the first filter, must not be null
+     * @param filter2  the second filter, must not be null
+     * @throws IllegalArgumentException if either filter is null
+     */
+    public OrFileFilter(IOFileFilter filter1, IOFileFilter filter2) {
+        if (filter1 == null || filter2 == null) {
+            throw new IllegalArgumentException("The filters must not be null");
+        }
+        this.filter1 = filter1;
+        this.filter2 = filter2;
+    }
+
+    /**
+     * Checks to see if either filter is true.
+     * 
+     * @param file  the File to check
+     * @return true if either filter is true
+     */
+    public boolean accept(File file) {
+        return filter1.accept(file) || filter2.accept(file);
+    }
+    
+    /**
+     * Checks to see if either filter is true.
+     * 
+     * @param file  the File directory
+     * @param name  the filename
+     * @return true if either filter is true
+     */
+    public boolean accept(File file, String name) {
+        return filter1.accept(file, name) || filter2.accept(file, name);
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/PrefixFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/PrefixFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/PrefixFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+import java.util.List;
+
+/**
+ * Filters filenames for a certain prefix.
+ * <p>
+ * For example, to print all files and directories in the 
+ * current directory whose name starts with <code>Test</code>:
+ *
+ * <pre>
+ * File dir = new File(".");
+ * String[] files = dir.list( new PrefixFileFilter("Test") );
+ * for ( int i = 0; i &lt; files.length; i++ ) {
+ *     System.out.println(files[i]);
+ * }
+ * </pre>
+ *
+ * @since Commons IO 1.0
+ * @version $Revision: 1.8 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ * @author Federico Barbieri
+ * @author Serge Knystautas
+ * @author Peter Donald
+ */
+public class PrefixFileFilter extends AbstractFileFilter {
+    
+    /** The filename prefixes to search for */
+    private String[] prefixes;
+
+    /**
+     * Constructs a new Prefix file filter for a single prefix.
+     * 
+     * @param prefix  the prefix to allow, must not be null
+     * @throws IllegalArgumentException if the prefix is null
+     */
+    public PrefixFileFilter(String prefix) {
+        if (prefix == null) {
+            throw new IllegalArgumentException("The prefix must not be null");
+        }
+        this.prefixes = new String[] {prefix};
+    }
+
+    /**
+     * Constructs a new Prefix file filter for any of an array of prefixes.
+     * <p>
+     * The array is not cloned, so could be changed after constructing the
+     * instance. This would be inadvisable however.
+     * 
+     * @param prefixes  the prefixes to allow, must not be null
+     * @throws IllegalArgumentException if the prefix array is null
+     */
+    public PrefixFileFilter(String[] prefixes) {
+        if (prefixes == null) {
+            throw new IllegalArgumentException("The array of prefixes must not be null");
+        }
+        this.prefixes = prefixes;
+    }
+
+    /**
+     * Constructs a new Prefix file filter for a list of prefixes.
+     * 
+     * @param prefixes  the prefixes to allow, must not be null
+     * @throws IllegalArgumentException if the prefix list is null
+     * @throws ClassCastException if the list does not contain Strings
+     */
+    public PrefixFileFilter(List prefixes) {
+        if (prefixes == null) {
+            throw new IllegalArgumentException("The list of prefixes must not be null");
+        }
+        this.prefixes = (String[]) prefixes.toArray(new String[prefixes.size()]);
+    }
+
+    /**
+     * Checks to see if the filename starts with the prefix.
+     * 
+     * @param file  the File to check
+     * @return true if the filename starts with one of our prefixes
+     */
+    public boolean accept(File file) {
+        String name = file.getName();
+        for (int i = 0; i < this.prefixes.length; i++) {
+            if (name.startsWith(this.prefixes[i])) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+    /**
+     * Checks to see if the filename starts with the prefix.
+     * 
+     * @param file  the File directory
+     * @param name  the filename
+     * @return true if the filename starts with one of our prefixes
+     */
+    public boolean accept(File file, String name) {
+        for (int i = 0; i < prefixes.length; i++) {
+            if (name.startsWith(prefixes[i])) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/SuffixFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/SuffixFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/SuffixFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+import java.util.List;
+
+/**
+ * Filters files based on the suffix (what the filename ends with).
+ * This is used in retrieving all the files of a particular type.
+ * <p>
+ * For example, to retrieve and print all <code>*.java</code> files 
+ * in the current directory:
+ *
+ * <pre>
+ * File dir = new File(".");
+ * String[] files = dir.list( new SuffixFileFilter(".java") );
+ * for (int i = 0; i &lt; files.length; i++) {
+ *     System.out.println(files[i]);
+ * }
+ * </pre>
+ *
+ * @since Commons IO 1.0
+ * @version $Revision: 1.6 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ * @author Federico Barbieri
+ * @author Serge Knystautas
+ * @author Peter Donald
+ */
+public class SuffixFileFilter extends AbstractFileFilter {
+    
+    /** The filename suffixes to search for */
+    private String[] suffixes;
+
+    /**
+     * Constructs a new Suffix file filter for a single extension.
+     * 
+     * @param suffix  the suffix to allow, must not be null
+     * @throws IllegalArgumentException if the suffix is null
+     */
+    public SuffixFileFilter(String suffix) {
+        if (suffix == null) {
+            throw new IllegalArgumentException("The suffix must not be null");
+        }
+        this.suffixes = new String[] {suffix};
+    }
+
+    /**
+     * Constructs a new Suffix file filter for an array of suffixs.
+     * <p>
+     * The array is not cloned, so could be changed after constructing the
+     * instance. This would be inadvisable however.
+     * 
+     * @param suffixes  the suffixes to allow, must not be null
+     * @throws IllegalArgumentException if the suffix array is null
+     */
+    public SuffixFileFilter(String[] suffixes) {
+        if (suffixes == null) {
+            throw new IllegalArgumentException("The array of suffixes must not be null");
+        }
+        this.suffixes = suffixes;
+    }
+
+    /**
+     * Constructs a new Suffix file filter for a list of suffixes.
+     * 
+     * @param suffixes  the suffixes to allow, must not be null
+     * @throws IllegalArgumentException if the suffix list is null
+     * @throws ClassCastException if the list does not contain Strings
+     */
+    public SuffixFileFilter(List suffixes) {
+        if (suffixes == null) {
+            throw new IllegalArgumentException("The list of suffixes must not be null");
+        }
+        this.suffixes = (String[]) suffixes.toArray(new String[suffixes.size()]);
+    }
+
+    /**
+     * Checks to see if the filename ends with the suffix.
+     * 
+     * @param file  the File to check
+     * @return true if the filename ends with one of our suffixes
+     */
+    public boolean accept(File file) {
+        String name = file.getName();
+        for (int i = 0; i < this.suffixes.length; i++) {
+            if (name.endsWith(this.suffixes[i])) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+    /**
+     * Checks to see if the filename ends with the suffix.
+     * 
+     * @param file  the File directory
+     * @param name  the filename
+     * @return true if the filename ends with one of our suffixes
+     */
+    public boolean accept(File file, String name) {
+        for (int i = 0; i < this.suffixes.length; i++) {
+            if (name.endsWith(this.suffixes[i])) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/TrueFileFilter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/TrueFileFilter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/TrueFileFilter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+
+/**
+ * A file filter that always returns true.
+ * 
+ * @since Commons IO 1.0
+ * @version $Revision: 1.7 $ $Date: 2004/02/23 04:37:57 $
+ * 
+ * @author Henri Yandell
+ * @author Stephen Colebourne
+ */
+public class TrueFileFilter implements IOFileFilter {
+    
+    /** Singleton instance of true filter */
+    public static final IOFileFilter INSTANCE = new TrueFileFilter();
+    
+    /**
+     * Restrictive consructor.
+     */
+    protected TrueFileFilter() {
+    }
+    
+    /**
+     * Returns true.
+     * 
+     * @param file  the file to check
+     * @return true
+     */
+    public boolean accept(File file) {
+        return true;
+    }
+    
+    /**
+     * Returns true.
+     * 
+     * @param dir  the directory to check
+     * @param name  the filename
+     * @return true
+     */
+    public boolean accept(File dir, String name) {
+        return true;
+    }
+    
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/package.html
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/package.html	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/filefilter/package.html	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,115 @@
+<html>
+  <body>
+<p>This package defines an interface (IOFileFilter) that combines both 
+{@link java.io.FileFilter} and {@link java.io.FilenameFilter}. Besides
+that the package offers a series of ready-to-use implementations of the
+IOFileFilter interface including implementation that allow you to combine
+other such filters.</p>
+<p>These filter can be used to list files or in {@link java.awt.FileDialog}, 
+for example.</p>
+     
+<p>There are four "primitive" FilenameFilters:</p>
+     
+<table>
+       <tbody>
+    <tr>
+      <td><a href="DirectoryFileFilter.html">DirectoryFilter</a></td>
+      <td>Only accept directories</td>
+    </tr>
+       <tr>
+      <td><a href="PrefixFileFilter.html">PrefixFileFilter</a></td>
+      <td>Filter based on a prefix</td>
+    </tr>
+       <tr>
+      <td><a href="SuffixFileFilter.html">SuffixFileFilter</a></td>
+      <td>Filter based on a suffix</td>
+    </tr>
+       <tr>
+      <td><a href="NameFileFilter.html">NameFileFilter</a></td>
+      <td>Filter based on a filename</td>
+    </tr>
+     
+  </tbody>
+</table>
+     
+<p>And there are five "boolean" FilenameFilters:</p>
+     
+<table>
+       <tbody>
+       <tr>
+      <td><a href="TrueFileFilter.html">TrueFileFilter</a></td>
+      <td>Accept all files</td>
+    </tr>
+       <tr>
+      <td><a href="FalseFileFilter.html">FalseFileFilter</a></td>
+      <td>Accept no files</td>
+    </tr>
+       <tr>
+      <td><a href="NotFileFilter.html">NotFileFilter</a></td>
+      <td>Applies a logical NOT to an existing filter</td>
+    </tr>
+    <tr>
+      <td><a href="AndFileFilter.html">AndFileFilter</a></td>
+      <td>Combines two filters using a logical AND</td>
+    </tr>
+       <tr>
+      <td><a href="OrFileFilter.html">OrFileFilter</a></td>
+      <td>Combines two filter using a logical OR</td>
+    </tr>
+     
+  </tbody>
+</table>
+      
+<p>These boolean FilenameFilters can be nested, to allow arbitrary expressions.
+For example, here is how one could print all non-directory files in the
+current directory, starting with "A", and ending in ".java" or ".class":</p>
+     
+<pre>
+  File dir = new File(".");
+  String[] files = dir.list( 
+    new AndFileFilter(
+      new AndFileFilter(
+        new PrefixFileFilter("A"),
+        new OrFileFilter(
+          new SuffixFileFilter(".class"),
+          new SuffixFileFilter(".java")
+        )
+      ),
+      new NotdFileFilter(
+        new DirectoryFileFilter()
+      )
+    )
+  );
+  for ( int i=0; i&lt;files.length; i++ ) {
+    System.out.println(files[i]);
+  }
+</pre>
+
+<p>This package also contains a utility class: 
+<a href="FileFilterUtils.html">FileFilterUtils</a>. It allows you to use all 
+file filters without having to put the in the import section. Here's how the 
+above example will look using FileFilterUtils:</p>
+<pre>
+  File dir = new File(".");
+  String[] files = dir.list( 
+    FileFilterUtils.andFileFilter(
+      FileFilterUtils.andFileFilter(
+        FileFilterUtils.prefixFileFilter("A"),
+        FileFilterUtils.orFileFilter(
+          FileFilterUtils.suffixFileFilter(".class"),
+          FileFilterUtils.suffixFileFilter(".java")
+        )
+      ),
+      FileFilterUtils.notFileFilter(
+        FileFilterUtils.directoryFileFilter()
+      )
+    )
+  );
+  for ( int i=0; i&lt;files.length; i++ ) {
+    System.out.println(files[i]);
+  }
+</pre>
+<p>There are a few other goodies in that class so please have a look at the 
+documentation in detail.</p>
+    </body>
+</html>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/CountingInputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/CountingInputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/CountingInputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Used in debugging, it counts the number of bytes that pass 
+ * through it.
+ *
+ * @author <a href="mailto:bayard at apache.org">Henri Yandell</a>
+ * @version $Id: CountingInputStream.java,v 1.8 2004/02/23 04:38:52 bayard Exp $
+ */
+public class CountingInputStream extends ProxyInputStream {
+
+    private int count;
+
+    /**
+     * Constructs a new CountingInputStream.
+     * @param in InputStream to delegate to
+     */
+    public CountingInputStream( InputStream in ) {
+        super(in);
+    }
+
+    /**
+     * Increases the count by super.read(b)'s return count
+     * 
+     * @see java.io.InputStream#read(byte[]) 
+     */
+    public int read(byte[] b) throws IOException {
+        int found = super.read(b);
+        this.count += found;
+        return found;
+    }
+
+    /**
+     * Increases the count by super.read(b, off, len)'s return count
+     *
+     * @see java.io.InputStream#read(byte[], int, int)
+     */
+    public int read(byte[] b, int off, int len) throws IOException {
+        int found = super.read(b, off, len);
+        this.count += found;
+        return found;
+    }
+
+    /**
+     * Increases the count by 1. 
+     *
+     * @see java.io.InputStream#read()
+     */
+    public int read() throws IOException {
+        this.count++;
+        return super.read();
+    }
+
+    /**
+     * The number of bytes that have passed through this stream.
+     *
+     * @return the number of bytes accumulated
+     */
+    public int getCount() {
+        return this.count;
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/DemuxInputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/DemuxInputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/DemuxInputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Data written to this stream is forwarded to a stream that has been associated
+ * with this thread.
+ *
+ * @author <a href="mailto:peter at apache.org">Peter Donald</a>
+ * @version $Revision: 1.5 $ $Date: 2004/02/23 04:38:52 $
+ */
+public class DemuxInputStream
+    extends InputStream
+{
+    private InheritableThreadLocal m_streams = new InheritableThreadLocal();
+
+    /**
+     * Bind the specified stream to the current thread.
+     *
+     * @param input the stream to bind
+     * @return the InputStream that was previously active
+     */
+    public InputStream bindStream( InputStream input )
+    {
+        InputStream oldValue = getStream();
+        m_streams.set( input );
+        return oldValue;
+    }
+
+    /**
+     * Closes stream associated with current thread.
+     *
+     * @throws IOException if an error occurs
+     */
+    public void close()
+        throws IOException
+    {
+        InputStream input = getStream();
+        if( null != input )
+        {
+            input.close();
+        }
+    }
+
+    /**
+     * Read byte from stream associated with current thread.
+     *
+     * @return the byte read from stream
+     * @throws IOException if an error occurs
+     */
+    public int read()
+        throws IOException
+    {
+        InputStream input = getStream();
+        if( null != input )
+        {
+            return input.read();
+        }
+        else
+        {
+            return -1;
+        }
+    }
+
+    /**
+     * Utility method to retrieve stream bound to current thread (if any).
+     */
+    private InputStream getStream()
+    {
+        return (InputStream)m_streams.get();
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/ProxyInputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/ProxyInputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/ProxyInputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A Proxy stream which acts as expected, that is it passes the method 
+ * calls on to the proxied stream and doesn't change which methods are 
+ * being called. 
+ * 
+ * It is an alternative base class to FilterInputStream
+ * to increase reusability, because FilterInputStream changes the 
+ * methods being called, such as read(byte[]) to read(byte[], int, int).
+ */
+public abstract class ProxyInputStream extends FilterInputStream {
+
+    private InputStream proxy;
+
+    /**
+     * Constructs a new ProxyInputStream.
+     * @param proxy InputStream to delegate to
+     */
+    public ProxyInputStream(InputStream proxy) {
+        super(proxy);
+        this.proxy = proxy;
+    }
+
+    /** @see java.io.InputStream#read() */
+    public int read() throws IOException {
+        return this.proxy.read();
+    }
+
+    /** @see java.io.InputStream#read(byte[]) */
+    public int read(byte[] bts) throws IOException {
+        return this.proxy.read(bts);
+    }
+
+    /** @see java.io.InputStream#read(byte[], int, int) */
+    public int read(byte[] bts, int st, int end) throws IOException {
+        return this.proxy.read(bts, st, end);
+    }
+
+    /** @see java.io.InputStream#skip(long) */
+    public long skip(long ln) throws IOException {
+        return this.proxy.skip(ln);
+    }
+
+    /** @see java.io.InputStream#available() */
+    public int available() throws IOException {
+        return this.proxy.available();
+    }
+
+    /** @see java.io.InputStream#close() */
+    public void close() throws IOException {
+        this.proxy.close();
+    }
+
+    /** @see java.io.InputStream#mark(int) */
+    public synchronized void mark(int idx) {
+        this.proxy.mark(idx);
+    }
+
+    /** @see java.io.InputStream#reset() */
+    public synchronized void reset() throws IOException {
+        this.proxy.reset();
+    }
+
+    /** @see java.io.InputStream#markSupported() */
+    public boolean markSupported() {
+        return this.proxy.markSupported();
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/ProxyReader.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/ProxyReader.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/ProxyReader.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.FilterReader;
+import java.io.IOException;
+import java.io.Reader;
+
+/**
+ * A Proxy stream which acts as expected, that is it passes the method 
+ * calls on to the proxied stream and doesn't change which methods are 
+ * being called. 
+ * 
+ * It is an alternative base class to FilterReader
+ * to increase reusability, because FilterReader changes the 
+ * methods being called, such as read(char[]) to read(char[], int, int).
+ */
+public abstract class ProxyReader extends FilterReader {
+
+    private Reader proxy;
+
+    /**
+     * Constructs a new ProxyReader.
+     * @param proxy Reader to delegate to
+     */
+    public ProxyReader(Reader proxy) {
+        super(proxy);
+        this.proxy = proxy;
+    }
+
+    /** @see java.io.Reader#read() */
+    public int read() throws IOException {
+        return this.proxy.read();
+    }
+
+    /** @see java.io.Reader#read(char[]) */
+    public int read(char[] chr) throws IOException {
+        return this.proxy.read(chr);
+    }
+
+    /** @see java.io.Reader#read(char[], int, int) */
+    public int read(char[] chr, int st, int end) throws IOException {
+        return this.proxy.read(chr, st, end);
+    }
+
+    /** @see java.io.Reader#skip(long) */
+    public long skip(long ln) throws IOException {
+        return this.proxy.skip(ln);
+    }
+
+    /** @see java.io.Reader#ready() */
+    public boolean ready() throws IOException {
+        return this.proxy.ready();
+    }
+
+    /** @see java.io.Reader#close() */
+    public void close() throws IOException {
+        this.proxy.close();
+    }
+
+    /** @see java.io.Reader#mark(int) */
+    public synchronized void mark(int idx) throws IOException {
+        this.proxy.mark(idx);
+    }
+
+    /** @see java.io.Reader#reset() */
+    public synchronized void reset() throws IOException {
+        this.proxy.reset();
+    }
+
+    /** @see java.io.Reader#markSupported() */
+    public boolean markSupported() {
+        return this.proxy.markSupported();
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/SwappedDataInputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/SwappedDataInputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/SwappedDataInputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.input;
+
+import java.io.DataInput;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.apache.commons.io.EndianUtils;
+
+/**
+ * DataInput for systems relying on little endian data formats.
+ * When read, values will be changed from little endian to big 
+ * endian formats for internal usage. 
+ *
+ * <p><b>Origin of code: </b>Avalon Excalibur (IO)</p>
+ *
+ * @author <a href="mailto:peter at apache.org">Peter Donald</a>
+ * @version CVS $Revision: 1.8 $ $Date: 2004/02/23 04:56:59 $
+ */
+public class SwappedDataInputStream extends ProxyInputStream
+    implements DataInput
+{
+
+    /**
+     * Constructs a SwappedDataInputStream.
+     *
+     * @param input InputStream to read from
+     */
+    public SwappedDataInputStream( InputStream input )
+    {
+        super( input );
+    }
+
+    /** @see java.io.DataInput#readBoolean() */
+    public boolean readBoolean()
+        throws IOException, EOFException
+    {
+        return ( 0 == readByte() );
+    }
+
+    /** @see java.io.DataInput#readByte() */
+    public byte readByte()
+        throws IOException, EOFException
+    {
+        return (byte)in.read();
+    }
+
+    /** @see java.io.DataInput#readChar() */
+    public char readChar()
+        throws IOException, EOFException
+    {
+        return (char)readShort();
+    }
+
+    /** @see java.io.DataInput#readDouble() */
+    public double readDouble()
+        throws IOException, EOFException
+    {
+        return EndianUtils.readSwappedDouble( in );
+    }
+
+    /** @see java.io.DataInput#readFloat() */
+    public float readFloat()
+        throws IOException, EOFException
+    {
+        return EndianUtils.readSwappedFloat( in );
+    }
+
+    /** @see java.io.DataInput#readFully(byte[]) */
+    public void readFully( byte[] data )
+        throws IOException, EOFException
+    {
+        readFully( data, 0, data.length );
+    }
+
+    /** @see java.io.DataInput#readFully(byte[], int, int) */
+    public void readFully( byte[] data, int offset, int length )
+        throws IOException, EOFException
+    {
+        int remaining = length;
+
+        while( remaining > 0 )
+        {
+            int location = offset + ( length - remaining );
+            int count = read( data, location, remaining );
+
+            if( -1 == count )
+            {
+                throw new EOFException();
+            }
+
+            remaining -= count;
+        }
+    }
+
+    /** @see java.io.DataInput#readInt() */
+    public int readInt()
+        throws IOException, EOFException
+    {
+        return EndianUtils.readSwappedInteger( in );
+    }
+
+    /**
+     * Not currently supported.
+     *
+     * @see java.io.DataInput#readLine()
+     */
+    public String readLine()
+        throws IOException, EOFException
+    {
+        throw new UnsupportedOperationException( 
+                "Operation not supported: readLine()" );
+    }
+
+    /** @see java.io.DataInput#readLong() */
+    public long readLong()
+        throws IOException, EOFException
+    {
+        return EndianUtils.readSwappedLong( in );
+    }
+
+    /** @see java.io.DataInput#readShort() */
+    public short readShort()
+        throws IOException, EOFException
+    {
+        return EndianUtils.readSwappedShort( in );
+    }
+
+    /** @see java.io.DataInput#readUnsignedByte() */
+    public int readUnsignedByte()
+        throws IOException, EOFException
+    {
+        return in.read();
+    }
+
+    /** @see java.io.DataInput#readUnsignedShort() */
+    public int readUnsignedShort()
+        throws IOException, EOFException
+    {
+        return EndianUtils.readSwappedUnsignedShort( in );
+    }
+
+    /**
+     * Not currently supported. 
+     *
+     * @see java.io.DataInput#readUTF() 
+     */
+    public String readUTF()
+        throws IOException, EOFException
+    {
+        throw new UnsupportedOperationException( 
+                "Operation not supported: readUTF()" );
+    }
+
+    /** @see java.io.DataInput#skipBytes(int) */
+    public int skipBytes( int count )
+        throws IOException, EOFException
+    {
+        return (int)in.skip( count );
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/package.html
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/package.html	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/input/package.html	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,8 @@
+<html>
+    <body>
+        Implementations of input classes, such as
+        <code>InputStream</code> and
+        <code>Reader</code>.
+    </body>
+</html>
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ByteArrayOutputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ByteArrayOutputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ByteArrayOutputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2003,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.output;
+ 
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.List;
+
+/**
+ * This class implements an output stream in which the data is 
+ * written into a byte array. The buffer automatically grows as data 
+ * is written to it.
+ * <p> 
+ * The data can be retrieved using <code>toByteArray()</code> and
+ * <code>toString()</code>.
+ * <p>
+ * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
+ * this class can be called after the stream has been closed without
+ * generating an <tt>IOException</tt>.
+ * <p>
+ * This is an alternative implementation of the java.io.ByteArrayOutputStream
+ * class. The original implementation only allocates 32 bytes at the beginning.
+ * As this class is designed for heavy duty it starts at 1024 bytes. In contrast
+ * to the original it doesn't reallocate the whole memory block but allocates
+ * additional buffers. This way no buffers need to be garbage collected and
+ * the contents don't have to be copied to the new buffer. This class is
+ * designed to behave exactly like the original. The only exception is the
+ * deprecated toString(int) method that has been ignored.
+ * @author <a href="mailto:jeremias at apache.org">Jeremias Maerki</a>
+ * @version $Id: ByteArrayOutputStream.java,v 1.8 2004/04/24 19:24:09 jeremias Exp $
+ */
+public class ByteArrayOutputStream extends OutputStream {
+
+    private List buffers = new java.util.ArrayList();
+    private int currentBufferIndex;
+    private int filledBufferSum;
+    private byte[] currentBuffer;
+    private int count;
+
+    /**
+     * Creates a new byte array output stream. The buffer capacity is 
+     * initially 1024 bytes, though its size increases if necessary. 
+     */
+    public ByteArrayOutputStream() {
+        this(1024);
+    }
+
+    /**
+     * Creates a new byte array output stream, with a buffer capacity of 
+     * the specified size, in bytes. 
+     *
+     * @param size the initial size.
+     * @exception IllegalArgumentException if size is negative.
+     */
+    public ByteArrayOutputStream(int size) {
+        if (size < 0) {
+            throw new IllegalArgumentException(
+                "Negative initial size: " + size);
+        }
+        needNewBuffer(size);
+    }
+
+    private byte[] getBuffer(int index) {
+        return (byte[])buffers.get(index);
+    }
+
+    private void needNewBuffer(int newcount) {
+        if (currentBufferIndex < buffers.size() - 1) {
+            //Recycling old buffer
+            filledBufferSum += currentBuffer.length;
+            
+            currentBufferIndex++;
+            currentBuffer = getBuffer(currentBufferIndex);
+        } else {
+            //Creating new buffer
+            int newBufferSize;
+            if (currentBuffer == null) {
+                newBufferSize = newcount;
+                filledBufferSum = 0;
+            } else {
+                newBufferSize = Math.max(
+                    currentBuffer.length << 1, 
+                    newcount - filledBufferSum);
+                filledBufferSum += currentBuffer.length;
+            }
+            
+            currentBufferIndex++;
+            currentBuffer = new byte[newBufferSize];
+            buffers.add(currentBuffer);
+        }
+    }
+
+    /**
+     * @see java.io.OutputStream#write(byte[], int, int)
+     */
+    public synchronized void write(byte[] b, int off, int len) {
+        if ((off < 0) 
+                || (off > b.length) 
+                || (len < 0) 
+                || ((off + len) > b.length) 
+                || ((off + len) < 0)) {
+            throw new IndexOutOfBoundsException();
+        } else if (len == 0) {
+            return;
+        }
+        int newcount = count + len;
+        int remaining = len;
+        int inBufferPos = count - filledBufferSum;
+        while (remaining > 0) {
+            int part = Math.min(remaining, currentBuffer.length - inBufferPos);
+            System.arraycopy(b, off + len - remaining, currentBuffer, inBufferPos, part);
+            remaining -= part;
+            if (remaining > 0) {
+                needNewBuffer(newcount);
+                inBufferPos = 0;
+            }
+        }
+        count = newcount;
+    }
+
+    /**
+     * Calls the write(byte[]) method.
+     *
+     * @see java.io.OutputStream#write(int)
+     */
+    public synchronized void write(int b) {
+        write(new byte[] {(byte)b}, 0, 1);
+    }
+
+    /**
+     * @see java.io.ByteArrayOutputStream#size()
+     */
+    public int size() {
+        return count;
+    }
+
+    /**
+     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
+     * this class can be called after the stream has been closed without
+     * generating an <tt>IOException</tt>.
+     * @throws IOException in case an I/O error occurs
+     */
+    public void close() throws IOException {
+        //nop
+    }
+
+    /**
+     * @see java.io.ByteArrayOutputStream#reset()
+     */
+    public synchronized void reset() {
+        count = 0;
+        filledBufferSum = 0;
+        currentBufferIndex = 0;
+        currentBuffer = getBuffer(currentBufferIndex);
+    }
+    
+    /**
+     * @see java.io.ByteArrayOutputStream#writeTo(OutputStream)
+     */
+    public synchronized void writeTo(OutputStream out) throws IOException {
+        int remaining = count;
+        for (int i = 0; i < buffers.size(); i++) {
+            byte[] buf = getBuffer(i);
+            int c = Math.min(buf.length, remaining);
+            out.write(buf, 0, c);
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+    }
+
+    /**
+     * @see java.io.ByteArrayOutputStream#toByteArray()
+     */
+    public synchronized byte toByteArray()[] {
+        int remaining = count;
+        int pos = 0;
+        byte newbuf[] = new byte[count];
+        for (int i = 0; i < buffers.size(); i++) {
+            byte[] buf = getBuffer(i);
+            int c = Math.min(buf.length, remaining);
+            System.arraycopy(buf, 0, newbuf, pos, c);
+            pos += c;
+            remaining -= c;
+            if (remaining == 0) {
+                break;
+            }
+        }
+        return newbuf;
+    }
+
+    /**
+     * @see java.io.ByteArrayOutputStream#toString()
+     */
+    public String toString() {
+        return new String(toByteArray());
+    }
+
+    /**
+     * @see java.io.ByteArrayOutputStream#toString(String)
+     */
+    public String toString(String enc) throws UnsupportedEncodingException {
+        return new String(toByteArray(), enc);
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/CountingOutputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/CountingOutputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/CountingOutputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Used in debugging, it counts the number of bytes that pass 
+ * through it.
+ *
+ * @author <a href="mailto:bayard at apache.org">Henri Yandell</a>
+ * @version $Id: CountingOutputStream.java,v 1.5 2004/02/23 04:40:29 bayard Exp $
+ */
+public class CountingOutputStream extends ProxyOutputStream {
+
+    private int count;
+
+    /**
+     * Constructs a CountingOutputStream.
+     * @param out the OutputStream to write to
+     */
+    public CountingOutputStream( OutputStream out ) {
+        super(out);
+    }
+
+    /** @see java.io.OutputStream#write(byte[]) */
+    public void write(byte[] b) throws IOException {
+        count += b.length;
+        super.write(b);
+    }
+
+    /** @see java.io.OutputStream#write(byte[], int, int) */
+    public void write(byte[] b, int off, int len) throws IOException {
+        count += len;
+        super.write(b, off, len);
+    }
+
+    /** @see java.io.OutputStream#write(int) */
+    public void write(int b) throws IOException {
+        count++;
+        super.write(b);
+    }
+
+    /**
+     * The number of bytes that have passed through this stream.
+     * @return the number of bytes accumulated
+     */
+    public int getCount() {
+        return this.count;
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/DeferredFileOutputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/DeferredFileOutputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/DeferredFileOutputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.io.output;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * <p>An output stream which will retain data in memory until a specified
+ * threshold is reached, and only then commit it to disk. If the stream is
+ * closed before the threshold is reached, the data will not be written to
+ * disk at all.</p>
+ *
+ * @author <a href="mailto:martinc at apache.org">Martin Cooper</a>
+ *
+ * @version $Id: DeferredFileOutputStream.java,v 1.2 2004/02/23 04:40:29 bayard Exp $
+ */
+public class DeferredFileOutputStream
+    extends ThresholdingOutputStream
+{
+
+    // ----------------------------------------------------------- Data members
+
+
+    /**
+     * The output stream to which data will be written prior to the theshold
+     * being reached.
+     */
+    private ByteArrayOutputStream memoryOutputStream;
+
+
+    /**
+     * The output stream to which data will be written after the theshold is
+     * reached.
+     */
+    private FileOutputStream diskOutputStream;
+
+
+    /**
+     * The output stream to which data will be written at any given time. This
+     * will always be one of <code>memoryOutputStream</code> or
+     * <code>diskOutputStream</code>.
+     */
+    private OutputStream currentOutputStream;
+
+
+    /**
+     * The file to which output will be directed if the threshold is exceeded.
+     */
+    private File outputFile;
+
+
+    // ----------------------------------------------------------- Constructors
+
+
+    /**
+     * Constructs an instance of this class which will trigger an event at the
+     * specified threshold, and save data to a file beyond that point.
+     *
+     * @param threshold  The number of bytes at which to trigger an event.
+     * @param outputFile The file to which data is saved beyond the threshold.
+     */
+    public DeferredFileOutputStream(int threshold, File outputFile)
+    {
+        super(threshold);
+        this.outputFile = outputFile;
+
+        memoryOutputStream = new ByteArrayOutputStream(threshold);
+        currentOutputStream = memoryOutputStream;
+    }
+
+
+    // --------------------------------------- ThresholdingOutputStream methods
+
+
+    /**
+     * Returns the current output stream. This may be memory based or disk
+     * based, depending on the current state with respect to the threshold.
+     *
+     * @return The underlying output stream.
+     *
+     * @exception IOException if an error occurs.
+     */
+    protected OutputStream getStream() throws IOException
+    {
+        return currentOutputStream;
+    }
+
+
+    /**
+     * Switches the underlying output stream from a memory based stream to one
+     * that is backed by disk. This is the point at which we realise that too
+     * much data is being written to keep in memory, so we elect to switch to
+     * disk-based storage.
+     *
+     * @exception IOException if an error occurs.
+     */
+    protected void thresholdReached() throws IOException
+    {
+        byte[] data = memoryOutputStream.toByteArray();
+        FileOutputStream fos = new FileOutputStream(outputFile);
+        fos.write(data);
+        diskOutputStream = fos;
+        currentOutputStream = fos;
+        memoryOutputStream = null;
+    }
+
+
+    // --------------------------------------------------------- Public methods
+
+
+    /**
+     * Determines whether or not the data for this output stream has been
+     * retained in memory.
+     *
+     * @return <code>true</code> if the data is available in memory;
+     *         <code>false</code> otherwise.
+     */
+    public boolean isInMemory()
+    {
+        return (!isThresholdExceeded());
+    }
+
+
+    /**
+     * Returns the data for this output stream as an array of bytes, assuming
+     * that the data has been retained in memory. If the data was written to
+     * disk, this method returns <code>null</code>.
+     *
+     * @return The data for this output stream, or <code>null</code> if no such
+     *         data is available.
+     */
+    public byte[] getData()
+    {
+        if (memoryOutputStream != null)
+        {
+            return memoryOutputStream.toByteArray();
+        }
+        return null;
+    }
+
+
+    /**
+     * Returns the data for this output stream as a <code>File</code>, assuming
+     * that the data was written to disk. If the data was retained in memory,
+     * this method returns <code>null</code>.
+     *
+     * @return The file for this output stream, or <code>null</code> if no such
+     *         file exists.
+     */
+    public File getFile()
+    {
+        return outputFile;
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/DemuxOutputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/DemuxOutputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/DemuxOutputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Data written to this stream is forwarded to a stream that has been associated
+ * with this thread.
+ *
+ * @author <a href="mailto:peter at apache.org">Peter Donald</a>
+ * @version $Revision: 1.5 $ $Date: 2004/02/23 04:40:29 $
+ */
+public class DemuxOutputStream
+    extends OutputStream
+{
+    private InheritableThreadLocal m_streams = new InheritableThreadLocal();
+
+    /**
+     * Bind the specified stream to the current thread.
+     *
+     * @param output the stream to bind
+     * @return the OutputStream that was previously active
+     */
+    public OutputStream bindStream( OutputStream output )
+    {
+        OutputStream stream = getStream();
+        m_streams.set( output );
+        return stream;
+    }
+
+    /**
+     * Closes stream associated with current thread.
+     *
+     * @throws IOException if an error occurs
+     */
+    public void close()
+        throws IOException
+    {
+        OutputStream output = getStream();
+        if( null != output )
+        {
+            output.close();
+        }
+    }
+
+    /**
+     * Flushes stream associated with current thread.
+     *
+     * @throws IOException if an error occurs
+     */
+    public void flush()
+        throws IOException
+    {
+        OutputStream output = getStream();
+        if( null != output )
+        {
+            output.flush();
+        }
+    }
+
+    /**
+     * Writes byte to stream associated with current thread.
+     *
+     * @param ch the byte to write to stream
+     * @throws IOException if an error occurs
+     */
+    public void write( int ch )
+        throws IOException
+    {
+        OutputStream output = getStream();
+        if( null != output )
+        {
+            output.write( ch );
+        }
+    }
+
+    /**
+     * Utility method to retrieve stream bound to current thread (if any).
+     */
+    private OutputStream getStream()
+    {
+        return (OutputStream)m_streams.get();
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/LockableFileWriter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/LockableFileWriter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/LockableFileWriter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+
+/**
+ * FileWriter that will create and honor lock files to allow simple
+ * cross thread file lock handling.  If <code>Writer</code> attributes
+ * are unspecified, the default behavior is to overwrite (rather than
+ * to append), and to use the value of the system property
+ * <code>java.io.tmpdir</code> for the lock file directory.
+ *
+ * @author <a href="mailto:sanders at apache.org">Scott Sanders</a>
+ * @author <a href="mailto:ms at collab.net">Michael Salmon</a>
+ * @author <a href="mailto:jon at collab.net">Jon S. Stevens</a>
+ * @author <a href="mailto:dlr at finemaltcoding.com">Daniel Rall</a>
+ * @version $Id: LockableFileWriter.java,v 1.7 2004/02/23 04:40:29 bayard Exp $
+ */
+public class LockableFileWriter extends Writer {
+
+    private static final String LCK = ".lck";
+
+    private File lockFile = null;
+
+    private FileWriter writer = null;
+
+    private boolean append = false;
+
+    /**
+     * Constructs a LockableFileWriter. If the file exists, it is overwritten.
+     * @param fileName file to write to
+     * @throws IOException in case of an I/O error
+     */
+    public LockableFileWriter(String fileName)
+            throws IOException {
+        this(fileName, false, null);
+    }
+
+    /**
+     * Constructs a LockableFileWriter.
+     * @param fileName file to write to
+     * @param append true if content should be appended (default is to overwrite).
+     * @throws IOException in case of an I/O error
+     */
+    public LockableFileWriter(String fileName, boolean append)
+            throws IOException {
+        this(fileName, append, null);
+    }
+
+    /**
+     * Constructs a LockableFileWriter.
+     * @param fileName file to write to
+     * @param append true if content should be appended (default is to overwrite).
+     * @param lockDir Specifies the directory in which the lock file should be held.
+     * @throws IOException in case of an I/O error
+     */
+    public LockableFileWriter(String fileName, boolean append, String lockDir)
+            throws IOException {
+        this(new File(fileName), append, lockDir);
+    }
+
+    /**
+     * Constructs a LockableFileWriter. If the file exists, it is overwritten.
+     * @param file file to write to
+     * @throws IOException in case of an I/O error
+     */
+    public LockableFileWriter(File file)
+            throws IOException {
+        this(file, false, null);
+    }
+
+    /**
+     * Constructs a LockableFileWriter.
+     * @param file file to write to
+     * @param append true if content should be appended (default is to overwrite).
+     * @throws IOException in case of an I/O error
+     */
+    public LockableFileWriter(File file, boolean append)
+            throws IOException {
+        this(file, append, null);
+    }
+
+    /**
+     * Constructs a LockableFileWriter.
+     * @param file file to write to
+     * @param append true if content should be appended (default is to overwrite).
+     * @param lockDir Specifies the directory in which the lock file should be held.
+     * @throws IOException in case of an I/O error
+     */
+    public LockableFileWriter(File file, boolean append, String lockDir)
+            throws IOException {
+        this.append = append;
+
+        if (lockDir == null) {
+            lockDir = System.getProperty("java.io.tmpdir");
+        }
+        testLockDir(new File(lockDir));
+        this.lockFile = new File(lockDir, file.getName() + LCK);
+        createLock();
+
+        this.writer = new FileWriter(file.getAbsolutePath(), this.append);
+    }
+
+    private void testLockDir(File lockDir)
+            throws IOException {
+        if (!lockDir.exists()) {
+            throw new IOException(
+                    "Could not find lockDir: " + lockDir.getAbsolutePath());
+        }
+        if (!lockDir.canWrite()) {
+            throw new IOException(
+                    "Could not write to lockDir: " + lockDir.getAbsolutePath());
+        }
+    }
+
+    private void createLock()
+            throws IOException {
+        synchronized (LockableFileWriter.class) {
+            if (!lockFile.createNewFile()) {
+                throw new IOException("Can't write file, lock " +
+                        lockFile.getAbsolutePath() + " exists");
+            }
+            lockFile.deleteOnExit();
+        }
+    }
+
+    /** @see java.io.Writer#close() */
+    public void close()
+            throws IOException {
+        try {
+            writer.close();
+        } finally {
+            lockFile.delete();
+        }
+    }
+
+    /** @see java.io.Writer#write(char[], int, int) */
+    public void write(char[] cbuf, int off, int len)
+            throws IOException {
+        writer.write(cbuf, off, len);
+    }
+
+    /** @see java.io.Writer#flush() */
+    public void flush()
+            throws IOException {
+        writer.flush();
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/NullOutputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/NullOutputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/NullOutputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2003,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.output;
+ 
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This OutputStream writes all data to the famous <b>/dev/null</b>.
+ * @author <a href="mailto:jeremias at apache.org">Jeremias Maerki</a>
+ * @version $Id: NullOutputStream.java,v 1.4 2004/02/23 04:40:29 bayard Exp $
+ */
+public class NullOutputStream extends OutputStream {
+
+    /**
+     * @see java.io.OutputStream#write(byte[], int, int)
+     */
+    public synchronized void write(byte[] b, int off, int len) {
+        //to /dev/null
+    }
+
+    /**
+     * @see java.io.OutputStream#write(int)
+     */
+    public synchronized void write(int b) {
+        //to /dev/null
+    }
+
+    /**
+     * @see java.io.OutputStream#write(byte[])
+     */
+    public void write(byte[] b) throws IOException {
+        //to /dev/null
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ProxyOutputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ProxyOutputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ProxyOutputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import java.io.IOException;
+import java.io.FilterOutputStream;
+import java.io.OutputStream;
+
+/**
+ * 
+ * A Proxy stream which acts as expected, that is it passes the method 
+ * calls on to the proxied stream and doesn't change which methods are 
+ * being called. It is an alternative base class to FilterOutputStream
+ * to increase reusability.
+ */
+public class ProxyOutputStream extends FilterOutputStream {
+
+    private OutputStream proxy;
+
+    /**
+     * Constructs a new ProxyOutputStream.
+     * @param proxy OutputStream to delegate to
+     */
+    public ProxyOutputStream(OutputStream proxy) {
+        super(proxy);
+        this.proxy = proxy;
+    }
+
+    /** @see java.io.OutputStream#write(int) */
+    public void write(int idx) throws IOException {
+        this.proxy.write(idx);
+    }
+
+    /** @see java.io.OutputStream#write(byte[]) */
+    public void write(byte[] bts) throws IOException {
+        this.proxy.write(bts);
+    }
+
+    /** @see java.io.OutputStream#write(byte[], int, int) */
+    public void write(byte[] bts, int st, int end) throws IOException {
+        this.proxy.write(bts, st, end);
+    }
+
+    /** @see java.io.OutputStream#flush() */
+    public void flush() throws IOException {
+        this.proxy.flush();
+    }
+
+    /** @see java.io.OutputStream#close() */
+    public void close() throws IOException {
+        this.proxy.close();
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ProxyWriter.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ProxyWriter.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ProxyWriter.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import java.io.IOException;
+import java.io.FilterWriter;
+import java.io.Writer;
+
+/**
+ * 
+ * A Proxy stream which acts as expected, that is it passes the method 
+ * calls on to the proxied stream and doesn't change which methods are 
+ * being called. It is an alternative base class to FilterWriter
+ * to increase reusability, because FilterWriter changes the 
+ * methods being called, such as write(char[]) to write(char[], int, int)
+ * and write(String) to write(String, int, int).
+ */
+public class ProxyWriter extends FilterWriter {
+
+    private Writer proxy;
+
+    /**
+     * Constructs a new ProxyWriter.
+     * @param proxy Writer to delegate to
+     */
+    public ProxyWriter(Writer proxy) {
+        super(proxy);
+        this.proxy = proxy;
+    }
+
+    /** @see java.io.Writer#write(int) */
+    public void write(int idx) throws IOException {
+        this.proxy.write(idx);
+    }
+
+    /** @see java.io.Writer#write(char[]) */
+    public void write(char[] chr) throws IOException {
+        this.proxy.write(chr);
+    }
+
+    /** @see java.io.Writer#write(char[], int, int) */
+    public void write(char[] chr, int st, int end) throws IOException {
+        this.proxy.write(chr, st, end);
+    }
+
+    /** @see java.io.Writer#write(String) */
+    public void write(String str) throws IOException {
+        this.proxy.write(str);
+    }
+
+    /** @see java.io.Writer#write(String, int, int) */
+    public void write(String str, int st, int end) throws IOException {
+        this.proxy.write(str, st, end);
+    }
+
+    /** @see java.io.Writer#flush() */
+    public void flush() throws IOException {
+        this.proxy.flush();
+    }
+
+    /** @see java.io.Writer#close() */
+    public void close() throws IOException {
+        this.proxy.close();
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/TeeOutputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/TeeOutputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/TeeOutputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.output;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Classic splitter of OutputStream. Named after the unix 'tee' 
+ * command. It allows a stream to be branched off so there 
+ * are now two streams.
+ *
+ * @author <a href="mailto:bayard at apache.org">Henri Yandell</a>
+ * @version $Id: TeeOutputStream.java,v 1.6 2004/02/23 04:53:04 bayard Exp $
+ */
+public class TeeOutputStream extends ProxyOutputStream {
+
+    /** the second OutputStream to write to */
+    protected OutputStream branch;
+
+    /**
+     * Constructs a TeeOutputStream.
+     * @param out the main OutputStream
+     * @param branch the second OutputStream
+     */
+    public TeeOutputStream( OutputStream out, OutputStream branch ) {
+        super(out);
+        this.branch = branch;
+    }
+
+    /** @see java.io.OutputStream#write(byte[]) */
+    public synchronized void write(byte[] b) throws IOException {
+        super.write(b);
+        this.branch.write(b);
+    }
+
+    /** @see java.io.OutputStream#write(byte[], int, int) */
+    public synchronized void write(byte[] b, int off, int len) throws IOException {
+        super.write(b, off, len);
+        this.branch.write(b, off, len);
+    }
+
+    /** @see java.io.OutputStream#write(int) */
+    public synchronized void write(int b) throws IOException {
+        super.write(b);
+        this.branch.write(b);
+    }
+
+    /**
+     * Flushes both streams.
+     *
+     * @see java.io.OutputStream#flush()
+     */
+    public void flush() throws IOException {
+        super.flush();
+        this.branch.flush();
+    }
+
+    /**
+     * Closes both streams. 
+     *
+     * @see java.io.OutputStream#close() 
+     */
+    public void close() throws IOException {
+        super.close();
+        this.branch.close();
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ThresholdingOutputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ThresholdingOutputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/ThresholdingOutputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,249 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.io.output;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+
+/**
+ * An output stream which triggers an event when a specified number of bytes of
+ * data have been written to it. The event can be used, for example, to throw
+ * an exception if a maximum has been reached, or to switch the underlying
+ * stream type when the threshold is exceeded.
+ * <p>
+ * This class overrides all <code>OutputStream</code> methods. However, these
+ * overrides ultimately call the corresponding methods in the underlying output
+ * stream implementation.
+ * <p>
+ * NOTE: This implementation may trigger the event <em>before</em> the threshold
+ * is actually reached, since it triggers when a pending write operation would
+ * cause the threshold to be exceeded.
+ *
+ * @author <a href="mailto:martinc at apache.org">Martin Cooper</a>
+ *
+ * @version $Id: ThresholdingOutputStream.java,v 1.2 2004/02/23 04:40:29 bayard Exp $
+ */
+public abstract class ThresholdingOutputStream
+    extends OutputStream
+{
+
+    // ----------------------------------------------------------- Data members
+
+
+    /**
+     * The threshold at which the event will be triggered.
+     */
+    private int threshold;
+
+
+    /**
+     * The number of bytes written to the output stream.
+     */
+    private long written;
+
+
+    /**
+     * Whether or not the configured threshold has been exceeded.
+     */
+    private boolean thresholdExceeded;
+
+
+    // ----------------------------------------------------------- Constructors
+
+
+    /**
+     * Constructs an instance of this class which will trigger an event at the
+     * specified threshold.
+     *
+     * @param threshold The number of bytes at which to trigger an event.
+     */
+    public ThresholdingOutputStream(int threshold)
+    {
+        this.threshold = threshold;
+    }
+
+
+    // --------------------------------------------------- OutputStream methods
+
+
+    /**
+     * Writes the specified byte to this output stream.
+     *
+     * @param b The byte to be written.
+     *
+     * @exception IOException if an error occurs.
+     */
+    public void write(int b) throws IOException
+    {
+        checkThreshold(1);
+        getStream().write(b);
+        written++;
+    }
+
+
+    /**
+     * Writes <code>b.length</code> bytes from the specified byte array to this
+     * output stream.
+     *
+     * @param b The array of bytes to be written.
+     *
+     * @exception IOException if an error occurs.
+     */
+    public void write(byte b[]) throws IOException
+    {
+        checkThreshold(b.length);
+        getStream().write(b);
+        written += b.length;
+    }
+
+
+    /**
+     * Writes <code>len</code> bytes from the specified byte array starting at
+     * offset <code>off</code> to this output stream.
+     *
+     * @param b   The byte array from which the data will be written.
+     * @param off The start offset in the byte array.
+     * @param len The number of bytes to write.
+     *
+     * @exception IOException if an error occurs.
+     */
+    public void write(byte b[], int off, int len) throws IOException
+    {
+        checkThreshold(len);
+        getStream().write(b, off, len);
+        written += len;
+    }
+
+
+    /**
+     * Flushes this output stream and forces any buffered output bytes to be
+     * written out.
+     *
+     * @exception IOException if an error occurs.
+     */
+    public void flush() throws IOException
+    {
+        getStream().flush();
+    }
+
+
+    /**
+     * Closes this output stream and releases any system resources associated
+     * with this stream.
+     *
+     * @exception IOException if an error occurs.
+     */
+    public void close() throws IOException
+    {
+        try
+        {
+            flush();
+        }
+        catch (IOException ignored)
+        {
+            // ignore
+        }
+        getStream().close();
+    }
+
+
+    // --------------------------------------------------------- Public methods
+
+
+    /**
+     * Returns the threshold, in bytes, at which an event will be triggered.
+     *
+     * @return The threshold point, in bytes.
+     */
+    public int getThreshold()
+    {
+        return threshold;
+    }
+
+
+    /**
+     * Returns the number of bytes that have been written to this output stream.
+     *
+     * @return The number of bytes written.
+     */
+    public long getByteCount()
+    {
+        return written;
+    }
+
+
+    /**
+     * Determines whether or not the configured threshold has been exceeded for
+     * this output stream.
+     *
+     * @return <code>true</code> if the threshold has been reached;
+     *         <code>false</code> otherwise.
+     */
+    public boolean isThresholdExceeded()
+    {
+        return (written > threshold);
+    }
+
+
+    // ------------------------------------------------------ Protected methods
+
+
+    /**
+     * Checks to see if writing the specified number of bytes would cause the
+     * configured threshold to be exceeded. If so, triggers an event to allow
+     * a concrete implementation to take action on this.
+     *
+     * @param count The number of bytes about to be written to the underlying
+     *              output stream.
+     *
+     * @exception IOException if an error occurs.
+     */
+    protected void checkThreshold(int count) throws IOException
+    {
+        if (!thresholdExceeded && (written + count > threshold))
+        {
+            thresholdReached();
+            thresholdExceeded = true;
+        }
+    }
+
+
+    // ------------------------------------------------------- Abstract methods
+
+
+    /**
+     * Returns the underlying output stream, to which the corresponding
+     * <code>OutputStream</code> methods in this class will ultimately delegate.
+     *
+     * @return The underlying output stream.
+     *
+     * @exception IOException if an error occurs.
+     */
+    protected abstract OutputStream getStream() throws IOException;
+
+
+    /**
+     * Indicates that the configured threshold has been reached, and that a
+     * subclass should take whatever action necessary on this event. This may
+     * include changing the underlying output stream.
+     *
+     * @exception IOException if an error occurs.
+     */
+    protected abstract void thresholdReached() throws IOException;
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/package.html
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/package.html	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/output/package.html	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,8 @@
+<html>
+    <body>
+        Implementations of output classes, such as
+        <code>OutputStream</code> and
+        <code>Writer</code>.
+    </body>
+</html>
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/package.html
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/package.html	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/java/org/apache/commons/io/package.html	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,110 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+  <title>Package Documentation for org.apache.avalon.excalibur.io Package</title>
+</head>
+   <body bgcolor="white">
+     Utility code for IO operations.     <br>
+<span style="font-style: italic;">NOTE: Some classes are not yet included
+in this description</span><br>
+<br>
+     <a name="doc.Description"></a>     
+<div align="center">       <a href="#doc.Intro">[Introduction]</a>      
+<a href="#doc.IOUtils">[IO Utilities]</a>       <a href="#doc.FileUtils">[File
+Utilities]</a>       <a href="#doc.Endian">[Endian Utilities]</a>     </div>
+      <a name="doc.Intro"></a>     
+<h2>Introduction</h2>
+     
+<p>The <code>org.apache.commons.io</code> package contains utility code for
+file- and stream-based IO operation. 
+    </p>
+
+
+        <a name="doc.IOUtils"></a>     
+<h2>The <a href="IOUtils.html">org.apache.commons.io.IOUtils</a> class</h2>
+     
+<p>     The <a href="IOUtils.html">IOUtils</a> class contains a     comprehensive
+set of static methods for copying from:     </p>
+<ul>
+       <li><code>String</code></li>
+       <li><code>byte[]</code></li>
+       <li><code>InputStream</code></li>
+       <li><code>Reader</code></li>
+     
+</ul>
+     To:     
+<ul>
+       <li><code>String</code></li>
+       <li><code>byte[]</code></li>
+       <li><code>OutputStream</code></li>
+       <li><code>Writer</code></li>
+     
+</ul>
+     
+<p></p>
+      
+<p>As an example, consider the task of reading bytes from a URL, and printing
+them. This would     typically done like this:</p>
+     
+<pre>import java.net.URL;<br>import java.io.*;<br><br>public class ManualCopy {<br>  public static void main(String args[]) throws IOException {<br>    InputStream in = new URL( "http://jakarta.apache.org" ).openStream();<br>    
+    <b>InputStreamReader inR = new InputStreamReader( in );
+    BufferedReader buf = new BufferedReader( inR );
+    String line;
+    while ( ( line = buf.readLine() ) != null )
+    {
+      System.out.println( line );
+    }</b>
+    in.close();
+  }
+}
+   </pre>
+     
+<p>With the IOUtils class, that could be done with:</p>
+     
+<pre>import java.net.URL;<br>import java.io.*;<br>import org.apache.commons.io.IOUtils;<br><br>public class IOUtilsCopy {<br>  public static void main(String args[]) throws IOException {<br>    InputStream in = new URL( "http://jakarta.apache.org" ).openStream();<br>    
+<b>System.out.println( IOUtils.toString( in ) );</b>
+    in.close();
+  }   
+}
+    </pre>
+     
+<p>In certain application domains, such IO operations are common, and this
+class can save a     great deal of time.</p>
+     
+<p>For utility code such as this, flexibility and speed are of primary importance.
+In IOUtils,     each kind of copy method has a variant which allows the buffer
+size to be set. For methods that     convert bytes to chars, the encoding
+method may also be set.</p>
+       <a name="doc.FileUtils"></a>     
+<h2>The <a href="FileUtils.html">org.apache.commons.io.FileUtils</a> class</h2>
+      
+<p>The <a href="FileUtils.html">FileUtils</a> class contains     methods for
+retrieving different components of a file path (directory name, file base
+name, file     extension), methods for copying Files to other files and directories,
+and methods for deleting     and cleaning directories. For more information,
+see the <a href="FileUtils.html">class       description</a>     </p>
+       <a name="doc.Endian"></a>     
+<h2>The Endian classes</h2>
+       
+<p>Different computer architectures adopt different conventions for byte
+ordering. In so-called     "Little Endian" architectures (eg Intel), the
+low-order byte is stored in memory at the lowest     address, and subsequent
+bytes at higher addresses. For "Big Endian" architectures (eg Motorola), 
+   the situation is reversed.</p>
+     
+<p>There are two classes in this package of relevance:     </p>
+<ul>
+       <li>The <a href="EndianUtil.html">org.apache.commons.io.EndianUtil</a>
+class       contains static methods for swapping the Endian-ness of Java
+primitives and streams.</li>
+       <li>The       <a href="input/SwappedDataInputStream.html">org.apache.commons.io.input.SwappedDataInputStream</a> 
+      class is an implementation of the {@link java.io.DataInput} interface.
+With this, one can read       data from files of non-native Endian-ness.</li>
+     
+</ul>
+      
+<p>For more information, see <a
+ href="http://www.cs.umass.edu/%7Everts/cs32/endian.html">http://www.cs.umass.edu/~verts/cs32/endian.html</a>.  </p>
+<br>
+</body>
+</html>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/CopyUtilsTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/CopyUtilsTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/CopyUtilsTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Reader;
+import java.io.Writer;
+import java.util.Arrays;
+
+import org.apache.commons.io.output.ByteArrayOutputStream;
+import org.apache.commons.io.testtools.YellOnCloseInputStream;
+import org.apache.commons.io.testtools.YellOnFlushAndCloseOutputStream;
+import org.apache.commons.io.testtools.FileBasedTestCase;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+/**
+ * JUnit tests for CopyUtils.
+ * 
+ * @author Jeff Turner
+ * @author Matthew Hawthorne
+ * @author <a href="mailto:jeremias at apache.org">Jeremias Maerki</a>
+ * @version $Id: CopyUtilsTest.java,v 1.6 2004/02/23 05:02:25 bayard Exp $
+ * @see CopyUtils
+ */
+public class CopyUtilsTest extends FileBasedTestCase {
+
+    /*
+     * NOTE this is not particularly beautiful code. A better way to check for
+     * flush and close status would be to implement "trojan horse" wrapper
+     * implementations of the various stream classes, which set a flag when
+     * relevant methods are called. (JT)
+     */
+
+    private static final int FILE_SIZE = 1024 * 4 + 1;
+
+
+    private byte[] inData = generateTestData(FILE_SIZE);
+
+    public static void main(String[] args) {
+        TestRunner.run(suite());
+    }
+
+    public static Test suite() {
+        return new TestSuite(CopyUtilsTest.class);
+    }
+
+    public CopyUtilsTest(String testName) {
+        super(testName);
+    }
+
+    // ----------------------------------------------------------------
+    // Setup
+    // ----------------------------------------------------------------
+
+    public void setUp() throws Exception {
+    }
+
+    public void tearDown() throws Exception {
+    }
+
+    // ----------------------------------------------------------------
+    // Tests
+    // ----------------------------------------------------------------
+
+    public void testCopy_byteArrayToOutputStream() throws Exception {
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
+        
+        CopyUtils.copy(inData, out);
+
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
+    public void testCopy_byteArrayToWriter() throws Exception {
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
+        Writer writer = new java.io.OutputStreamWriter(baout, "US-ASCII");
+        
+        CopyUtils.copy(inData, writer);
+        writer.flush();
+
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
+    public void testCopy_inputStreamToOutputStream() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new YellOnCloseInputStream(in);
+
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
+
+        int count = CopyUtils.copy(in, out);
+        
+        assertTrue("Not all bytes were read", in.available() == 0);
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
+    public void testCopy_inputStreamToWriter() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new YellOnCloseInputStream(in);
+
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
+        Writer writer = new java.io.OutputStreamWriter(baout, "US-ASCII");
+        
+        CopyUtils.copy(in, writer);
+        writer.flush();
+
+        assertTrue("Not all bytes were read", in.available() == 0);
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
+    public void testCopy_readerToOutputStream() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new YellOnCloseInputStream(in);
+        Reader reader = new java.io.InputStreamReader(in, "US-ASCII");
+        
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
+        
+        CopyUtils.copy(reader, out);
+        //Note: this method *does* flush. It is equivalent to:
+        //  OutputStreamWriter _out = new OutputStreamWriter(fout);
+        //  IOUtils.copy( fin, _out, 4096 ); // copy( Reader, Writer, int );
+        //  _out.flush();
+        //  out = fout;
+
+        // Note: rely on the method to flush
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
+    public void testCopy_readerToWriter() throws Exception {
+        InputStream in = new ByteArrayInputStream(inData);
+        in = new YellOnCloseInputStream(in);
+        Reader reader = new java.io.InputStreamReader(in, "US-ASCII");
+
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
+        Writer writer = new java.io.OutputStreamWriter(baout, "US-ASCII");
+
+        int count = CopyUtils.copy(reader, writer);
+        writer.flush();
+        assertEquals(
+            "The number of characters returned by copy is wrong",
+            inData.length,
+            count);
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
+    public void testCopy_stringToOutputStream() throws Exception {
+        String str = new String(inData, "US-ASCII");
+        
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
+
+        CopyUtils.copy(str, out);
+        //Note: this method *does* flush. It is equivalent to:
+        //  OutputStreamWriter _out = new OutputStreamWriter(fout);
+        //  IOUtils.copy( str, _out, 4096 ); // copy( Reader, Writer, int );
+        //  _out.flush();
+        //  out = fout;
+        // note: we don't flush here; this IOUtils method does it for us
+
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
+    public void testCopy_stringToWriter() throws Exception {
+        String str = new String(inData, "US-ASCII");
+
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        OutputStream out = new YellOnFlushAndCloseOutputStream(baout, false, true);
+        Writer writer = new java.io.OutputStreamWriter(baout, "US-ASCII");
+
+        CopyUtils.copy(str, writer);
+        writer.flush();
+
+        assertEquals("Sizes differ", inData.length, baout.size());
+        assertTrue("Content differs", Arrays.equals(inData, baout.toByteArray()));
+    }
+
+} // CopyUtilsTest

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/DemuxTestCase.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/DemuxTestCase.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/DemuxTestCase.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,243 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Random;
+import junit.framework.TestCase;
+
+import org.apache.commons.io.output.ByteArrayOutputStream;
+import org.apache.commons.io.output.DemuxOutputStream;
+import org.apache.commons.io.input.DemuxInputStream;
+
+/**
+ * Basic unit tests for the multiplexing streams.
+ *
+ * @author <a href="mailto:peter at apache.org">Peter Donald</a>
+ */
+public class DemuxTestCase
+    extends TestCase
+{
+    private static final String T1 = "Thread1";
+    private static final String T2 = "Thread2";
+    private static final String T3 = "Thread3";
+    private static final String T4 = "Thread4";
+
+    private static final String DATA1 = "Data for thread1";
+    private static final String DATA2 = "Data for thread2";
+    private static final String DATA3 = "Data for thread3";
+    private static final String DATA4 = "Data for thread4";
+
+    private static Random c_random = new Random();
+    private HashMap m_outputMap = new HashMap();
+    private HashMap m_threadMap = new HashMap();
+
+    public DemuxTestCase( String name )
+    {
+        super( name );
+    }
+
+    private String getOutput( String threadName )
+        throws IOException
+    {
+        ByteArrayOutputStream output =
+            (ByteArrayOutputStream)m_outputMap.get( threadName );
+        assertNotNull( "getOutput()", output );
+
+        return output.toString();
+    }
+
+    private String getInput( String threadName )
+        throws IOException
+    {
+        ReaderThread thread = (ReaderThread)m_threadMap.get( threadName );
+        assertNotNull( "getInput()", thread );
+
+        return thread.getData();
+    }
+
+    private void doStart()
+        throws Exception
+    {
+        Iterator iterator = m_threadMap.keySet().iterator();
+        while( iterator.hasNext() )
+        {
+            String name = (String)iterator.next();
+            Thread thread = (Thread)m_threadMap.get( name );
+            thread.start();
+        }
+    }
+
+    private void doJoin()
+        throws Exception
+    {
+        Iterator iterator = m_threadMap.keySet().iterator();
+        while( iterator.hasNext() )
+        {
+            String name = (String)iterator.next();
+            Thread thread = (Thread)m_threadMap.get( name );
+            thread.join();
+        }
+    }
+
+    private void startWriter( String name,
+                              String data,
+                              DemuxOutputStream demux )
+        throws Exception
+    {
+        ByteArrayOutputStream output = new ByteArrayOutputStream();
+        m_outputMap.put( name, output );
+        WriterThread thread =
+            new WriterThread( name, data, output, demux );
+        m_threadMap.put( name, thread );
+    }
+
+    private void startReader( String name,
+                              String data,
+                              DemuxInputStream demux )
+        throws Exception
+    {
+        ByteArrayInputStream input = new ByteArrayInputStream( data.getBytes() );
+        ReaderThread thread = new ReaderThread( name, input, demux );
+        m_threadMap.put( name, thread );
+    }
+
+    public void testOutputStream()
+        throws Exception
+    {
+        DemuxOutputStream output = new DemuxOutputStream();
+        startWriter( T1, DATA1, output );
+        startWriter( T2, DATA2, output );
+        startWriter( T3, DATA3, output );
+        startWriter( T4, DATA4, output );
+
+        doStart();
+        doJoin();
+
+        assertEquals( "Data1", DATA1, getOutput( T1 ) );
+        assertEquals( "Data2", DATA2, getOutput( T2 ) );
+        assertEquals( "Data3", DATA3, getOutput( T3 ) );
+        assertEquals( "Data4", DATA4, getOutput( T4 ) );
+    }
+
+    public void testInputStream()
+        throws Exception
+    {
+        DemuxInputStream input = new DemuxInputStream();
+        startReader( T1, DATA1, input );
+        startReader( T2, DATA2, input );
+        startReader( T3, DATA3, input );
+        startReader( T4, DATA4, input );
+
+        doStart();
+        doJoin();
+
+        assertEquals( "Data1", DATA1, getInput( T1 ) );
+        assertEquals( "Data2", DATA2, getInput( T2 ) );
+        assertEquals( "Data3", DATA3, getInput( T3 ) );
+        assertEquals( "Data4", DATA4, getInput( T4 ) );
+    }
+
+    private static class ReaderThread
+        extends Thread
+    {
+        private StringBuffer m_buffer = new StringBuffer();
+        private InputStream m_input;
+        private DemuxInputStream m_demux;
+
+        ReaderThread( String name,
+                      InputStream input,
+                      DemuxInputStream demux )
+        {
+            super( name );
+            m_input = input;
+            m_demux = demux;
+        }
+
+        public String getData()
+        {
+            return m_buffer.toString();
+        }
+
+        public void run()
+        {
+            m_demux.bindStream( m_input );
+
+            try
+            {
+                int ch = m_demux.read();
+                while( -1 != ch )
+                {
+                    //System.out.println( "Reading: " + (char)ch );
+                    m_buffer.append( (char)ch );
+
+                    int sleepTime = Math.abs( c_random.nextInt() % 10 );
+                    Thread.sleep( sleepTime );
+                    ch = m_demux.read();
+                }
+            }
+            catch( Exception e )
+            {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private static class WriterThread
+        extends Thread
+    {
+        private byte[] m_data;
+        private OutputStream m_output;
+        private DemuxOutputStream m_demux;
+
+        WriterThread( String name,
+                      String data,
+                      OutputStream output,
+                      DemuxOutputStream demux )
+        {
+            super( name );
+            m_output = output;
+            m_demux = demux;
+            m_data = data.getBytes();
+        }
+
+        public void run()
+        {
+            m_demux.bindStream( m_output );
+            for( int i = 0; i < m_data.length; i++ )
+            {
+                try
+                {
+                    //System.out.println( "Writing: " + (char)m_data[ i ] );
+                    m_demux.write( m_data[ i ] );
+                    int sleepTime = Math.abs( c_random.nextInt() % 10 );
+                    Thread.sleep( sleepTime );
+                }
+                catch( Exception e )
+                {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+}
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/EndianUtilsTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/EndianUtilsTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/EndianUtilsTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,245 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+
+/**
+ * @author Henri Yandell (bayard at apache dot org)
+ * @version $Revision: 1.13 $ $Date: 2004/02/29 21:47:07 $
+ */
+public class EndianUtilsTest extends TestCase {
+
+    public EndianUtilsTest(String name) {
+        super(name);
+    }
+
+    public void testSwapShort() {
+        assertEquals( (short) 0, EndianUtils.swapShort( (short) 0 ) );
+        assertEquals( (short) 0x0201, EndianUtils.swapShort( (short) 0x0102 ) );
+        assertEquals( (short) 0xffff, EndianUtils.swapShort( (short) 0xffff ) );
+        assertEquals( (short) 0x0102, EndianUtils.swapShort( (short) 0x0201 ) );
+    }
+
+    public void testSwapInteger() {
+        assertEquals( 0, EndianUtils.swapInteger( 0 ) );
+        assertEquals( 0x04030201, EndianUtils.swapInteger( 0x01020304 ) );
+        assertEquals( 0x01000000, EndianUtils.swapInteger( 0x00000001 ) );
+        assertEquals( 0x00000001, EndianUtils.swapInteger( 0x01000000 ) );
+        assertEquals( 0x11111111, EndianUtils.swapInteger( 0x11111111 ) );
+        assertEquals( 0xabcdef10, EndianUtils.swapInteger( 0x10efcdab ) );
+        assertEquals( 0xab, EndianUtils.swapInteger( 0xab000000 ) );
+    }
+
+    public void testSwapLong() {
+        assertEquals( 0, EndianUtils.swapLong( 0 ) );
+        assertEquals( 0x0807060504030201L, EndianUtils.swapLong( 0x0102030405060708L ) );
+        assertEquals( 0xffffffffffffffffL, EndianUtils.swapLong( 0xffffffffffffffffL ) );
+        assertEquals( 0xab, EndianUtils.swapLong( 0xab00000000000000L ) );
+    }
+
+    public void testSwapFloat() {
+        assertEquals( 0.0f, EndianUtils.swapFloat( 0.0f ), 0.0 );
+        float f1 = Float.intBitsToFloat( 0x01020304 );
+        float f2 = Float.intBitsToFloat( 0x04030201 );
+        assertEquals( f2, EndianUtils.swapFloat( f1 ), 0.0 );
+    }
+
+    public void testSwapDouble() {
+        assertEquals( 0.0, EndianUtils.swapDouble( 0.0 ), 0.0 );
+        double d1 = Double.longBitsToDouble( 0x0102030405060708L );
+        double d2 = Double.longBitsToDouble( 0x0807060504030201L );
+        assertEquals( d2, EndianUtils.swapDouble( d1 ), 0.0 );
+    }
+
+    /**
+     * Tests all swapXxxx methods for symmetry when going from one endian 
+     * to another and back again. 
+     */
+    public void testSymmetry() {
+        assertEquals( (short) 0x0102, EndianUtils.swapShort( EndianUtils.swapShort( (short) 0x0102 ) ) );
+        assertEquals( 0x01020304, EndianUtils.swapInteger( EndianUtils.swapInteger( 0x01020304 ) ) );
+        assertEquals( 0x0102030405060708L, EndianUtils.swapLong( EndianUtils.swapLong( 0x0102030405060708L ) ) );
+        float f1 = Float.intBitsToFloat( 0x01020304 );
+        assertEquals( f1, EndianUtils.swapFloat( EndianUtils.swapFloat( f1 ) ), 0.0 );
+        double d1 = Double.longBitsToDouble( 0x0102030405060708L );
+        assertEquals( d1, EndianUtils.swapDouble( EndianUtils.swapDouble( d1 ) ), 0.0 );
+    }
+
+    public void testReadSwappedShort() throws IOException {
+        byte[] bytes = new byte[] { 0x02, 0x01 };
+        assertEquals( 0x0102, EndianUtils.readSwappedShort( bytes, 0 ) );
+
+        ByteArrayInputStream input = new ByteArrayInputStream(bytes);
+        assertEquals( 0x0102, EndianUtils.readSwappedShort( input ) );
+    }
+
+    public void testWriteSwappedShort() throws IOException {
+        byte[] bytes = new byte[2];
+        EndianUtils.writeSwappedShort( bytes, 0, (short) 0x0102 );
+        assertEquals( 0x02, bytes[0] );
+        assertEquals( 0x01, bytes[1] );
+
+        ByteArrayOutputStream baos = new ByteArrayOutputStream(2);
+        EndianUtils.writeSwappedShort( baos, (short) 0x0102 );
+        bytes = baos.toByteArray();
+        assertEquals( 0x02, bytes[0] );
+        assertEquals( 0x01, bytes[1] );
+    }
+
+    public void testReadSwappedUnsignedShort() throws IOException {
+        byte[] bytes = new byte[] { 0x02, 0x01 };
+        assertEquals( 0x00000102, EndianUtils.readSwappedUnsignedShort( bytes, 0 ) );
+
+        ByteArrayInputStream input = new ByteArrayInputStream(bytes);
+        assertEquals( 0x00000102, EndianUtils.readSwappedUnsignedShort( input ) );
+    }
+
+    public void testReadSwappedInteger() throws IOException {
+        byte[] bytes = new byte[] { 0x04, 0x03, 0x02, 0x01 };
+        assertEquals( 0x01020304, EndianUtils.readSwappedInteger( bytes, 0 ) );
+
+        ByteArrayInputStream input = new ByteArrayInputStream(bytes);
+        assertEquals( 0x01020304, EndianUtils.readSwappedInteger( input ) );
+    }
+
+    public void testWriteSwappedInteger() throws IOException {
+        byte[] bytes = new byte[4];
+        EndianUtils.writeSwappedInteger( bytes, 0, 0x01020304 );
+        assertEquals( 0x04, bytes[0] );
+        assertEquals( 0x03, bytes[1] );
+        assertEquals( 0x02, bytes[2] );
+        assertEquals( 0x01, bytes[3] );
+
+        ByteArrayOutputStream baos = new ByteArrayOutputStream(4);
+        EndianUtils.writeSwappedInteger( baos, 0x01020304 );
+        bytes = baos.toByteArray();
+        assertEquals( 0x04, bytes[0] );
+        assertEquals( 0x03, bytes[1] );
+        assertEquals( 0x02, bytes[2] );
+        assertEquals( 0x01, bytes[3] );
+    }
+
+    public void testReadSwappedUnsignedInteger() throws IOException {
+        byte[] bytes = new byte[] { 0x04, 0x03, 0x02, 0x01 };
+        assertEquals( 0x0000000001020304L, EndianUtils.readSwappedUnsignedInteger( bytes, 0 ) );
+
+        ByteArrayInputStream input = new ByteArrayInputStream(bytes);
+        assertEquals( 0x0000000001020304L, EndianUtils.readSwappedUnsignedInteger( input ) );
+    }
+
+    public void testReadSwappedLong() throws IOException {
+        byte[] bytes = new byte[] { 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01 };
+        assertEquals( 0x0102030405060708L, EndianUtils.readSwappedLong( bytes, 0 ) );
+
+        ByteArrayInputStream input = new ByteArrayInputStream(bytes);
+        assertEquals( 0x0102030405060708L, EndianUtils.readSwappedLong( input ) );
+    }
+
+    public void testWriteSwappedLong() throws IOException {
+        byte[] bytes = new byte[8];
+        EndianUtils.writeSwappedLong( bytes, 0, 0x0102030405060708L );
+        assertEquals( 0x08, bytes[0] );
+        assertEquals( 0x07, bytes[1] );
+        assertEquals( 0x06, bytes[2] );
+        assertEquals( 0x05, bytes[3] );
+        assertEquals( 0x04, bytes[4] );
+        assertEquals( 0x03, bytes[5] );
+        assertEquals( 0x02, bytes[6] );
+        assertEquals( 0x01, bytes[7] );
+
+        ByteArrayOutputStream baos = new ByteArrayOutputStream(8);
+        EndianUtils.writeSwappedLong( baos, 0x0102030405060708L );
+        bytes = baos.toByteArray();
+        assertEquals( 0x08, bytes[0] );
+        assertEquals( 0x07, bytes[1] );
+        assertEquals( 0x06, bytes[2] );
+        assertEquals( 0x05, bytes[3] );
+        assertEquals( 0x04, bytes[4] );
+        assertEquals( 0x03, bytes[5] );
+        assertEquals( 0x02, bytes[6] );
+        assertEquals( 0x01, bytes[7] );
+    }
+
+    public void testReadSwappedFloat() throws IOException {
+        byte[] bytes = new byte[] { 0x04, 0x03, 0x02, 0x01 };
+        float f1 = Float.intBitsToFloat( 0x01020304 );
+        float f2 = EndianUtils.readSwappedFloat( bytes, 0 );
+        assertEquals( f1, f2, 0.0 );
+
+        ByteArrayInputStream input = new ByteArrayInputStream(bytes);
+        assertEquals( f1, EndianUtils.readSwappedFloat( input ), 0.0 );
+    }
+
+    public void testWriteSwappedFloat() throws IOException {
+        byte[] bytes = new byte[4];
+        float f1 = Float.intBitsToFloat( 0x01020304 );
+        EndianUtils.writeSwappedFloat( bytes, 0, f1 );
+        assertEquals( 0x04, bytes[0] );
+        assertEquals( 0x03, bytes[1] );
+        assertEquals( 0x02, bytes[2] );
+        assertEquals( 0x01, bytes[3] );
+
+        ByteArrayOutputStream baos = new ByteArrayOutputStream(4);
+        EndianUtils.writeSwappedFloat( baos, f1 );
+        bytes = baos.toByteArray();
+        assertEquals( 0x04, bytes[0] );
+        assertEquals( 0x03, bytes[1] );
+        assertEquals( 0x02, bytes[2] );
+        assertEquals( 0x01, bytes[3] );
+    }
+
+    public void testReadSwappedDouble() throws IOException {
+        byte[] bytes = new byte[] { 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01 };
+        double d1 = Double.longBitsToDouble( 0x0102030405060708L );
+        double d2 = EndianUtils.readSwappedDouble( bytes, 0 );
+        assertEquals( d1, d2, 0.0 );
+
+        ByteArrayInputStream input = new ByteArrayInputStream(bytes);
+        assertEquals( d1, EndianUtils.readSwappedDouble( input ), 0.0 );
+    }
+
+    public void testWriteSwappedDouble() throws IOException {
+        byte[] bytes = new byte[8];
+        double d1 = Double.longBitsToDouble( 0x0102030405060708L );
+        EndianUtils.writeSwappedDouble( bytes, 0, d1 );
+        assertEquals( 0x08, bytes[0] );
+        assertEquals( 0x07, bytes[1] );
+        assertEquals( 0x06, bytes[2] );
+        assertEquals( 0x05, bytes[3] );
+        assertEquals( 0x04, bytes[4] );
+        assertEquals( 0x03, bytes[5] );
+        assertEquals( 0x02, bytes[6] );
+        assertEquals( 0x01, bytes[7] );
+
+        ByteArrayOutputStream baos = new ByteArrayOutputStream(8);
+        EndianUtils.writeSwappedDouble( baos, d1 );
+        bytes = baos.toByteArray();
+        assertEquals( 0x08, bytes[0] );
+        assertEquals( 0x07, bytes[1] );
+        assertEquals( 0x06, bytes[2] );
+        assertEquals( 0x05, bytes[3] );
+        assertEquals( 0x04, bytes[4] );
+        assertEquals( 0x03, bytes[5] );
+        assertEquals( 0x02, bytes[6] );
+        assertEquals( 0x01, bytes[7] );
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileCleanerTestCase.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileCleanerTestCase.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileCleanerTestCase.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2004 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+import org.apache.commons.io.testtools.FileBasedTestCase;
+
+/**
+ * This is used to test FileCleaner for correctness.
+ *
+ * @author Noel Bergman
+ * @author Martin Cooper
+ *
+ * @version $Id: FileCleanerTestCase.java,v 1.1 2004/03/18 06:04:14 martinc Exp $
+
+ * @see FileCleaner
+ */
+public class FileCleanerTestCase extends FileBasedTestCase {
+
+    private File testFile;
+
+    public static void main(String[] args) {
+        TestRunner.run(suite());
+    }
+
+    public static Test suite() {
+        return new TestSuite(FileCleanerTestCase.class);
+    }
+
+    public FileCleanerTestCase(String name) throws IOException {
+        super(name);
+
+        testFile = new File(getTestDirectory(), "file-test.txt");
+    }
+
+    /** @see junit.framework.TestCase#setUp() */
+    protected void setUp() throws Exception {
+        getTestDirectory().mkdirs();
+    }
+
+    /** @see junit.framework.TestCase#tearDown() */
+    protected void tearDown() throws Exception {
+        FileUtils.deleteDirectory(getTestDirectory());
+    }
+
+    /**
+     *  Test the FileCleaner implementation.
+     */
+    public void testFileCleaner() throws Exception {
+        String path = testFile.getPath();
+
+        assertFalse("File does not exist", testFile.exists());
+        RandomAccessFile r = new RandomAccessFile(testFile, "rw");
+        assertTrue("File exists", testFile.exists());
+
+        assertTrue("No files tracked", FileCleaner.getTrackCount() == 0);
+        FileCleaner.track(path, r);
+        assertTrue("One file tracked", FileCleaner.getTrackCount() == 1);
+
+        r.close();
+        testFile = null;
+        r = null;
+
+        while (FileCleaner.getTrackCount() != 0) {
+            System.gc();
+        }
+
+        assertTrue("No files tracked", FileCleaner.getTrackCount() == 0);
+        assertFalse("File does not exist", new File(path).exists());
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsFileNewerTestCase.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsFileNewerTestCase.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsFileNewerTestCase.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2003,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io;
+
+import java.io.File;
+import java.util.Date;
+
+import org.apache.commons.io.testtools.*;
+
+/**
+ * This is used to test FileUtils for correctness.
+ *
+ * @author <a href="mailto:alban.peignier at free.fr">Alban Peignier</a>
+ */
+public class FileUtilsFileNewerTestCase extends FileBasedTestCase {
+
+    // Test data
+    private static final int FILE1_SIZE = 1;
+    private static final int FILE2_SIZE = 1024 * 4 + 1;
+
+    private File m_testFile1;
+    private File m_testFile2;
+
+    public FileUtilsFileNewerTestCase(String name) {
+        super(name);
+        
+        m_testFile1 = new File(getTestDirectory(), "file1-test.txt");
+        m_testFile2 = new File(getTestDirectory(), "file2-test.txt");
+    }
+
+    /** @see junit.framework.TestCase#setUp() */
+    protected void setUp() throws Exception {
+        getTestDirectory().mkdirs();
+        createFile(m_testFile1, FILE1_SIZE);
+        createFile(m_testFile2, FILE2_SIZE);
+    }
+
+    /** @see junit.framework.TestCase#tearDown() */
+    protected void tearDown() throws Exception {
+        m_testFile1.delete();
+        m_testFile2.delete();
+    }
+
+    /**
+     * Tests the <code>isFileNewer(File, *)</code> methods which a "normal" file.
+     *
+     * @see FileUtils#isFileNewer(File, long)
+     * @see FileUtils#isFileNewer(File, Date)
+     * @see FileUtils#isFileNewer(File, File)
+     */
+    public void testIsFileNewer() {
+        if (!m_testFile1.exists())
+            throw new IllegalStateException("The m_testFile1 should exist");
+
+        long fileLastModified = m_testFile1.lastModified();
+        final long ONE_SECOND = 1000;
+
+        testIsFileNewer("one second earlier is not newer" , m_testFile1, fileLastModified + ONE_SECOND, false);
+        testIsFileNewer("same time is not newer" , m_testFile1, fileLastModified, false);
+        testIsFileNewer("one second later is newer" , m_testFile1, fileLastModified - ONE_SECOND, true);
+    }
+
+    /**
+     * Tests the <code>isFileNewer(File, *)</code> methods which a not existing file.
+     *
+     * @see FileUtils#isFileNewer(File, long)
+     * @see FileUtils#isFileNewer(File, Date)
+     * @see FileUtils#isFileNewer(File, File)
+     */
+    public void testIsFileNewerImaginaryFile() {
+        File imaginaryFile = new File(getTestDirectory(), "imaginaryFile");
+        if (imaginaryFile.exists())
+            throw new IllegalStateException("The imaginary File exists");
+
+        testIsFileNewer("imaginary file can be newer" , imaginaryFile, 0, false);
+    }
+
+    /**
+     * Tests the <code>isFileNewer(File, *)</code> methods which the specified conditions.
+     * <p/>
+     * Creates :
+     * <ul>
+     * <li>a <code>Date</code> which represents the time reference</li>
+     * <li>a temporary file with the same last modification date than the time reference</li>
+     * </ul>
+     * Then compares (with the needed <code>isFileNewer</code> method) the last modification date of 
+     * the specified file with the specified time reference, the created <code>Date</code> and the temporary 
+     * file.
+     * <br/>
+     * The test is successfull if the three comparaisons return the specified wanted result.
+     *
+     * @param description describes the tested situation
+     * @param file the file of which the last modification date is compared
+     * @param timeMillis the time reference measured in milliseconds since the epoch 
+     *
+     * @see FileUtils#isFileNewer(File, long)
+     * @see FileUtils#isFileNewer(File, Date)
+     * @see FileUtils#isFileNewer(File, File)
+     */
+    protected void testIsFileNewer(String description, File file, long time, boolean wantedResult)  {
+        assertEquals(description + " - time", wantedResult, FileUtils.isFileNewer(file, time));
+        assertEquals(description + " - date", wantedResult, FileUtils.isFileNewer(file, new Date(time)));
+        
+        File temporaryFile = m_testFile2;
+
+        temporaryFile.setLastModified(time);
+        if (temporaryFile.lastModified() != time)
+            throw new IllegalStateException("The temporary file hasn't the right last modification date");
+        assertEquals(description + " - file", wantedResult, FileUtils.isFileNewer(file, temporaryFile));
+    }
+
+    /**
+     * Tests the <code>isFileNewer(File, long)</code> method without specifying a <code>File</code>.
+     * <br/>
+     * The test is successfull if the method throws an <code>IllegalArgumentException</code>. 
+     */
+    public void testIsFileNewerNoFile() {
+        try {
+            FileUtils.isFileNewer(null,0);
+            fail("File not specified");
+        } catch (IllegalArgumentException e) {}
+    }
+
+    /**
+     * Tests the <code>isFileNewer(File, Date)</code> method without specifying a <code>Date</code>.
+     * <br/>
+     * The test is successfull if the method throws an <code>IllegalArgumentException</code>. 
+     */
+    public void testIsFileNewerNoDate() {
+        try {
+            FileUtils.isFileNewer(m_testFile1, (Date) null);
+            fail("Date not specified");
+        } catch (IllegalArgumentException e) {}
+    }
+
+    /**
+     * Tests the <code>isFileNewer(File, File)</code> method without specifying a reference <code>File</code>.
+     * <br/>
+     * The test is successfull if the method throws an <code>IllegalArgumentException</code>. 
+     */
+    public void testIsFileNewerNoFileReference() {
+        try {
+            FileUtils.isFileNewer(m_testFile1, (File) null);
+            fail("Reference file not specified");
+        } catch (IllegalArgumentException e) {}
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsListFilesTestCase.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsListFilesTestCase.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsListFilesTestCase.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2003,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.File;
+import java.util.Collection;
+import java.util.Iterator;
+
+import org.apache.commons.io.filefilter.FileFilterUtils;
+import org.apache.commons.io.filefilter.IOFileFilter;
+import org.apache.commons.io.testtools.FileBasedTestCase;
+
+/**
+ * Test cases for FileUtils.listFiles() methods.
+ */
+public class FileUtilsListFilesTestCase extends FileBasedTestCase {
+
+    public FileUtilsListFilesTestCase(String name) {
+        super(name);
+    }
+    
+    private File getLocalTestDirectory() {
+        return new File(getTestDirectory(), "list-files");
+    }
+    
+    /**
+     * @see junit.framework.TestCase#setUp()
+     */
+    protected void setUp() throws Exception {
+        File dir = getLocalTestDirectory();
+        if (dir.exists()) {
+            FileUtils.deleteDirectory(dir);
+        }
+        dir.mkdirs();
+        File file = new File(dir, "dummy-build.xml");
+        FileUtils.touch(file);
+        file = new File(dir, "README");
+        FileUtils.touch(file);
+        
+        dir = new File(dir, "subdir1");
+        dir.mkdirs();
+        file = new File(dir, "dummy-build.xml");
+        FileUtils.touch(file);
+        file = new File(dir, "dummy-readme.txt");
+        FileUtils.touch(file);
+        
+        dir = new File(dir, "subsubdir1");
+        dir.mkdirs();
+        file = new File(dir, "dummy-file.txt");
+        FileUtils.touch(file);
+        file = new File(dir, "dummy-index.html");
+        FileUtils.touch(file);
+        
+        dir = dir.getParentFile();
+        dir = new File(dir, "CVS");
+        dir.mkdirs();
+        file = new File(dir, "Entries");
+        FileUtils.touch(file);
+        file = new File(dir, "Repository");
+        FileUtils.touch(file);
+    }
+
+    /**
+     * @see junit.framework.TestCase#tearDown()
+     */
+    protected void tearDown() throws Exception {
+        File dir = getLocalTestDirectory();
+        FileUtils.deleteDirectory(dir);
+    }
+    
+    private Collection filesToFilenames(Collection files) {
+        Collection filenames = new java.util.ArrayList(files.size());
+        Iterator i = files.iterator();
+        while (i.hasNext()) {
+            filenames.add(((File)i.next()).getName());
+        }
+        return filenames;
+    }
+    
+    public void testListFilesByExtension() throws Exception {
+        String[] extensions = {"xml", "txt"};
+        
+        Collection files = FileUtils.listFiles(getLocalTestDirectory(), extensions, false);
+        assertEquals(1, files.size());
+        Collection filenames = filesToFilenames(files);
+        assertTrue(filenames.contains("dummy-build.xml"));
+        assertFalse(filenames.contains("README"));
+        assertFalse(filenames.contains("dummy-file.txt"));
+        
+        files = FileUtils.listFiles(getLocalTestDirectory(), extensions, true);
+        filenames = filesToFilenames(files);
+        assertEquals(4, filenames.size());
+        assertTrue(filenames.contains("dummy-file.txt"));
+        assertFalse(filenames.contains("dummy-index.html"));
+        
+        files = FileUtils.listFiles(getLocalTestDirectory(), null, false);
+        assertEquals(2, files.size());
+        filenames = filesToFilenames(files);
+        assertTrue(filenames.contains("dummy-build.xml"));
+        assertTrue(filenames.contains("README"));
+        assertFalse(filenames.contains("dummy-file.txt"));
+        
+    }
+
+    public void testListFiles() throws Exception {
+        Collection files;
+        Collection filenames;
+        IOFileFilter fileFilter;
+        IOFileFilter dirFilter;
+        
+        //First, find non-recursively
+        fileFilter = FileFilterUtils.trueFileFilter();
+        files = FileUtils.listFiles(getLocalTestDirectory(), fileFilter, null);
+        filenames = filesToFilenames(files);
+        assertTrue("'dummy-build.xml' is missing", filenames.contains("dummy-build.xml"));
+        assertFalse("'dummy-index.html' shouldn't be found", filenames.contains("dummy-index.html"));
+        assertFalse("'Entries' shouldn't be found", filenames.contains("Entries"));
+        
+        //Second, find recursively
+        fileFilter = FileFilterUtils.trueFileFilter();
+        dirFilter = FileFilterUtils.notFileFilter(FileFilterUtils.nameFileFilter("CVS"));
+        files = FileUtils.listFiles(getLocalTestDirectory(), fileFilter, dirFilter);
+        filenames = filesToFilenames(files);
+        assertTrue("'dummy-build.xml' is missing", filenames.contains("dummy-build.xml"));
+        assertTrue("'dummy-index.html' is missing", filenames.contains("dummy-index.html"));
+        assertFalse("'Entries' shouldn't be found", filenames.contains("Entries"));
+        
+        //Do the same as above but now with the filter coming from FileFilterUtils
+        fileFilter = FileFilterUtils.trueFileFilter();
+        dirFilter = FileFilterUtils.makeCVSAware(null);
+        files = FileUtils.listFiles(getLocalTestDirectory(), fileFilter, dirFilter);
+        filenames = filesToFilenames(files);
+        assertTrue("'dummy-build.xml' is missing", filenames.contains("dummy-build.xml"));
+        assertTrue("'dummy-index.html' is missing", filenames.contains("dummy-index.html"));
+        assertFalse("'Entries' shouldn't be found", filenames.contains("Entries"));
+
+        //Again with the CVS filter but now with a non-null parameter
+        fileFilter = FileFilterUtils.trueFileFilter();
+        dirFilter = FileFilterUtils.prefixFileFilter("sub");
+        dirFilter = FileFilterUtils.makeCVSAware(dirFilter);
+        files = FileUtils.listFiles(getLocalTestDirectory(), fileFilter, dirFilter);
+        filenames = filesToFilenames(files);
+        assertTrue("'dummy-build.xml' is missing", filenames.contains("dummy-build.xml"));
+        assertTrue("'dummy-index.html' is missing", filenames.contains("dummy-index.html"));
+        assertFalse("'Entries' shouldn't be found", filenames.contains("Entries"));
+
+        try {
+            FileUtils.listFiles(getLocalTestDirectory(), null, null);
+            fail("Expected error about null parameter");
+        } catch (Exception e) {
+            //fine
+        }
+    }
+
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsTestCase.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsTestCase.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/FileUtilsTestCase.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,453 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URL;
+
+import org.apache.commons.io.testtools.FileBasedTestCase;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+/**
+ * This is used to test FileUtils for correctness.
+ *
+ * @author Peter Donald
+ * @author Matthew Hawthorne
+ * @version $Id: FileUtilsTestCase.java,v 1.18 2004/04/23 22:47:39 jeremias Exp $
+ * @see FileUtils
+ */
+public class FileUtilsTestCase extends FileBasedTestCase {
+
+    // Test data
+
+    /**
+     * Size of test directory.
+     */
+    private static final int TEST_DIRECTORY_SIZE = 0;
+    
+    /** Delay in milliseconds to make sure test for "last modified date" are accurate */
+    private static final int LAST_MODIFIED_DELAY = 600;
+
+    private File testFile1;
+    private File testFile2;
+
+    private static int testFile1Size;
+    private static int testFile2Size;
+
+    public static void main(String[] args) {
+        TestRunner.run(suite());
+    }
+
+    public static Test suite() {
+        return new TestSuite(FileUtilsTestCase.class);
+    }
+
+    public FileUtilsTestCase(String name) throws IOException {
+        super(name);
+
+        testFile1 = new File(getTestDirectory(), "file1-test.txt");
+        testFile2 = new File(getTestDirectory(), "file1a-test.txt");
+
+        testFile1Size = (int)testFile1.length();
+        testFile2Size = (int)testFile2.length();
+    }
+
+    /** @see junit.framework.TestCase#setUp() */
+    protected void setUp() throws Exception {
+        getTestDirectory().mkdirs();
+        createFile(testFile1, testFile1Size);
+        createFile(testFile2, testFile2Size);
+        FileUtils.deleteDirectory(getTestDirectory());
+        getTestDirectory().mkdirs();
+        createFile(testFile1, testFile1Size);
+        createFile(testFile2, testFile2Size);
+    }
+
+    /** @see junit.framework.TestCase#tearDown() */
+    protected void tearDown() throws Exception {
+        FileUtils.deleteDirectory(getTestDirectory());
+    }
+
+    // byteCountToDisplaySize
+
+    public void testByteCountToDisplaySize() {
+        assertEquals(FileUtils.byteCountToDisplaySize(0), "0 bytes");
+        assertEquals(FileUtils.byteCountToDisplaySize(1024), "1 KB");
+        assertEquals(FileUtils.byteCountToDisplaySize(1024 * 1024), "1 MB");
+        assertEquals(
+            FileUtils.byteCountToDisplaySize(1024 * 1024 * 1024),
+            "1 GB");
+    }
+
+    // waitFor
+
+    public void testWaitFor() {
+        FileUtils.waitFor(new File(""), -1);
+
+        FileUtils.waitFor(new File(""), 2);
+    }
+
+    // toURL
+
+    public void testToURLs() throws Exception {
+        File[] files = new File[] { new File("file1"), new File("file2")};
+
+        URL[] urls = FileUtils.toURLs(files);
+
+        // Path separator causes equality tests to fail
+        //assertEquals(urls[0].getFile(), File.separator + files[0].getAbsolutePath());
+        //assertEquals(urls[1].getFile(), File.separator + files[1].getAbsolutePath());
+
+    }
+
+    // contentEquals
+
+    public void testContentEquals() throws Exception {
+        // Non-existent files
+        File file = new File(getTestDirectory(), getName());
+        assertTrue(FileUtils.contentEquals(file, file));
+
+        // Directories
+        try {
+            FileUtils.contentEquals(getTestDirectory(), getTestDirectory());
+            fail("Comparing directories should fail with an IOException");
+        } catch (IOException ioe) {
+            //expected
+        }
+
+        // Different files
+        File objFile1 =
+            new File(getTestDirectory(), getName() + ".object");
+        objFile1.deleteOnExit();
+        FileUtils.copyURLToFile(
+            getClass().getResource("/java/lang/Object.class"),
+            objFile1);
+
+        File objFile2 =
+            new File(getTestDirectory(), getName() + ".collection");
+        objFile2.deleteOnExit();
+        FileUtils.copyURLToFile(
+            getClass().getResource("/java/util/Collection.class"),
+            objFile2);
+
+        assertTrue(
+            "Files should not be equal.",
+            !FileUtils.contentEquals(objFile1, objFile2));
+
+        // Equal files
+        file.createNewFile();
+        assertTrue(FileUtils.contentEquals(file, file));
+    }
+
+    // copyURLToFile
+
+    public void testCopyURLToFile() throws Exception {
+        // Creates file
+        File file = new File(getTestDirectory(), getName());
+        file.deleteOnExit();
+
+        // Loads resource
+        String resourceName = "/java/lang/Object.class";
+        FileUtils.copyURLToFile(getClass().getResource(resourceName), file);
+
+        // Tests that resuorce was copied correctly
+        FileInputStream fis = new FileInputStream(file);
+        try {
+            assertTrue(
+                "Content is not equal.",
+                IOUtils.contentEquals(
+                    getClass().getResourceAsStream(resourceName),
+                    fis));
+        } finally {
+            fis.close();
+        }
+        //TODO Maybe test copy to itself like for copyFile()
+    }
+
+    // forceMkdir
+
+    public void testForceMkdir() throws Exception {
+        // Tests with existing directory
+        FileUtils.forceMkdir(getTestDirectory());
+
+        // Creates test file
+        File testFile = new File(getTestDirectory(), getName());
+        testFile.deleteOnExit();
+        testFile.createNewFile();
+        assertTrue("Test file does not exist.", testFile.exists());
+
+        // Tests with existing file
+        try {
+            FileUtils.forceMkdir(testFile);
+            fail("Exception expected.");
+        } catch (IOException ex) {}
+
+        testFile.delete();
+
+        // Tests with non-existent directory
+        FileUtils.forceMkdir(testFile);
+        assertTrue("Directory was not created.", testFile.exists());
+    }
+
+    // sizeOfDirectory
+
+    public void testSizeOfDirectory() throws Exception {
+        File file = new File(getTestDirectory(), getName());
+
+        // Non-existent file
+        try {
+            FileUtils.sizeOfDirectory(file);
+            fail("Exception expected.");
+        } catch (IllegalArgumentException ex) {}
+
+        // Creates file
+        file.createNewFile();
+        file.deleteOnExit();
+
+        // Existing file
+        try {
+            FileUtils.sizeOfDirectory(file);
+            fail("Exception expected.");
+        } catch (IllegalArgumentException ex) {}
+
+        // Existing directory
+        file.delete();
+        file.mkdir();
+
+        assertEquals(
+            "Unexpected directory size",
+            TEST_DIRECTORY_SIZE,
+            FileUtils.sizeOfDirectory(file));
+    }
+
+    // isFileNewer
+
+    // TODO Finish test
+    public void XtestIsFileNewer() {}
+
+    // TODO Remove after debugging
+    private void log(Object obj) {
+        System.out.println(
+            FileUtilsTestCase.class +" " + getName() + " " + obj);
+    }
+
+    // copyFile
+
+    public void testCopyFile1() throws Exception {
+        File destination = new File(getTestDirectory(), "copy1.txt");
+        
+        //Thread.sleep(LAST_MODIFIED_DELAY);
+        //This is to slow things down so we can catch if 
+        //the lastModified date is not ok
+        
+        FileUtils.copyFile(testFile1, destination);
+        assertTrue("Check Exist", destination.exists());
+        assertTrue("Check Full copy", destination.length() == testFile1Size);
+        /* disabled: Thread.sleep doesn't work reliantly for this case
+        assertTrue("Check last modified date preserved", 
+            testFile1.lastModified() == destination.lastModified());*/  
+    }
+
+    public void testCopyFile2() throws Exception {
+        File destination = new File(getTestDirectory(), "copy2.txt");
+        
+        Thread.sleep(LAST_MODIFIED_DELAY);
+        //This is to slow things down so we can catch if 
+        //the lastModified date is not ok
+        
+        FileUtils.copyFile(testFile1, destination);
+        assertTrue("Check Exist", destination.exists());
+        assertTrue("Check Full copy", destination.length() == testFile2Size);
+        assertTrue("Check last modified date preserved", 
+            testFile1.lastModified() == destination.lastModified());    
+    }
+    
+    public void testCopyToSelf() throws Exception {
+        File destination = new File(getTestDirectory(), "copy3.txt");
+        //Prepare a test file
+        FileUtils.copyFile(testFile1, destination);
+        
+        try {
+            FileUtils.copyFile(destination, destination);
+            fail("file copy to self should not be possible");
+        } catch (IOException ioe) {
+            //we want the exception, copy to self should be illegal
+        }
+    }
+
+    public void testCopyFile2WithoutFileDatePreservation() throws Exception {
+        File destination = new File(getTestDirectory(), "copy2.txt");
+        
+        //Thread.sleep(LAST_MODIFIED_DELAY);
+        //This is to slow things down so we can catch if 
+        //the lastModified date is not ok
+        
+        FileUtils.copyFile(testFile1, destination, false);
+        assertTrue("Check Exist", destination.exists());
+        assertTrue("Check Full copy", destination.length() == testFile2Size);
+        /* disabled: Thread.sleep doesn't work reliantly for this case
+        assertTrue("Check last modified date modified", 
+            testFile1.lastModified() != destination.lastModified());*/    
+    }
+
+    // forceDelete
+
+    public void testForceDeleteAFile1() throws Exception {
+        File destination = new File(getTestDirectory(), "copy1.txt");
+        destination.createNewFile();
+        assertTrue("Copy1.txt doesn't exist to delete", destination.exists());
+        FileUtils.forceDelete(destination);
+        assertTrue("Check No Exist", !destination.exists());
+    }
+
+    public void testForceDeleteAFile2() throws Exception {
+        File destination = new File(getTestDirectory(), "copy2.txt");
+        destination.createNewFile();
+        assertTrue("Copy2.txt doesn't exist to delete", destination.exists());
+        FileUtils.forceDelete(destination);
+        assertTrue("Check No Exist", !destination.exists());
+    }
+
+    // copyFileToDirectory
+
+    public void testCopyFile1ToDir() throws Exception {
+        File directory = new File(getTestDirectory(), "subdir");
+        if (!directory.exists())
+            directory.mkdirs();
+        File destination = new File(directory, testFile1.getName());
+        
+        //Thread.sleep(LAST_MODIFIED_DELAY);
+        //This is to slow things down so we can catch if 
+        //the lastModified date is not ok
+        
+        FileUtils.copyFileToDirectory(testFile1, directory);
+        assertTrue("Check Exist", destination.exists());
+        assertTrue("Check Full copy", destination.length() == testFile1Size);
+        /* disabled: Thread.sleep doesn't work reliantly for this case
+        assertTrue("Check last modified date preserved", 
+            testFile1.lastModified() == destination.lastModified());*/
+            
+        try {
+            FileUtils.copyFileToDirectory(destination, directory);
+            fail("Should not be able to copy a file into the same directory as itself");    
+        } catch (IOException ioe) {
+            //we want that, cannot copy to the same directory as the original file
+        }
+    }
+
+    public void testCopyFile2ToDir() throws Exception {
+        File directory = new File(getTestDirectory(), "subdir");
+        if (!directory.exists())
+            directory.mkdirs();
+        File destination = new File(directory, testFile1.getName());
+        
+        //Thread.sleep(LAST_MODIFIED_DELAY);
+        //This is to slow things down so we can catch if 
+        //the lastModified date is not ok
+        
+        FileUtils.copyFileToDirectory(testFile1, directory);
+        assertTrue("Check Exist", destination.exists());
+        assertTrue("Check Full copy", destination.length() == testFile2Size);
+        /* disabled: Thread.sleep doesn't work reliantly for this case
+        assertTrue("Check last modified date preserved", 
+            testFile1.lastModified() == destination.lastModified());*/    
+    }
+
+    // forceDelete
+
+    public void testForceDeleteDir() throws Exception {
+        FileUtils.forceDelete(getTestDirectory().getParentFile());
+        assertTrue(
+            "Check No Exist",
+            !getTestDirectory().getParentFile().exists());
+    }
+
+    private String replaceAll(
+        String text,
+        String lookFor,
+        String replaceWith) {
+        StringBuffer sb = new StringBuffer(text);
+        while (true) {
+            int idx = sb.toString().indexOf(lookFor);
+            if (idx < 0) {
+                break;
+            }
+            sb.replace(idx, idx + lookFor.length(), replaceWith);
+        }
+        return sb.toString();
+    }
+
+    /**
+     *  Test the FileUtils implementation.
+     */
+    // Used to exist as IOTestCase class
+    public void testFileUtils() throws Exception {
+        // Loads file from classpath
+        File file1 = new File(getTestDirectory(), "test.txt");
+        String filename = file1.getAbsolutePath();
+        
+        //Create test file on-the-fly (used to be in CVS)
+        OutputStream out = new java.io.FileOutputStream(file1);
+        try {
+            out.write("This is a test".getBytes("UTF-8"));
+        } finally {
+            out.close();
+        }
+        
+        File file2 = new File(getTestDirectory(), "test2.txt");
+        String filename2 = file2.getAbsolutePath();
+
+//1.0 These lines commented out as FilenameUtils not in 1.0
+//1.0        assertTrue(
+//1.0            "test.txt extension == \"txt\"",
+//1.0            FilenameUtils.getExtension(filename).equals("txt"));
+
+//1.0        assertTrue(
+//1.0            "Test file does not exist: " + filename,
+//1.0            FilenameUtils.fileExists(filename));
+
+//1.0        assertTrue(
+//1.0            "Second test file does not exist",
+//1.0            !FilenameUtils.fileExists(filename2));
+
+        FileUtils.writeStringToFile(file2, filename, "UTF-8");
+        assertTrue(file2.exists());
+        assertTrue(file2.length() > 0);
+
+        String file2contents = FileUtils.readFileToString(file2, "UTF-8");
+        assertTrue(
+            "Second file's contents correct",
+            filename.equals(file2contents));
+
+        assertTrue(file2.delete());
+        
+//1.0        FilenameUtils.fileDelete(filename2);
+//1.0        assertTrue(
+//1.0            "Second test file does not exist",
+//1.0            !FilenameUtils.fileExists(filename2));
+
+        String contents = FileUtils.readFileToString(new File(filename), "UTF-8");
+        assertTrue("FileUtils.fileRead()", contents.equals("This is a test"));
+
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/HexDumpTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/HexDumpTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/HexDumpTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,268 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io;
+
+import java.io.IOException;
+
+import org.apache.commons.io.output.ByteArrayOutputStream;
+
+import junit.framework.TestCase;
+
+
+/**
+ * @author Scott Sanders (sanders at apache dot org)
+ * @author Marc Johnson (mjohnson at apache dot org)
+ * @version $Revision: 1.5 $ $Date: 2004/02/23 05:02:25 $
+ */
+
+public class HexDumpTest extends TestCase {
+
+    /**
+     * Creates new HexDumpTest
+     *
+     * @param name
+     */
+
+    public HexDumpTest(String name) {
+        super(name);
+    }
+
+    private char toHex(int n) {
+        char[] hexChars =
+                {
+                    '0', '1', '2', '3', '4', '5', '6', '7',
+                    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
+                };
+
+        return hexChars[n % 16];
+    }
+
+    /**
+     * test dump method
+     *
+     * @exception IOException
+     */
+
+    public void testDump()
+            throws IOException {
+        byte[] testArray = new byte[256];
+
+        for (int j = 0; j < 256; j++) {
+            testArray[j] = (byte) j;
+        }
+        ByteArrayOutputStream stream = new ByteArrayOutputStream();
+
+        HexDump.dump(testArray, 0, stream, 0);
+        byte[] outputArray = new byte[16 * (73 + HexDump.EOL.length())];
+
+        for (int j = 0; j < 16; j++) {
+            int offset = (73 + HexDump.EOL.length()) * j;
+
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) toHex(j);
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) ' ';
+            for (int k = 0; k < 16; k++) {
+                outputArray[offset++] = (byte) toHex(j);
+                outputArray[offset++] = (byte) toHex(k);
+                outputArray[offset++] = (byte) ' ';
+            }
+            for (int k = 0; k < 16; k++) {
+                outputArray[offset++] = (byte) toAscii((j * 16) + k);
+            }
+            System.arraycopy(HexDump.EOL.getBytes(), 0, outputArray, offset,
+                    HexDump.EOL.getBytes().length);
+        }
+        byte[] actualOutput = stream.toByteArray();
+
+        assertEquals("array size mismatch", outputArray.length,
+                actualOutput.length);
+        for (int j = 0; j < outputArray.length; j++) {
+            assertEquals("array[ " + j + "] mismatch", outputArray[j],
+                    actualOutput[j]);
+        }
+
+        // verify proper behavior with non-zero offset
+        stream = new ByteArrayOutputStream();
+        HexDump.dump(testArray, 0x10000000, stream, 0);
+        outputArray = new byte[16 * (73 + HexDump.EOL.length())];
+        for (int j = 0; j < 16; j++) {
+            int offset = (73 + HexDump.EOL.length()) * j;
+
+            outputArray[offset++] = (byte) '1';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) toHex(j);
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) ' ';
+            for (int k = 0; k < 16; k++) {
+                outputArray[offset++] = (byte) toHex(j);
+                outputArray[offset++] = (byte) toHex(k);
+                outputArray[offset++] = (byte) ' ';
+            }
+            for (int k = 0; k < 16; k++) {
+                outputArray[offset++] = (byte) toAscii((j * 16) + k);
+            }
+            System.arraycopy(HexDump.EOL.getBytes(), 0, outputArray, offset,
+                    HexDump.EOL.getBytes().length);
+        }
+        actualOutput = stream.toByteArray();
+        assertEquals("array size mismatch", outputArray.length,
+                actualOutput.length);
+        for (int j = 0; j < outputArray.length; j++) {
+            assertEquals("array[ " + j + "] mismatch", outputArray[j],
+                    actualOutput[j]);
+        }
+
+        // verify proper behavior with negative offset
+        stream = new ByteArrayOutputStream();
+        HexDump.dump(testArray, 0xFF000000, stream, 0);
+        outputArray = new byte[16 * (73 + HexDump.EOL.length())];
+        for (int j = 0; j < 16; j++) {
+            int offset = (73 + HexDump.EOL.length()) * j;
+
+            outputArray[offset++] = (byte) 'F';
+            outputArray[offset++] = (byte) 'F';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) toHex(j);
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) ' ';
+            for (int k = 0; k < 16; k++) {
+                outputArray[offset++] = (byte) toHex(j);
+                outputArray[offset++] = (byte) toHex(k);
+                outputArray[offset++] = (byte) ' ';
+            }
+            for (int k = 0; k < 16; k++) {
+                outputArray[offset++] = (byte) toAscii((j * 16) + k);
+            }
+            System.arraycopy(HexDump.EOL.getBytes(), 0, outputArray, offset,
+                    HexDump.EOL.getBytes().length);
+        }
+        actualOutput = stream.toByteArray();
+        assertEquals("array size mismatch", outputArray.length,
+                actualOutput.length);
+        for (int j = 0; j < outputArray.length; j++) {
+            assertEquals("array[ " + j + "] mismatch", outputArray[j],
+                    actualOutput[j]);
+        }
+
+        // verify proper behavior with non-zero index
+        stream = new ByteArrayOutputStream();
+        HexDump.dump(testArray, 0x10000000, stream, 0x81);
+        outputArray = new byte[(8 * (73 + HexDump.EOL.length())) - 1];
+        for (int j = 0; j < 8; j++) {
+            int offset = (73 + HexDump.EOL.length()) * j;
+
+            outputArray[offset++] = (byte) '1';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) '0';
+            outputArray[offset++] = (byte) toHex(j + 8);
+            outputArray[offset++] = (byte) '1';
+            outputArray[offset++] = (byte) ' ';
+            for (int k = 0; k < 16; k++) {
+                int index = 0x81 + (j * 16) + k;
+
+                if (index < 0x100) {
+                    outputArray[offset++] = (byte) toHex(index / 16);
+                    outputArray[offset++] = (byte) toHex(index);
+                } else {
+                    outputArray[offset++] = (byte) ' ';
+                    outputArray[offset++] = (byte) ' ';
+                }
+                outputArray[offset++] = (byte) ' ';
+            }
+            for (int k = 0; k < 16; k++) {
+                int index = 0x81 + (j * 16) + k;
+
+                if (index < 0x100) {
+                    outputArray[offset++] = (byte) toAscii(index);
+                }
+            }
+            System.arraycopy(HexDump.EOL.getBytes(), 0, outputArray, offset,
+                    HexDump.EOL.getBytes().length);
+        }
+        actualOutput = stream.toByteArray();
+        assertEquals("array size mismatch", outputArray.length,
+                actualOutput.length);
+        for (int j = 0; j < outputArray.length; j++) {
+            assertEquals("array[ " + j + "] mismatch", outputArray[j],
+                    actualOutput[j]);
+        }
+
+        // verify proper behavior with negative index
+        try {
+            HexDump.dump(testArray, 0x10000000, new ByteArrayOutputStream(),
+                    -1);
+            fail("should have caught ArrayIndexOutOfBoundsException on negative index");
+        } catch (ArrayIndexOutOfBoundsException ignored_exception) {
+
+            // as expected
+        }
+
+        // verify proper behavior with index that is too large
+        try {
+            HexDump.dump(testArray, 0x10000000, new ByteArrayOutputStream(),
+                    testArray.length);
+            fail("should have caught ArrayIndexOutOfBoundsException on large index");
+        } catch (ArrayIndexOutOfBoundsException ignored_exception) {
+
+            // as expected
+        }
+
+        // verify proper behavior with null stream
+        try {
+            HexDump.dump(testArray, 0x10000000, null, 0);
+            fail("should have caught IllegalArgumentException on negative index");
+        } catch (IllegalArgumentException ignored_exception) {
+
+            // as expected
+        }
+    }
+
+    private char toAscii(int c) {
+        char rval = '.';
+
+        if ((c >= 32) && (c <= 126)) {
+            rval = (char) c;
+        }
+        return rval;
+    }
+
+    /**
+     * main method to run the unit tests
+     *
+     * @param ignored_args
+     */
+
+    public static void main(String[] ignored_args) {
+        System.out.println("Testing io.HexDump functionality");
+        junit.textui.TestRunner.run(HexDumpTest.class);
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/IOTestSuite.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/IOTestSuite.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/IOTestSuite.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,49 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io;
+
+import org.apache.commons.io.filefilter.FileFilterTestCase;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+/**
+ * A basic test suite that tests all the IO package.
+ * 
+ * @author Matthew Hawthorne
+ * @see org.apache.commons.io
+ */
+public class IOTestSuite
+{
+    
+    public static void main(String[] args) {
+        TestRunner.run(suite());
+    }
+    
+    public static Test suite()
+    {
+        TestSuite suite = new TestSuite( "IO Utilities" );
+        suite.addTest( new TestSuite( CopyUtilsTest.class ) );
+        suite.addTest( new TestSuite( IOUtilsTestCase.class ) );
+        suite.addTest( new TestSuite( FileUtilsTestCase.class ) );
+        suite.addTest( new TestSuite( FileFilterTestCase.class ) );
+        suite.addTest( new TestSuite( DemuxTestCase.class ) );
+        suite.addTest( new TestSuite( HexDumpTest.class ) );
+        return suite;
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/IOUtilsTestCase.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/IOUtilsTestCase.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/IOUtilsTestCase.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,283 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.commons.io.testtools.*;
+
+// Note: jdk1.2 dependency
+
+/**
+ * This is used to test IOUtils for correctness. The following checks are performed:
+ * <ul>
+ *   <li>The return must not be null, must be the same type and equals() to the method's second arg</li>
+ *   <li>All bytes must have been read from the source (available() == 0)</li>
+ *   <li>The source and destination content must be identical (byte-wise comparison check)</li>
+ *   <li>The output stream must not have been closed (a byte/char is written to test this, and
+ *   subsequent size checked)</li>
+ * </ul>
+ * Due to interdependencies in IOUtils and IOUtilsTestlet, one bug may cause
+ * multiple tests to fail.
+ *
+ * @author <a href="mailto:jefft at apache.org">Jeff Turner</a>
+ */
+public class IOUtilsTestCase extends FileBasedTestCase {
+    /*
+     * Note: this is not particularly beautiful code. A better way to check for
+     * flush and close status would be to implement "trojan horse" wrapper
+     * implementations of the various stream classes, which set a flag when
+     * relevant methods are called. (JT)
+     */
+
+    private static final int FILE_SIZE = 1024 * 4 + 1;
+
+    private File m_testFile;
+
+    public void setUp()
+    {
+        try
+        {
+            getTestDirectory().mkdirs();
+            m_testFile = new File( getTestDirectory(), "file2-test.txt" );
+
+            createFile( m_testFile, FILE_SIZE );
+        }
+        catch( IOException ioe )
+        {
+            throw new RuntimeException( "Can't run this test because "
+                    + "environment could not be built: " + ioe.getMessage());
+        }
+    }
+
+    public void tearDown()
+    {
+        try
+        {
+            FileUtils.deleteDirectory( getTestDirectory() );
+        }
+        catch( IOException ioe )
+        {
+            // Ignore, because by this time, it is too late.
+        }
+    }
+
+    public IOUtilsTestCase( String name )
+    {
+        super( name );
+    }
+
+    /** Assert that the contents of two byte arrays are the same. */
+    private void assertEqualContent( byte[] b0, byte[] b1 )
+        throws IOException
+    {
+        assertTrue( "Content not equal according to java.util.Arrays#equals()", Arrays.equals( b0, b1 ) );
+    }
+
+    public void testInputStreamToString()
+        throws Exception
+    {
+        FileInputStream fin = new FileInputStream( m_testFile );
+        try {
+            String out = IOUtils.toString( fin );
+            assertNotNull( out );
+            assertTrue( "Not all bytes were read", fin.available() == 0 );
+            assertTrue( "Wrong output size: out.length()=" + out.length() +
+                        "!=" + FILE_SIZE, out.length() == FILE_SIZE );
+        } finally {
+            fin.close();
+        }
+    }
+
+    public void testReaderToString()
+        throws Exception
+    {
+        FileReader fin = new FileReader( m_testFile );
+        try {
+            String out = IOUtils.toString( fin );
+            assertNotNull( out );
+            assertTrue( "Wrong output size: out.length()=" +
+                        out.length() + "!=" + FILE_SIZE,
+                        out.length() == FILE_SIZE );
+        } finally {
+            fin.close();
+        }
+    }
+
+    public void testStringToOutputStream()
+        throws Exception
+    {
+        File destination = newFile( "copy5.txt" );
+        FileReader fin = new FileReader( m_testFile );
+        String str;
+        try {
+            // Create our String. Rely on testReaderToString() to make sure this is valid.
+            str = IOUtils.toString( fin );
+        } finally {
+            fin.close();
+        }
+        
+        FileOutputStream fout = new FileOutputStream( destination );
+        try {
+            CopyUtils.copy( str, fout );
+            //Note: this method *does* flush. It is equivalent to:
+            //  OutputStreamWriter _out = new OutputStreamWriter(fout);
+            //  CopyUtils.copy( str, _out, 4096 ); // copy( Reader, Writer, int );
+            //  _out.flush();
+            //  out = fout;
+            // note: we don't flush here; this IOUtils method does it for us
+
+            checkFile( destination, m_testFile );
+            checkWrite( fout );
+        } finally {
+            fout.close();
+        }
+        deleteFile( destination );
+    }
+
+    public void testStringToWriter()
+        throws Exception
+    {
+        File destination = newFile( "copy6.txt" );
+        FileReader fin = new FileReader( m_testFile );
+        String str;
+        try {
+            // Create our String. Rely on testReaderToString() to make sure this is valid.
+            str = IOUtils.toString( fin );
+        } finally {
+            fin.close();
+        }
+        
+        FileWriter fout = new FileWriter( destination );
+        try {
+            CopyUtils.copy( str, fout );
+            fout.flush();
+
+            checkFile( destination, m_testFile );
+            checkWrite( fout );
+        } finally {
+            fout.close();
+        }
+        deleteFile( destination );
+    }
+
+    public void testInputStreamToByteArray()
+        throws Exception
+    {
+        FileInputStream fin = new FileInputStream( m_testFile );
+        try {
+            byte[] out = IOUtils.toByteArray( fin );
+            assertNotNull( out );
+            assertTrue( "Not all bytes were read", fin.available() == 0 );
+            assertTrue( "Wrong output size: out.length=" + out.length +
+                        "!=" + FILE_SIZE, out.length == FILE_SIZE );
+            assertEqualContent( out, m_testFile );
+        } finally {
+            fin.close();
+        }
+    }
+
+    public void testStringToByteArray()
+        throws Exception
+    {
+        FileReader fin = new FileReader( m_testFile );
+        try {
+            // Create our String. Rely on testReaderToString() to make sure this is valid.
+            String str = IOUtils.toString( fin );
+
+            byte[] out = IOUtils.toByteArray( str );
+            assertEqualContent( str.getBytes(), out );
+        } finally {
+            fin.close();
+        }
+    }
+
+    public void testByteArrayToWriter()
+        throws Exception
+    {
+        File destination = newFile( "copy7.txt" );
+        FileInputStream fin = new FileInputStream( m_testFile );
+        byte[] in;
+        try {
+            // Create our byte[]. Rely on testInputStreamToByteArray() to make sure this is valid.
+            in = IOUtils.toByteArray( fin );
+        } finally {
+            fin.close();
+        }
+
+        FileWriter fout = new FileWriter( destination );
+        try {
+            CopyUtils.copy( in, fout );
+            fout.flush();
+            checkFile( destination, m_testFile );
+            checkWrite( fout );
+        } finally {
+            fout.close();
+        }
+        deleteFile( destination );
+    }
+
+    public void testByteArrayToString()
+        throws Exception
+    {
+        FileInputStream fin = new FileInputStream( m_testFile );
+        try {
+            byte[] in = IOUtils.toByteArray( fin );
+            // Create our byte[]. Rely on testInputStreamToByteArray() to make sure this is valid.
+            String str = IOUtils.toString( in );
+            assertEqualContent( in, str.getBytes() );
+        } finally {
+            fin.close();
+        }
+    }
+
+    public void testByteArrayToOutputStream()
+        throws Exception
+    {
+        File destination = newFile( "copy8.txt" );
+        FileInputStream fin = new FileInputStream( m_testFile );
+        byte[] in;
+        try {
+            // Create our byte[]. Rely on testInputStreamToByteArray() to make sure this is valid.
+            in = IOUtils.toByteArray( fin );
+        } finally {
+            fin.close();
+        }
+
+        FileOutputStream fout = new FileOutputStream( destination );
+        try {
+            CopyUtils.copy( in, fout );
+
+            fout.flush();
+
+            checkFile( destination, m_testFile );
+            checkWrite( fout );
+        } finally {
+            fout.close();
+        }
+        deleteFile( destination );
+    }
+
+
+}
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/filefilter/FileFilterTestCase.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/filefilter/FileFilterTestCase.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/filefilter/FileFilterTestCase.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,200 @@
+/*
+ * Copyright 2002-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.filefilter;
+
+import java.io.File;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+/**
+ * Used to test an unknown FileFilter
+ */
+public class FileFilterTestCase extends TestCase {
+
+    public FileFilterTestCase(String name) {
+        super(name);
+    }
+    
+    public static void main(String[] args) {
+        TestRunner.run(suite());
+    }
+    
+    public static TestSuite suite() {
+        return new TestSuite(FileFilterTestCase.class);
+    }
+
+    public void setUp() {
+    }
+
+    public void tearDown() {
+    }
+
+    public void assertFiltering(IOFileFilter filter, File file, boolean expected) throws Exception {
+        // Note. This only tests the (File, String) version if the parent of 
+        //       the File passed in is not null
+        assertTrue(
+            "Filter(File) " + filter.getClass().getName() + " not " + expected + " for " + file,
+            (filter.accept(file) == expected));
+
+        if (file != null && file.getParentFile() != null) {
+            assertTrue(
+                "Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for " + file,
+                (filter.accept(file.getParentFile(), file.getName()) == expected));
+        } else if (file == null) {
+            assertTrue(
+                "Filter(File, String) " + filter.getClass().getName() + " not " + expected + " for null",
+                filter.accept(file) == expected);
+        }
+    }
+
+    public void testSuffix() throws Exception {
+        IOFileFilter filter = new SuffixFileFilter(new String[] { "tes", "est" });
+        assertFiltering(filter, new File("fred.tes"), true);
+        assertFiltering(filter, new File("fred.est"), true);
+        assertFiltering(filter, new File("fred.EST"), false); //case-sensitive
+        assertFiltering(filter, new File("fred.exe"), false);
+        assertFiltering(filter, new File("fred"), false);
+        assertFiltering(filter, new File(".tes"), true);
+        assertFiltering(filter, new File("fred.test"), true);
+        
+        filter = new SuffixFileFilter("est");
+        assertFiltering(filter, new File("test"), true);
+        assertFiltering(filter, new File("fred"), false);
+        
+        try {
+            new SuffixFileFilter((String) null);
+            fail();
+        } catch (IllegalArgumentException ex) {
+        }
+    }
+
+    public void testDirectory() throws Exception {
+        IOFileFilter filter = new DirectoryFileFilter();
+
+        assertFiltering(filter, new File("src/"), true);
+        assertFiltering(filter, new File("src/java/"), true);
+
+        assertFiltering(filter, new File("project.xml"), false);
+
+        assertFiltering(filter, new File("imaginary"), false);
+        assertFiltering(filter, new File("imaginary/"), false);
+
+        assertFiltering(filter, new File("STATUS.html"), false);
+    }
+
+    public void testPrefix() throws Exception {
+        IOFileFilter filter = new PrefixFileFilter(new String[] { "foo", "bar" });
+        assertFiltering(filter, new File("foo.test"), true);
+        assertFiltering(filter, new File("FOO.test"), false);  //case-sensitive
+        assertFiltering(filter, new File("foo"), true);
+        assertFiltering(filter, new File("bar"), true);
+        assertFiltering(filter, new File("food/"), true);
+        assertFiltering(filter, new File("barred\\"), true);
+        assertFiltering(filter, new File("test"), false);
+        assertFiltering(filter, new File("fo_o.test"), false);
+        assertFiltering(filter, new File("abar.exe"), false);
+        
+        filter = new PrefixFileFilter("tes");
+        assertFiltering(filter, new File("test"), true);
+        assertFiltering(filter, new File("fred"), false);
+        
+        try {
+            new PrefixFileFilter((String) null);
+            fail();
+        } catch (IllegalArgumentException ex) {
+        }
+    }
+    
+    public void testNameFilter() throws Exception {
+        IOFileFilter filter = new NameFileFilter(new String[] { "foo", "bar" });
+        assertFiltering(filter, new File("foo"), true);
+        assertFiltering(filter, new File("bar"), true);
+        assertFiltering(filter, new File("fred"), false);
+
+        // repeat for a List
+        java.util.ArrayList list = new java.util.ArrayList();
+        list.add("foo");
+        list.add("bar");
+        filter = new NameFileFilter(list);
+        assertFiltering(filter, new File("foo"), true);
+        assertFiltering(filter, new File("bar"), true);
+        assertFiltering(filter, new File("fred"), false);
+
+        filter = new NameFileFilter("foo");
+        assertFiltering(filter, new File("foo"), true);
+        assertFiltering(filter, new File("FOO"), false); //case-sensitive
+        assertFiltering(filter, new File("barfoo"), false);
+        assertFiltering(filter, new File("foobar"), false);
+        assertFiltering(filter, new File("fred"), false);
+    }
+
+    public void testTrue() throws Exception {
+        IOFileFilter filter = FileFilterUtils.trueFileFilter();
+        assertFiltering(filter, new File("foo.test"), true);
+        assertFiltering(filter, new File("foo"), true);
+        assertFiltering(filter, null, true);
+    }
+
+    public void testFalse() throws Exception {
+        IOFileFilter filter = FileFilterUtils.falseFileFilter();
+        assertFiltering(filter, new File("foo.test"), false);
+        assertFiltering(filter, new File("foo"), false);
+        assertFiltering(filter, null, false);
+    }
+
+    public void testNot() throws Exception {
+        IOFileFilter filter = FileFilterUtils.notFileFilter(FileFilterUtils.trueFileFilter());
+        assertFiltering(filter, new File("foo.test"), false);
+        assertFiltering(filter, new File("foo"), false);
+        assertFiltering(filter, null, false);
+        try {
+            new NotFileFilter(null);
+            fail();
+        } catch (IllegalArgumentException ex) {
+        }
+    }
+
+    public void testAnd() throws Exception {
+        IOFileFilter trueFilter = TrueFileFilter.INSTANCE;
+        IOFileFilter falseFilter = FalseFileFilter.INSTANCE;
+        assertFiltering(new AndFileFilter(trueFilter, trueFilter), new File("foo.test"), true);
+        assertFiltering(new AndFileFilter(trueFilter, falseFilter), new File("foo.test"), false);
+        assertFiltering(new AndFileFilter(falseFilter, trueFilter), new File("foo.test"), false);
+        assertFiltering(new AndFileFilter(falseFilter, falseFilter), new File("foo.test"), false);
+        try {
+            new AndFileFilter(falseFilter, null);
+            fail();
+        } catch (IllegalArgumentException ex) {
+        }
+    }
+
+    public void testOr() throws Exception {
+        IOFileFilter trueFilter = TrueFileFilter.INSTANCE;
+        IOFileFilter falseFilter = FalseFileFilter.INSTANCE;
+        assertFiltering(new OrFileFilter(trueFilter, trueFilter), new File("foo.test"), true);
+        assertFiltering(new OrFileFilter(trueFilter, falseFilter), new File("foo.test"), true);
+        assertFiltering(new OrFileFilter(falseFilter, trueFilter), new File("foo.test"), true);
+        assertFiltering(new OrFileFilter(falseFilter, falseFilter), new File("foo.test"), false);
+        try {
+            new OrFileFilter(falseFilter, null);
+            fail();
+        } catch (IllegalArgumentException ex) {
+        }
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input/CountingInputStreamTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input/CountingInputStreamTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input/CountingInputStreamTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2003,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.input;
+
+import java.io.ByteArrayInputStream;
+
+import junit.framework.TestCase;
+
+/**
+ * Tests the CountingInputStream.
+ *
+ * @author <a href="mailto:bayard at apache.org">Henri Yandell</a>
+ */
+public class CountingInputStreamTest extends TestCase {
+
+    public CountingInputStreamTest(String name) {
+        super(name);
+    }
+
+    public void testCounting() throws Exception {
+        String text = "A piece of text";
+        byte[] bytes = text.getBytes();
+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
+        CountingInputStream cis = new CountingInputStream(bais);
+
+        // have to declare this larger as we're going to read 
+        // off the end of the stream and input stream seems 
+        // to do bounds checking
+        byte[] result = new byte[21];
+
+        byte[] ba = new byte[5];
+        int found = cis.read(ba);
+        System.arraycopy(ba, 0, result, 0, 5);
+        assertEquals( found, cis.getCount() );
+
+        int value = cis.read();
+        found++; 
+        result[5] = (byte)value;
+        assertEquals( found, cis.getCount() );
+
+        found += cis.read(result, 6, 5);
+        assertEquals( found, cis.getCount() );
+
+        found += cis.read(result, 11, 10); // off the end
+        assertEquals( found, cis.getCount() );
+
+        // trim to get rid of the 6 empty values
+        String textResult = new String(result).trim();
+        assertEquals(textResult, text);
+    }
+}
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input/SwappedDataInputStreamTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input/SwappedDataInputStreamTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/input/SwappedDataInputStreamTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,132 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.io.input;
+
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+
+/**
+ * Test for the SwappedDataInputStream. This also 
+ * effectively tests the underlying EndianUtils Stream methods.
+ *
+ * @author Henri Yandell (bayard at apache dot org)
+ * @version $Revision: 1.9 $ $Date: 2004/02/29 22:03:45 $
+ */
+
+public class SwappedDataInputStreamTest extends TestCase {
+
+    private SwappedDataInputStream sdis;
+    private byte[] bytes;
+
+    public SwappedDataInputStreamTest(String name) {
+        super(name);
+    }
+
+    public void setUp() {
+        bytes = new byte[] {
+            0x01,
+            0x02,
+            0x03,
+            0x04,
+            0x05,
+            0x06,
+            0x07,
+            0x08
+        };
+        ByteArrayInputStream bais = new ByteArrayInputStream( bytes );
+        this.sdis = new SwappedDataInputStream( bais );
+    }
+
+    public void tearDown() {
+        this.sdis = null;
+    }
+
+    public void testReadBoolean() throws IOException {
+        assertEquals( false, this.sdis.readBoolean() );
+    }
+
+    public void testReadByte() throws IOException {
+        assertEquals( 0x01, this.sdis.readByte() );
+    }
+
+    public void testReadChar() throws IOException {
+        assertEquals( (char) 0x0201, this.sdis.readChar() );
+    }
+
+    public void testReadDouble() throws IOException {
+        assertEquals( Double.longBitsToDouble(0x0807060504030201L), this.sdis.readDouble(), 0 );
+    }
+
+    public void testReadFloat() throws IOException {
+        assertEquals( Float.intBitsToFloat(0x04030201), this.sdis.readFloat(), 0 );
+    }
+
+    public void testReadFully() throws IOException {
+        byte[] bytesIn = new byte[8];
+        this.sdis.readFully(bytesIn);
+        for( int i=0; i<8; i++) {
+            assertEquals( bytes[i], bytesIn[i] );
+        }
+    }
+
+    public void testReadInt() throws IOException {
+        assertEquals( (int) 0x04030201, this.sdis.readInt() );
+    }
+
+    public void testReadLine() throws IOException {
+        try {
+            String unexpected = this.sdis.readLine();
+            fail("readLine should be unsupported. ");
+        } catch(UnsupportedOperationException uoe) {
+        }
+    }
+
+    public void testReadLong() throws IOException {
+        assertEquals( 0x0807060504030201L, this.sdis.readLong() );
+    }
+
+    public void testReadShort() throws IOException {
+        assertEquals( (short) 0x0201, this.sdis.readShort() );
+    }
+
+    public void testReadUnsignedByte() throws IOException {
+        assertEquals( 0x01, this.sdis.readUnsignedByte() );
+    }
+
+    public void testReadUnsignedShort() throws IOException {
+        assertEquals( (short) 0x0201, this.sdis.readUnsignedShort() );
+    }
+
+    public void testReadUTF() throws IOException {
+        try {
+            String unexpected = this.sdis.readUTF();
+            fail("readUTF should be unsupported. ");
+        } catch(UnsupportedOperationException uoe) {
+        }
+    }
+
+    public void testSkipBytes() throws IOException {
+        this.sdis.skipBytes(4);
+        assertEquals( (int)0x08070605, this.sdis.readInt() );
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/ByteArrayOutputStreamTestCase.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/ByteArrayOutputStreamTestCase.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/ByteArrayOutputStreamTestCase.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2003,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.io.output;
+
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+/**
+ * Basic unit tests for the alternative ByteArrayOutputStream implementation.
+ *
+ * @author <a href="mailto:jeremias at apache.org">Jeremias Maerki</a>
+ */
+public class ByteArrayOutputStreamTestCase extends TestCase {
+
+    private static final byte[] DATA;
+    
+    static {
+        DATA = new byte[64];
+        for (byte i = 0; i < 64; i++) {
+            DATA[i] = i;
+        }
+    }
+
+    public ByteArrayOutputStreamTestCase(String name) {
+        super(name);
+    }
+
+    private int writeData(ByteArrayOutputStream baout, 
+                java.io.ByteArrayOutputStream ref,
+                int count) throws IOException {
+        if (count > DATA.length) {
+            throw new IllegalArgumentException("Requesting too many bytes");
+        }
+        if (count == 0) {
+            baout.write(100);
+            ref.write(100);
+            return 1;
+        } else {
+            baout.write(DATA, 0, count);
+            ref.write(DATA, 0, count);
+            return count;
+        }
+    }
+    
+    private int writeData(ByteArrayOutputStream baout, 
+                java.io.ByteArrayOutputStream ref, 
+                int[] instructions) throws IOException {
+        int written = 0;
+        for (int i = 0; i < instructions.length; i++) {
+            written += writeData(baout, ref, instructions[i]);
+        }
+        return written;
+    }
+
+    private static boolean byteCmp(byte[] src, byte[] cmp) {
+        for (int i = 0; i < cmp.length; i++) {
+            if (src[i] != cmp[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private void checkByteArrays(byte[] expected, byte[] actual) {
+        if (expected.length != actual.length) {
+            fail("Resulting byte arrays are not equally long");
+        }
+        if (!byteCmp(expected, actual)) {
+            fail("Resulting byte arrays are not equal");
+        }
+    }
+
+    private void checkStreams(
+            ByteArrayOutputStream actual,
+            java.io.ByteArrayOutputStream expected) {
+        assertEquals("Sizes are not equal", expected.size(), actual.size());
+        byte[] buf = actual.toByteArray();
+        byte[] refbuf = expected.toByteArray();
+        checkByteArrays(buf, refbuf);
+    }
+              
+    public void testStream() throws Exception {
+        int written;
+        
+        //The ByteArrayOutputStream is initialized with 32 bytes to match
+        //the original more closely for this test.
+        ByteArrayOutputStream baout = new ByteArrayOutputStream(32);
+        java.io.ByteArrayOutputStream ref = new java.io.ByteArrayOutputStream();
+        
+        //First three writes
+        written = writeData(baout, ref, new int[] {4, 10, 22});
+        checkStreams(baout, ref);
+
+        //Another two writes to see if there are any bad effects after toByteArray()
+        written = writeData(baout, ref, new int[] {20, 12});
+        checkStreams(baout, ref);
+
+        //Now reset the streams        
+        baout.reset();
+        ref.reset();
+        
+        //Test again to see if reset() had any bad effects
+        written = writeData(baout, ref, new int[] {5, 47, 33, 60, 1, 0, 8});
+        checkStreams(baout, ref);
+        
+        //Write the commons Byte[]OutputStream to a java.io.Byte[]OutputStream 
+        //and vice-versa to test the writeTo() method.
+        ByteArrayOutputStream baout1 = new ByteArrayOutputStream(32);
+        ref.writeTo(baout1);
+        java.io.ByteArrayOutputStream ref1 = new java.io.ByteArrayOutputStream();
+        baout.writeTo(ref1);
+        checkStreams(baout1, ref1);
+        
+        //Testing toString(String)
+        String baoutString = baout.toString("ASCII");
+        String refString = ref.toString("ASCII");
+        assertEquals("ASCII decoded String must be equal", refString, baoutString);
+    }
+}
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/CountingOutputStreamTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/CountingOutputStreamTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/CountingOutputStreamTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,74 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.io.output;
+
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+
+/**
+ * @author Henri Yandell (bayard at apache dot org)
+ * @version $Revision: 1.2 $ $Date: 2004/02/23 05:02:25 $
+ */
+
+public class CountingOutputStreamTest extends TestCase {
+
+    public CountingOutputStreamTest(String name) {
+        super(name);
+    }
+
+    public void testCounting() throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        CountingOutputStream cos = new CountingOutputStream(baos);
+
+        for(int i = 0; i < 20; i++) {
+            cos.write(i);
+        }
+        assertByteArrayEquals("CountingOutputStream.write(int)", baos.toByteArray(), 0, 20);
+        assertEquals("CountingOutputStream.getCount()", cos.getCount(), 20);
+
+        byte[] array = new byte[10];
+        for(int i = 20; i < 30; i++) {
+            array[i-20] = (byte)i;
+        }
+        cos.write(array);
+        assertByteArrayEquals("CountingOutputStream.write(byte[])", baos.toByteArray(), 0, 30);
+        assertEquals("CountingOutputStream.getCount()", cos.getCount(), 30);
+
+        for(int i = 25; i < 35; i++) {
+            array[i-25] = (byte)i;
+        }
+        cos.write(array, 5, 5);
+        assertByteArrayEquals("CountingOutputStream.write(byte[], int, int)", baos.toByteArray(), 0, 35);
+        assertEquals("CountingOutputStream.getCount()", cos.getCount(), 35);
+    }
+
+    private void assertByteArrayEquals(String msg, byte[] array, int start, int end) {
+        assertEquals(msg+": array size mismatch", end-start,
+                array.length );
+
+        for (int i = start; i < end; i++) {
+            assertEquals(msg+": array[ " + i + "] mismatch", array[i],
+                    i);
+        }
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/DeferredFileOutputStreamTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/DeferredFileOutputStreamTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/DeferredFileOutputStreamTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.io.output;
+
+import junit.framework.TestCase;
+//import org.apache.commons.fileupload.DeferredFileOutputStream;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * Unit tests for the <code>DeferredFileOutputStream</code> class.
+ *
+ * @author <a href="mailto:martinc at apache.org">Martin Cooper</a>
+ *
+ * @version $Id: DeferredFileOutputStreamTest.java,v 1.2 2004/02/23 05:02:25 bayard Exp $
+ */
+public class DeferredFileOutputStreamTest extends TestCase
+ {
+
+    /**
+     * The test data as a string (which is the simplest form).
+     */
+    private String testString = "0123456789";
+
+    /**
+     * The test data as a byte array, derived from the string.
+     */
+    private byte[] testBytes = testString.getBytes();
+
+    /**
+     * Standard JUnit test case constructor.
+     *
+     * @param name The name of the test case.
+     */
+    public DeferredFileOutputStreamTest(String name)
+    {
+        super(name);
+    }
+
+    /**
+     * Tests the case where the amount of data falls below the threshold, and
+     * is therefore confined to memory.
+     */
+    public void testBelowThreshold()
+    {
+        DeferredFileOutputStream dfos =
+                new DeferredFileOutputStream(testBytes.length + 42, null);
+        try
+        {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        }
+        catch (IOException e) {
+            fail("Unexpected IOException");
+        }
+        assertTrue(dfos.isInMemory());
+
+        byte[] resultBytes = dfos.getData();
+        assertTrue(resultBytes.length == testBytes.length);
+        assertTrue(Arrays.equals(resultBytes, testBytes));
+    }
+
+    /**
+     * Tests the case where the amount of data is exactly the same as the
+     * threshold. The behavior should be the same as that for the amount of
+     * data being below (i.e. not exceeding) the threshold.
+     */
+    public void testAtThreshold() {
+        DeferredFileOutputStream dfos =
+                new DeferredFileOutputStream(testBytes.length, null);
+        try
+        {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        }
+        catch (IOException e) {
+            fail("Unexpected IOException");
+        }
+        assertTrue(dfos.isInMemory());
+
+        byte[] resultBytes = dfos.getData();
+        assertTrue(resultBytes.length == testBytes.length);
+        assertTrue(Arrays.equals(resultBytes, testBytes));
+    }
+
+    /**
+     * Tests the case where the amount of data exceeds the threshold, and is
+     * therefore written to disk. The actual data written to disk is verified,
+     * as is the file itself.
+     */
+    public void testAboveThreshold() {
+        File testFile = new File("testAboveThreshold.dat");
+
+        // Ensure that the test starts from a clean base.
+        testFile.delete();
+
+        DeferredFileOutputStream dfos =
+                new DeferredFileOutputStream(testBytes.length - 5, testFile);
+        try
+        {
+            dfos.write(testBytes, 0, testBytes.length);
+            dfos.close();
+        }
+        catch (IOException e) {
+            fail("Unexpected IOException");
+        }
+        assertFalse(dfos.isInMemory());
+        assertNull(dfos.getData());
+
+        verifyResultFile(testFile);
+
+        // Ensure that the test starts from a clean base.
+        testFile.delete();
+    }
+
+    /**
+     * Tests the case where there are multiple writes beyond the threshold, to
+     * ensure that the <code>thresholdReached()</code> method is only called
+     * once, as the threshold is crossed for the first time.
+     */
+    public void testThresholdReached() {
+        File testFile = new File("testThresholdReached.dat");
+
+        // Ensure that the test starts from a clean base.
+        testFile.delete();
+
+        DeferredFileOutputStream dfos =
+                new DeferredFileOutputStream(testBytes.length / 2, testFile);
+        int chunkSize = testBytes.length / 3;
+
+        try
+        {
+            dfos.write(testBytes, 0, chunkSize);
+            dfos.write(testBytes, chunkSize, chunkSize);
+            dfos.write(testBytes, chunkSize * 2,
+                    testBytes.length - chunkSize * 2);
+            dfos.close();
+        }
+        catch (IOException e) {
+            fail("Unexpected IOException");
+        }
+        assertFalse(dfos.isInMemory());
+        assertNull(dfos.getData());
+
+        verifyResultFile(testFile);
+
+        // Ensure that the test starts from a clean base.
+        testFile.delete();
+    }
+
+    /**
+     * Verifies that the specified file contains the same data as the original
+     * test data.
+     *
+     * @param testFile The file containing the test output.
+     */
+    private void verifyResultFile(File testFile) {
+        try
+        {
+            FileInputStream fis = new FileInputStream(testFile);
+            assertTrue(fis.available() == testBytes.length);
+
+            byte[] resultBytes = new byte[testBytes.length];
+            assertTrue(fis.read(resultBytes) == testBytes.length);
+
+            assertTrue(Arrays.equals(resultBytes, testBytes));
+            assertTrue(fis.read(resultBytes) == -1);
+
+            try
+            {
+                fis.close();
+            }
+            catch (IOException e) {
+                // Ignore an exception on close
+            }
+        }
+        catch (FileNotFoundException e) {
+            fail("Unexpected FileNotFoundException");
+        }
+        catch (IOException e) {
+            fail("Unexpected IOException");
+        }
+    }
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/LockableFileWriterTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/LockableFileWriterTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/LockableFileWriterTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.io.output;
+
+
+import java.io.IOException;
+import java.io.File;
+
+import junit.framework.TestCase;
+
+/**
+ * Tests that files really lock, although no writing is done as 
+ * the locking is tested only on construction. 
+ *
+ * @author Henri Yandell (bayard at apache dot org)
+ * @version $Revision: 1.2 $ $Date: 2004/02/29 21:07:14 $
+ */
+
+public class LockableFileWriterTest extends TestCase {
+
+    private File file;
+
+    public LockableFileWriterTest(String name) {
+        super(name);
+    }
+
+    public void setUp() {
+        this.file = new File("testlockfile");
+    }
+
+    public void tearDown() {
+        this.file.delete();
+    }
+
+    public void testFileLocked() throws IOException {
+        LockableFileWriter lfw = new LockableFileWriter(this.file);
+        try {
+            LockableFileWriter lfw2 = new LockableFileWriter(this.file);
+            fail("Somehow able to open a locked file. ");
+        } catch(IOException ioe) {
+            String msg = ioe.getMessage();
+            assertTrue( "Exception message does not start correctly. ", 
+                        msg.startsWith("Can't write file, lock ") );
+        } finally {
+            lfw.close();
+        }
+    }
+
+    public void testFileNotLocked() throws IOException {
+        LockableFileWriter lfw = new LockableFileWriter(this.file);
+        lfw.close();
+        try {
+            LockableFileWriter lfw2 = new LockableFileWriter(this.file);
+            lfw2.close();
+        } catch(IOException ioe) {
+            String msg = ioe.getMessage();
+            if( msg.startsWith("Can't write file, lock ") ) {
+                fail("Somehow unable to open a unlocked file. ");
+            }
+        }
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/NullOutputStreamTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/NullOutputStreamTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/NullOutputStreamTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,52 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.io.output;
+
+
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+
+/**
+ * Really not a lot to do here, but checking that no 
+ * Exceptions are thrown. 
+ *
+ * @author Henri Yandell (bayard at apache dot org)
+ * @version $Revision: 1.2 $ $Date: 2004/02/23 05:02:25 $
+ */
+
+public class NullOutputStreamTest extends TestCase {
+
+    public NullOutputStreamTest(String name) {
+        super(name);
+    }
+
+    public void testNull() throws IOException {
+        NullOutputStream nos = new NullOutputStream();
+        nos.write("string".getBytes());
+        nos.write("some string".getBytes(), 3, 5);
+        nos.write(1);
+        nos.write(0x0f);
+        nos.flush();
+        nos.close();
+        nos.write("allowed".getBytes());
+        nos.write(255);
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/TeeOutputStreamTest.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/TeeOutputStreamTest.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/output/TeeOutputStreamTest.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,68 @@
+/*
+ * Copyright 1999-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.commons.io.output;
+
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+
+/**
+ * @author Henri Yandell (bayard at apache dot org)
+ * @version $Revision: 1.3 $ $Date: 2004/02/23 05:02:25 $
+ */
+
+public class TeeOutputStreamTest extends TestCase {
+
+    public TeeOutputStreamTest(String name) {
+        super(name);
+    }
+
+    public void testTee() throws IOException {
+        ByteArrayOutputStream baos1 = new ByteArrayOutputStream();
+        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
+        TeeOutputStream tos = new TeeOutputStream(baos1, baos2);
+        for(int i = 0; i < 20; i++) {
+            tos.write(i);
+        }
+        assertByteArrayEquals("TeeOutputStream.write(int)", baos1.toByteArray(), baos2.toByteArray() );
+
+        byte[] array = new byte[10];
+        for(int i = 20; i < 30; i++) {
+            array[i-20] = (byte)i;
+        }
+        tos.write(array);
+        assertByteArrayEquals("TeeOutputStream.write(byte[])", baos1.toByteArray(), baos2.toByteArray() );
+
+        for(int i = 25; i < 35; i++) {
+            array[i-25] = (byte)i;
+        }
+        tos.write(array, 5, 5);
+        assertByteArrayEquals("TeeOutputStream.write(byte[], int, int)", baos1.toByteArray(), baos2.toByteArray() );
+    }
+
+    private void assertByteArrayEquals(String msg, byte[] array1, byte[] array2) {
+        assertEquals(msg+": array size mismatch", array1.length, array2.length);
+        for(int i=0; i<array1.length; i++) {
+            assertEquals(msg+": array[ " + i + "] mismatch", array1[i], array2[i]);
+        }
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/FileBasedTestCase.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/FileBasedTestCase.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/FileBasedTestCase.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2001-2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.testtools;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.Writer;
+import java.util.Arrays;
+
+import org.apache.commons.io.FileUtils;
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.io.output.ByteArrayOutputStream;
+
+import junit.framework.AssertionFailedError;
+import junit.framework.TestCase;
+
+/**
+ * Base class for testcases doing tests with files.
+ * 
+ * @author Jeremias Maerki
+ */
+public abstract class FileBasedTestCase extends TestCase {
+
+    private static File testDir;
+
+    public FileBasedTestCase(String name) {
+        super(name);
+    }
+    
+    public static File getTestDirectory() {
+        if (testDir == null) {
+            testDir = (new File("test/io/")).getAbsoluteFile();
+        }
+        return testDir;
+    }
+    
+    protected void createFile(File file, long size)
+            throws IOException {
+        if (!file.getParentFile().exists()) {
+            throw new IOException("Cannot create file " + file 
+                + " as the parent directory does not exist");
+        }
+        BufferedOutputStream output =
+            new BufferedOutputStream(new java.io.FileOutputStream(file));
+        try {
+            generateTestData(output, size);
+        } finally {
+            IOUtils.closeQuietly(output);
+        }
+    }
+    
+    protected byte[] generateTestData(long size) {
+        try {
+            ByteArrayOutputStream baout = new ByteArrayOutputStream();
+            generateTestData(baout, size);
+            return baout.toByteArray();
+        } catch (IOException ioe) {
+            throw new RuntimeException("This should never happen: " + ioe.getMessage());
+        }
+    }
+    
+    protected void generateTestData(OutputStream out, long size) 
+                throws IOException {
+        for (int i = 0; i < size; i++) {
+            //output.write((byte)'X');
+
+            // nice varied byte pattern compatible with Readers and Writers
+            out.write( (byte)( (i % 127) + 1) );
+        }
+    }
+
+    protected File newFile(String filename) throws IOException {
+        File destination = new File( getTestDirectory(), filename );
+        /*
+        assertTrue( filename + "Test output data file shouldn't previously exist",
+                    !destination.exists() );
+        */
+        if (destination.exists()) {
+            FileUtils.forceDelete(destination);
+        }
+        return destination;
+    }
+
+    protected void checkFile( File file, File referenceFile )
+                throws Exception {
+        assertTrue( "Check existence of output file", file.exists() );
+        assertEqualContent( referenceFile, file );
+    }
+
+    /** Assert that the content of two files is the same. */
+    private void assertEqualContent( File f0, File f1 )
+        throws IOException
+    {
+        /* This doesn't work because the filesize isn't updated until the file
+         * is closed.
+        assertTrue( "The files " + f0 + " and " + f1 +
+                    " have differing file sizes (" + f0.length() +
+                    " vs " + f1.length() + ")", ( f0.length() == f1.length() ) );
+        */
+        InputStream is0 = new java.io.FileInputStream( f0 );
+        try {
+            InputStream is1 = new java.io.FileInputStream( f1 );
+            try {
+                byte[] buf0 = new byte[ 1024 ];
+                byte[] buf1 = new byte[ 1024 ];
+                int n0 = 0;
+                int n1 = 0;
+
+                while( -1 != n0 )
+                {
+                    n0 = is0.read( buf0 );
+                    n1 = is1.read( buf1 );
+                    assertTrue( "The files " + f0 + " and " + f1 +
+                                " have differing number of bytes available (" + n0 +
+                                " vs " + n1 + ")", ( n0 == n1 ) );
+
+                    assertTrue( "The files " + f0 + " and " + f1 +
+                                " have different content", Arrays.equals( buf0, buf1 ) );
+                }
+            } finally {
+                is1.close();
+            }
+        } finally {
+            is0.close();
+        }
+    }
+
+    /** Assert that the content of a file is equal to that in a byte[]. */
+    protected void assertEqualContent( byte[] b0, File file )
+        throws IOException
+    {
+        InputStream is = new java.io.FileInputStream( file );
+        try {
+            byte[] b1 = new byte[ b0.length ];
+            int numRead = is.read( b1 );
+            assertTrue( "Different number of bytes", numRead == b0.length && is.available() == 0 );
+            for( int i = 0;
+                 i < numRead;
+                 assertTrue( "Byte " + i + " differs (" + b0[ i ] + " != " + b1[ i ] + ")", 
+                    b0[ i ] == b1[ i ] ), i++
+                );
+        } finally {
+            is.close();
+        }
+    }
+
+    protected void checkWrite(OutputStream output) throws Exception {
+        try {
+            new java.io.PrintStream(output).write(0);
+        } catch (Throwable t) {
+            throw new AssertionFailedError(
+                "The copy() method closed the stream "
+                    + "when it shouldn't have. "
+                    + t.getMessage());
+        }
+    }
+
+    protected void checkWrite(Writer output) throws Exception {
+        try {
+            new java.io.PrintWriter(output).write('a');
+        } catch (Throwable t) {
+            throw new AssertionFailedError(
+                "The copy() method closed the stream "
+                    + "when it shouldn't have. "
+                    + t.getMessage());
+        }
+    }
+
+    protected void deleteFile( File file )
+        throws Exception {
+        if (file.exists()) {
+            assertTrue("Couldn't delete file: " + file, file.delete());
+        }
+    }
+    
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/YellOnCloseInputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/YellOnCloseInputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/YellOnCloseInputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2003,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.testtools;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import junit.framework.AssertionFailedError;
+
+import org.apache.commons.io.input.ProxyInputStream;
+
+/**
+ * Helper class for checking behaviour of IO classes.
+ * 
+ * @author <a href="mailto:jeremias at apache.org">Jeremias Maerki</a>
+ */
+public class YellOnCloseInputStream extends ProxyInputStream {
+
+    /**
+     * @param proxy InputStream to delegate to.
+     */
+    public YellOnCloseInputStream(InputStream proxy) {
+        super(proxy);
+    }
+
+    /** @see java.io.InputStream#close() */
+    public void close() throws IOException {
+        throw new AssertionFailedError("close() was called on OutputStream");
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/YellOnFlushAndCloseOutputStream.java
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/YellOnFlushAndCloseOutputStream.java	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/src/test/org/apache/commons/io/testtools/YellOnFlushAndCloseOutputStream.java	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2003,2004 The Apache Software Foundation.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.io.testtools;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import junit.framework.AssertionFailedError;
+
+import org.apache.commons.io.output.ProxyOutputStream;
+
+/**
+ * Helper class for checking behaviour of IO classes.
+ * 
+ * @author <a href="mailto:jeremias at apache.org">Jeremias Maerki</a>
+ */
+public class YellOnFlushAndCloseOutputStream extends ProxyOutputStream {
+
+    private boolean yellForFlush;
+    private boolean yellForClose;
+
+    /**
+     * @param proxy OutputStream to delegate to.
+     * @param yellForFlush True if flush() is forbidden
+     * @param yellForClose True if close() is forbidden
+     */
+    public YellOnFlushAndCloseOutputStream(OutputStream proxy, boolean yellForFlush, boolean yellForClose) {
+        super(proxy);
+        this.yellForFlush = yellForFlush;
+        this.yellForClose = yellForClose;
+    }
+
+    /** @see java.io.OutputStream#flush() */
+    public void flush() throws IOException {
+        if (yellForFlush) {
+            throw new AssertionFailedError("flush() was called on OutputStream");
+        }
+        super.flush();
+    }
+
+    /** @see java.io.OutputStream#close() */
+    public void close() throws IOException {
+        if (yellForClose) {
+            throw new AssertionFailedError("close() was called on OutputStream");
+        }
+        super.close();
+    }
+
+}

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/bestpractices.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/bestpractices.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/bestpractices.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,113 @@
+<?xml version="1.0"?>
+
+<!--
+    Building IO
+    $Id: bestpractices.xml,v 1.1 2004/01/16 17:05:03 jeremias Exp $
+-->
+
+<document>
+  <body>
+
+    <section name="Overview">
+        <p>
+            This document presents a number of "best practices" in the IO area.
+        </p>
+    </section>
+
+    <section name="java.io.File">
+    
+        <p>
+            Often, you have to deal with files and filenames. There are many
+            things that can go wrong:
+        </p>
+        <ul>
+            <li>A class works in Unix but doesn't on Windows (or vice versa)</li>
+            <li>Invalid filenames due to double or missing path separators</li>
+            <li>UNC filenames (on Windows) don't work with my home-grown filename utility function</li>
+            <li>etc. etc.</li>
+        </ul>
+        <p>
+            These are good reasons not to work with filenames as Strings. Use 
+            java.io.File instead which handles many of the above cases nicely. Too
+            many people are still always using Strings for filenames and risk
+            platform dependencies, for example.
+        </p>
+        <p>
+            Let's look at an example. BTW, it's one of the functions that made us
+            skip the class FilenameUtils for the initial release of Commons IO.
+        </p>
+        <source>
+    public static String getExtension(String filename) {
+        int index = filename.lastIndexOf('.');
+
+        if (-1 == index) {
+            return "";
+        } else {
+            return filename.substring(index + 1);
+        }
+    }</source>
+        <p>
+            Easy enough? Right, but what happens if someone passes in a full path 
+            instead of only a filename? Consider the following, perfectly legal path:
+            "C:\Temp\documentation.new\README" 
+        </p>
+        <p>
+            Please use java.io.File for filenames instead of Strings. The functionality
+            that the class provides is well tested. In FileUtils you will find other
+            useful utility functions around java.io.File.
+        </p>
+        <p>
+            Instead of:
+        </p>
+        <source>
+    String tmpdir = "/var/tmp";
+    String tmpfile = tmpdir + System.getProperty("file.separator") + "test.tmp";
+    InputStream in = new java.io.FileInputStream(tmpfile);</source>
+        <p>
+            ...write:
+        </p>
+        <source>
+    File tmpdir = new File("/var/tmp");
+    File tmpfile = new File(tmpdir, "test.tmp");
+    InputStream in = new java.io.FileInputStream(tmpfile);</source>
+
+    </section>
+    
+    <section name="Buffering streams">
+        <p>
+            IO performance depends a lot from the buffering strategy. Usually, it's 
+            quite fast to read packets with the size of 512 or 1024 bytes because
+            these sizes match well with the packet sizes used on harddisks in 
+            file systems or file system caches. But as soon as you have to read only 
+            a few bytes and that many times performance drops significantly.
+        </p>
+        <p>
+            Make sure you're properly buffering streams when reading or writing 
+            streams, especially when working with files. Just decorate your 
+            FileInputStream with a BufferedInputStream:
+        </p>
+        <source>
+            InputStream in = new java.io.FileInputStream(myfile);
+            try {
+                in = new java.io.BufferedInputStream(in);
+                
+                in.read(.....
+            } finally {
+                IOUtils.closeQuietly(in);
+            }
+        </source>
+        <p>
+            Pay attention that you're not buffering an already buffered stream. Some
+            components like XML parsers may do their own buffering so decorating
+            the InputStream you pass to the XML parser does nothing but slowing down
+            your code. If you use our CopyUtils or IOUtils you don't need to 
+            additionally buffer the streams you use as the code in there already
+            buffers the copy process. Always check the Javadocs for information. 
+            Another case where buffering is unnecessary is when you write to a 
+            ByteArrayOutputStream since you're writing to memory only.
+        </p>
+    </section>
+
+  </body>
+
+</document>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/building.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/building.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/building.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,43 @@
+<?xml version="1.0"?>
+
+<!--
+    Building IO
+    $Id: building.xml,v 1.1 2004/01/16 17:05:03 jeremias Exp $
+-->
+
+<document>
+  <body>
+
+    <section name="Overview">
+        <p>
+            Jakarta Commons IO uses <a href="http://maven.apache.org">Maven</a> as 
+            build system. Please install Maven prior to attempting a build of IO.
+        </p>
+    </section>
+
+    <section name="Maven Goals">
+    
+        <subsection name="Building a JAR file">
+            <p>
+                Change into IO's root directory and run "maven jar" to build the JAR 
+                file. After a successful build you will find it in the "target" 
+                subdirectory.
+            </p>
+        </subsection>
+
+        <subsection name="Other Goals">
+            <p>
+                To build the Javadocs, run "maven javadoc". The result will be in 
+                "target/docs/apidocs".
+            </p>
+            <p>
+                To build the full website, run "maven site". The result will be in 
+                "target/docs".
+            </p>
+        </subsection>
+
+    </section>
+
+  </body>
+
+</document>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/changes.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/changes.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/changes.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<document>
+  <properties>
+    <title>Changes</title>
+  </properties>
+  <body>
+    <release version="1.0-dev" date="in CVS">
+    	<action dev="jeremias" type="remove">
+        IOUtils: Removed the copy() and toByteArray() variants with the bufferSize
+        parameter. Reasoning can be found at
+        http://www.mail-archive.com/commons-dev at jakarta.apache.org/msg19703.html
+    	</action>
+      <action type="update">
+        Renamed all *Util.java to *Utils.java for consistency.
+      </action>
+      <action dev="jeremias" type="update" 
+          due-to="Matthew Hawthorne" due-to-email="mhawthorne at alumni.pitt.edu">
+        Moved copy methods from IOUtils to CopyUtils.
+      </action>
+      <action dev="jeremias" type="update" 
+          due-to="Matthew Hawthorne" due-to-email="mhawthorne at alumni.pitt.edu">
+        Deprecated all methods in FileUtils using String filenames instead of 
+        java.io.File.
+      </action>
+      <action dev="bayard" type="remove">
+        Removed StreamUtils as all functionality is is IOUtils (and CopyUtils).
+      </action>
+      <action dev="rdonkin" type="fix">
+        Fixed typos in Apache license.
+      </action>
+      <action dev="jeremias" type="update">
+        All of Commons IO now uses its own ByteArrayOutputStream instead of 
+        java.io.ByteArrayOutputStream which should improve speed.
+      </action>
+      <action dev="jeremias" type="remove">
+        Removed deprecated IOUtils.bufferedCopy method.
+      </action>
+      <action dev="bayard" type="add">
+        ProxyInput/OutputStream: Better alternative base class than 
+        FilterInput/OutputStream.
+      </action>
+      <action dev="jeremias" type="add"
+          due-to="Alban Peignier" due-to-email="alban.peignier at free.fr">
+        New methods for FileUtils: isFileNewer() (3 variants)
+      </action>
+      <action dev="bayard" type="add"
+          due-to="Jeremias Maerki" due-to-email="jeremias at apache.org">
+        Added an alternative ByteArrayOutputStream implementation which is faster than
+        the original java.io.ByteArrayOutputStream by reusing buffers instead of 
+        reallocating them when the buffer needs to be resized.
+      </action>
+    </release>
+  </body>
+</document>
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/io-logo-white.png
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/io-logo-white.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/io-logo-white.xcf
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/io-logo-white.xcf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/logo.gif
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/images/logo.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/index.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/index.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/index.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,150 @@
+<?xml version="1.0"?>
+
+<!--
+    Main index
+    $Id: index.xml,v 1.8 2004/04/24 23:53:01 bayard Exp $
+-->
+
+<document>
+ <properties>
+   <title>Commons IO</title>
+   <author email="commons-dev at jakarta.apache.org">Commons Documentation Team</author>
+  </properties>
+  <body>
+
+    <section name="Commons IO">
+        <p>
+            Commons-IO contains <a href="#Utility classes">utility classes</a>,
+            stream implementations, <a href="#File filters">file filters</a>, and
+            <a href="#Endian classes">endian classes</a>.
+        </p>
+
+        <p>
+            For a more detailed descriptions, take a look at the
+            <a href="apidocs/index.html">JavaDocs</a>.
+        </p>
+    </section>
+
+    <section name="Utility classes">
+        <subsection name="CopyUtils and IOUtils">
+            <p>
+                <code>org.apache.commons.io.CopyUtils</code>
+                contains a comprehensive set of static methods for copying
+                from String, byte[], InputStream, Reader
+                to OutputStream, Writer.
+            </p>
+            <p>
+                <code>org.apache.commons.io.IOUtils</code>
+                contains additional IO-related tools for safely closing streams
+                and creating Strings and byte arrays from streams and Readers.
+            </p>
+
+            <p>
+                As an example, consider the task of reading bytes
+                from a URL, and printing them. This would typically done like this:
+            </p>
+
+            <source>
+    InputStream in = new URL( "http://jakarta.apache.org" ).openStream();
+    try {
+        InputStreamReader inR = new InputStreamReader( in );
+        BufferedReader buf = new BufferedReader( inR );
+        String line;
+        while ( ( line = buf.readLine() ) != null ) {
+            System.out.println( line );
+        }
+    } finally {
+        in.close();
+    }
+            </source>
+
+            <p>
+                With the IOUtils class, that could be done with:
+            </p>
+
+            <source>
+    InputStream in = new URL( "http://jakarta.apache.org" ).openStream();
+    try {
+        System.out.println( IOUtils.toString( in ) );
+    } finally {
+        IOUtils.closeQuietly(in);
+    }
+            </source>
+
+            <p>
+                In certain application domains, such IO operations are
+                common, and this class can save a great deal of time. And you can
+                rely on well-tested code.
+
+                For utility code such as this, flexibility and speed are of primary importance.
+            </p>
+
+        </subsection>
+
+        <subsection name="FileUtils">
+            <p>
+                The <code>org.apache.commons.io.FileUtils</code>
+                class contains methods for retrieving different components of a file path
+                (directory name, file base name, file extension), methods
+                for copying files to other files and directories, and methods
+                for querying, deleting and cleaning directories. For more information,
+                see the class description.
+            </p>
+        </subsection>
+
+    </section>
+
+    <section name="File filters">
+        <p>
+            The <code>org.apache.commons.io.filefilter</code>
+            package defines an interface (<code>IOFileFilter</code>) that
+            combines both <code>java.io.FileFilter</code> and
+            <code>java.io.FilenameFilter</code>. Besides
+            that the package offers a series of ready-to-use
+            implementations of the <code>IOFileFilter</code>
+            interface including
+            implementation that allow you to combine other such filters.
+
+            These filter can be used to list files or in FileDialog, for example.
+        </p>
+    </section>
+
+    <section name="Endian classes">
+        <p>
+            Different computer architectures adopt different
+            conventions for byte ordering. In so-called
+            "Little Endian" architectures (eg Intel), the low-order
+            byte is stored in memory at the lowest address, and
+            subsequent bytes at higher addresses. For "Big Endian"
+            architectures (eg Motorola), the situation is reversed.
+        </p>
+
+        <p>
+        There are two classes in this package of relevance:
+        </p>
+
+        <ul>
+           <li>
+           The <code>org.apache.commons.io.EndianUtils</code>
+           class contains static methods for swapping the Endian-ness
+           of Java primitives and streams.
+           </li>
+
+           <li>
+           The <code>org.apache.commons.io.input.SwappedDataInputStream</code>
+           class is an implementation of the <code>DataInput</code> interface. With
+           this, one can read data from files of non-native Endian-ness.
+           </li>
+        </ul>
+
+        <p>
+            For more information, see
+            <a
+                href="http://www.cs.umass.edu/~verts/cs32/endian.html">http://www.cs.umass.edu/~verts/cs32/endian.html</a>
+         </p>
+
+    </section>
+
+  </body>
+
+</document>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/navigation.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/navigation.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/navigation.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE org.apache.commons.menus SYSTEM '../../commons-build/menus/menus.dtd'>
+<project name="IO">
+
+  <title>IO</title>
+
+  <body>
+    <links>
+      <item name="Jakarta Commons" href="http://jakarta.apache.org/commons/"/>
+    </links>
+
+    <menu name="Commons IO">
+      <item name="Overview" href="index.html"/>
+      <item name="Javadoc" href="apidocs/index.html"/>
+      <item name="Best practices" href="bestpractices.html"/>
+      <item name="Building" href="building.html"/>
+      <item name="Mailing lists" href="mail-lists.html"/>
+      <item name="Team" href="team-list.html"/>
+      <item name="Tasks" href="tasks.html"/>
+      <item name="Proposal" href="proposal.html"/>
+      <item name="CVS" href="http://cvs.apache.org/viewcvs/jakarta-commons/io/"/>
+    </menu>
+    
+    &common-menus;
+
+  </body>
+</project>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/proposal.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/proposal.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/proposal.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,72 @@
+<?xml version="1.0"?>
+<?xml-stylesheet type="text/xsl" href="xdoc.xsl"?>
+<!-- $Revision: 1.2 $ $Date: 2004/02/18 09:40:34 $ -->
+<document>
+<properties>
+  <title>Proposal for IO Package</title>
+</properties>
+ <body>
+  
+ 
+<section name="Proposal for IO Package">
+ 
+  
+
+<subsection name="(0) Rationale">
+  
+<p>Many software projects have a need to perform I/O in various ways, and
+the JDK class libraries provide a lot of functionality, but sometimes you
+need just a little bit more.  The io package seeks to  encapsulate some of
+the most popular i/o base classes into one easy to  use package.</p>
+   
+</subsection>
+<subsection name="(1) Scope of the Package">
+  
+<p>This proposal is to create a package of Java utility classes for  various
+types of i/o related activity.</p>
+   
+</subsection>
+<subsection name="(1.5) Interaction With Other Packages">
+  
+<p><em>IO</em> relies only on standard JDK 1.2 (or later) APIs for production
+deployment.  It utilizes the JUnit unit testing framework for developing
+and executing unit tests, but this is of interest only to developers of the
+component.  IO will be a dependency for several existing components in the
+open source world.</p>
+  
+<p>No external configuration files are utilized.</p>
+   
+</subsection>
+<subsection name="(2) Initial Source of the Package">
+  
+<p>The original Java classes are splashed around various Apache  subprojects.
+ We intend to seek them out and integrate them.</p>
+  
+<p>The proposed package name for the new component is <code>org.apache.commons.io</code>.</p>
+   
+</subsection>
+<subsection name="(3)  Required Jakarta-Commons Resources">
+  
+<ul>
+ <li>CVS Repository - New directory <code>io</code> in the     <code>jakarta-commons</code>
+CVS repository.</li>
+ <li>Mailing List - Discussions will take place on the general     <em>commons-dev at jakarta.apache.org</em>
+mailing list.  To help     list subscribers identify messages of interest,
+it is suggested that     the message subject of messages about this component
+be prefixed with     [IO].</li>
+ <li>Bugzilla - New component "IO" under the "Commons" product     category,
+with appropriate version identifiers as needed.</li>
+ <li>Jyve FAQ - New category "commons-io" (when available).</li>
+ 
+</ul>
+   
+</subsection>
+<subsection name="(4) Initial Committers">
+  
+<p>The initial committers on the IO component shall be Scott Sanders and
+Nicola Ken Barozzi and Henri Yandell</p>
+    
+</subsection>
+</section>
+</body>
+</document>

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/style/project.css
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/style/project.css	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/style/project.css	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,10 @@
+#banner, #banner td { 
+ background: #fff;
+ color: #000;
+}
+
+#banner td { 
+ height: 100%;
+ vertical-align: middle;
+}
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/tasks.xml
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/tasks.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/jakarta/commons-io-1.0/xdocs/tasks.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,45 @@
+<?xml version="1.0"?>
+<document>
+  <body>
+    <section name="Action Items">
+      <p>
+        The following classes will be excluded from the initial release:
+      </p>
+      <ul>
+        <li>FilenameUtils: This class is still a big mess with many methods not working properly.</li>
+        <li>ClassLoaderObjectInputStream: Unless a unit test is written for it in time. </li>
+      </ul>
+    </section>
+    <section name="Post 1.0 release">
+      <ul>
+        <li>IOUtilsTestCase: Handle unit tests that test an IOUtils method and a CopyUtils method at the same time. </li>
+        <li>Write Unit Test for ClassLoaderObjectInputStream. </li>
+        <li>FilenameUtils: This class is a big mess ATM. We need to clean it up.</li>
+        <li>A CsvReader/Writer set of classes in a csv sub-package</li>
+        <li>FilePoller for telling when a file changes. Look in Tomcat, or GenJava[bayard]</li>
+        <li>A "hot folder" handler which triggers an action when a new file has been uploaded to an FTP directory, for example.</li>
+        <li>JoinReader/ConcatReader. One in GenJava, one submitted to Bayard</li>
+        <li>FormattedWriter, when it writes out values it uses Format objects to output them. </li>
+        <li>FixedWidthReader. Reads in files with a known width, ie) mainframe like. </li>
+        <li>Finder system. Generic code to find things in things. So FileFinder, 
+            ClassFinder, ZipFinder. Probably too big for IO</li>
+        <li>Add an additional ByteArrayOutputStream variant that saves content
+            in memory just as the original but starts to write to a temp file when
+            a given number of bytes is surpassed. This is to reduce the memory
+            usage for big "things".</li>
+        <li>FileUtils could use a copyDirectory() method (possibly making use of IOFileFilters)</li>
+      </ul>
+    </section>
+    <section name="Misc.">
+      <ul>
+        <li>
+          <strong>Integration</strong>. Seek and integrate various i/o related classes.
+        </li>
+        <li>
+          <strong>Install / Use Documentation</strong>.  Create simple
+          installation and User's Guide documentation for this component.
+        </li>
+      </ul>
+    </section>
+  </body>
+</document>

Added: trunk/org.prorefactor.lib/plugin.xml
===================================================================
--- trunk/org.prorefactor.lib/plugin.xml	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/plugin.xml	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<?eclipse version="3.0"?>
+<plugin
+   id="org.prorefactor.lib"
+   name="ProRefactor required Libraries"
+   version="1.2.4"
+   provider-name="ProRefactor.org">
+
+   <runtime>
+      <library name="hibernate/cglib-full-2.0.2.jar">
+         <export name="*"/>
+      </library>
+      <library name="hsqldb/hsqldb.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/commons-collections-2.1.1.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/commons-lang-1.0.1.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/commons-logging-1.0.4.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/dom4j-1.4.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/ehcache-0.9.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/jdbc2_0-stdext.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/jta.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/odmg-3.0.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/xerces-2.4.0.jar">
+         <export name="*"/>
+      </library>
+      <library name="hibernate/xml-apis.jar">
+         <export name="*"/>
+      </library>
+      <library name="jakarta/commons-io-1.0/commons-io-1.0.jar">
+         <export name="*"/>
+      </library>
+   </runtime>
+
+</plugin>

Added: trunk/org.prorefactor.lib/readme.txt
===================================================================
--- trunk/org.prorefactor.lib/readme.txt	2005-01-20 00:40:49 UTC (rev 16)
+++ trunk/org.prorefactor.lib/readme.txt	2005-04-19 21:45:07 UTC (rev 17)
@@ -0,0 +1,7 @@
+Most of these libraries can be commonly shared amongst plug-ins, but there is a problem
+with trying to reference hibernate.jar from one plug-in to another. Each plug-in gets its own
+ClassLoader, and Hibernate needs to be able to find resources on your classpath. So if
+hibernate.jar has a different ClassLoader than your plug-in does, then the necessary
+resources won't be found by Hibernate. Because of this, you must copy hibernate.jar into
+your plug-in, so that it has the same class loader as the rest of your plug-in.
+If you know of a better way, please tell me.  -- john at joanju.com, March 2005.



From johnallengreen at sheep.berlios.de  Fri Apr 29 02:03:00 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Fri, 29 Apr 2005 02:03:00 +0200
Subject: [Prorefactor-svn] r19 - trunk/org.prorefactor.core/data/tp01tests
Message-ID: <200504290003.j3T030LZ014236@sheep.berlios.de>

Author: johnallengreen
Date: 2005-04-29 02:01:04 +0200 (Fri, 29 Apr 2005)
New Revision: 19

Removed:
   trunk/org.prorefactor.core/data/tp01tests/test01.out.p
Log:
Removed temp output file from repository.

Deleted: trunk/org.prorefactor.core/data/tp01tests/test01.out.p
===================================================================
--- trunk/org.prorefactor.core/data/tp01tests/test01.out.p	2005-04-19 21:54:45 UTC (rev 18)
+++ trunk/org.prorefactor.core/data/tp01tests/test01.out.p	2005-04-29 00:01:04 UTC (rev 19)
@@ -1,101 +0,0 @@
- /* buffers=sports.bs,sports.customer,sports.state,tt1,tt12,wt1 */ 
-/* Data file for testing treeparser01.
- */
-
-
-DEF TEMP-TABLE  /* 0:tt1 */ tt1 FIELD  /* 0:tt1.f1 */ f1 AS INT.
-DEF WORK-TABLE  /* 0:wt1 */ wt1 FIELD  /* 0:wt1.f1 */ f1 AS INT.
-
-FIND FIRST  /* 0:sports.customer */ customer NO-ERROR.
-FIND FIRST  /* 0:sports.customer abbrev */ cust NO-ERROR.
-DISPLAY /* 0:sports.customer.address unqualfield */  address /* 0:sports.customer.balance abbrev unqualfield */  bal.
-DISPLAY /* 0:sports.customer.discount */  customer.discount.
-DISPLAY /* 0:sports.customer.discount abbrev */  customer.disc.
-DISPLAY /* 0:sports.customer.discount abbrev */  cust.discount.
-DISPLAY /* 0:sports.customer.comments abbrev */  sports.cust.comm.
-
-DEF VAR  /* 0:outer1 */ outer1 AS INT.
-
- /* buffers=b_tt1,sports.b_cust */ PROCEDURE myproc1:
-  DEF INPUT PARAMETER  /* 1:inner1c */ inner1c AS INT.
-  DEF BUFFER  /* 1:b_tt1 */ b_tt1 FOR  /* 0:tt1 */ tt1.
-  DEF BUFFER  /* 1:sports.b_cust */ b_cust FOR  /* 0:sports.customer abbrev */ cust.
-  DEF VAR  /* 1:inner1a */ inner1a AS INT.
-  DEF VAR  /* 1:inner1b */ inner1b AS INT.
-  DISPLAY /* 1:inner1c */  inner1c.
-  FIND FIRST  /* 0:tt1 */ tt1 NO-ERROR.
-  FIND FIRST  /* 0:wt1 */ wt1 NO-ERROR.
-  FIND FIRST  /* 1:b_tt1 */ b_tt1 NO-ERROR.
-  FIND FIRST  /* 1:sports.b_cust */ b_cust NO-ERROR.
-  DISPLAY /* 1:sports.b_cust.comments abbrev */  b_cust.comm.
-END.
-
-DEF VAR  /* 0:outer2 */ outer2 AS INT.
-
-FUNCTION myFunc1 RETURNS LOGICAL ( /* 1:inner2c */ inner2c AS INT):
-  DEF VAR  /* 1:inner2a */ inner2a AS INT.
-  ON ENDKEY ANYWHERE DO:
-    DEF VAR  /* 2:inner2aa */ inner2aa AS INT.
-    DISPLAY /* 2:inner2aa */  inner2aa.
-    DISPLAY /* 1:inner2a */  inner2a.
-    DISPLAY /* 1:inner2c */  inner2c.
-    DISPLAY /* 0:outer1 */  outer1.
-  END.
-  DEF VAR  /* 1:inner2b */ inner2b AS INT.
-  RETURN TRUE.
-END.
-
-DEF VAR  /* 0:outer3 */ outer3 AS INT.
-
-
-/* Bug in the tree parser used to prevent parameter buffers from working */
-DEFINE TEMP-TABLE  /* 0:tt11 */ tt11
-  FIELD  /* 0:tt11.f1 */ f1 AS CHARACTER.
- /* buffers=sports.bf11 */ function fn11 returns logical
-    (   buffer  /* 1:sports.bf11 */ bf11 for  /* 0:sports.customer */ customer,
-        table for  /* 0:tt11 */ tt11 append,
-        table  /* 0:tt11 */ tt11,
-        table-handle  /* 1:thandle11 */ thandle11 append
-    ):
-  message /* 1:thandle11 */  thandle11.
-  find first  /* 1:sports.bf11 */ bf11.
-  return false.
-end.
-
-
-/* Test that define table LIKE works
- * i.e. Ensure that the field names get copied into the
- * new table def.
- */
-def temp-table  /* 0:tt12a */ tt12a
-  rcode-information
-  field  /* 0:tt12a.f1 */ f1 as char.
-def temp-table  /* 0:tt12 */ tt12 no-undo like  /* 0:tt12a */ tt12a.
-find first  /* 0:tt12 */ tt12.
-display /* 0:tt12.f1 */  tt12.f1.
-
-
-/* Make sure MESSAGE..UPDATE..AS works.
- * Note that defining the variable state changes the "display state"
- * statement. Normally it would display the record (not state.state)
- * but in this case, the variable is displayed.
- */
-find first  /* 0:sports.state */ state.
-MESSAGE "hello" 
-  VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO UPDATE /* 0:state */   /* 0:state */ state AS LOGICAL.
-display /* 0:state */  state.
-
-
-/* Make sure that we aren't comparing a buffer name to the
- * table name.
- */
-define buffer  /* 0:sports.bs */ bs for  /* 0:sports.state */ state.
-find first  /* 0:sports.bs */ bs.
-display /* 0:sports.bs.state */  bs.state.
-
-
-/* There used to be a problem with references like this... */
-DEFINE TEMP-TABLE  /* 0:state */ state NO-UNDO LIKE  /* 0:sports.state */ state
-       Field  /* 0:state.oldstate */ oldstate like /* 0:state.state */  state.state.
-
-



From johnallengreen at sheep.berlios.de  Fri Apr 29 02:25:34 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Fri, 29 Apr 2005 02:25:34 +0200
Subject: [Prorefactor-svn] r20 - trunk/org.prorefactor.core/data/tp01tests
Message-ID: <200504290025.j3T0PYNt024090@sheep.berlios.de>

Author: johnallengreen
Date: 2005-04-29 02:24:26 +0200 (Fri, 29 Apr 2005)
New Revision: 20

Modified:
   trunk/org.prorefactor.core/data/tp01tests/
Log:



Property changes on: trunk/org.prorefactor.core/data/tp01tests
___________________________________________________________________
Name: svn:ignore
   + test01.out.p




