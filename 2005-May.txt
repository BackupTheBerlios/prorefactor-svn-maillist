From johnallengreen at sheep.berlios.de  Mon May  2 20:58:49 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Mon, 2 May 2005 20:58:49 +0200
Subject: [Prorefactor-svn] r22 - in trunk: org.prorefactor.core/src/org/prorefactor org.prorefactor.core/src/org/prorefactor/core org.prorefactor.core/src/org/prorefactor/nodetypes org.prorefactor.core/src/org/prorefactor/treeparser org.prorefactor.core/src/org/prorefactor/treeparser01 org.prorefactor.doc org.prorefactor.refactor/src/org/prorefactor/refactor/action org.prorefactor.refactor/src/org/prorefactor/refactor/tfnames org.prorefactor.refactor/src/org/prorefactor/treeparser03
Message-ID: <200505021858.j42Iwn35016632@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-02 20:58:48 +0200 (Mon, 02 May 2005)
New Revision: 22

Added:
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/BlockNode.java
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/NodeFactory.java
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/RecordNameNode.java
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/package.html
Modified:
   trunk/org.prorefactor.core/src/org/prorefactor/core/JPNav.java
   trunk/org.prorefactor.core/src/org/prorefactor/core/JPNode.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Block.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java
   trunk/org.prorefactor.doc/manual.xml
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/ExtractMethod.java
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/QualifyFieldsRefactor.java
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/RenameSchema.java
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/tfnames/NamesLint.java
   trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TP03Support.java
Log:
Started subclassing JPNode, so that the AST is easier to program with.

Modified: trunk/org.prorefactor.core/src/org/prorefactor/core/JPNav.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/core/JPNav.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.core/src/org/prorefactor/core/JPNav.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -17,12 +17,16 @@
  * Methods here are specific to Proparse's tree structure.
  * For general node navigation (firstChild, etc.) see JPNode.
  * <p>
- * I plan to subclass JPNode, for example, to FieldRefNode, which will allow
+ * The new subclass of JPNode, FieldRefNode, allows
  * this class and its members to go away entirely.
+ * @deprecated
  */
 public class JPNav {
 
-	/** Find the ID node for a Field_ref node */
+	/** Find the ID node for a Field_ref node
+	 * @deprecated
+	 * @see org.prorefactor.nodetypes.FieldRefNode#getIdNode()
+	 */
 	public static JPNode findFieldRefIdNode(JPNode refNode) {
 		JPNode idNode = refNode.findDirectChild(TokenTypes.ID);
 		assert idNode != null;

Modified: trunk/org.prorefactor.core/src/org/prorefactor/core/JPNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/core/JPNode.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.core/src/org/prorefactor/core/JPNode.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -23,8 +23,10 @@
 
 import java.util.HashMap;
 
+import org.prorefactor.nodetypes.NodeFactory;
 
 
+
 /**
  * Extension to antlr.BaseAST, which allows us to extract an
  * external "antlr" AST view of a Proparse AST, which we can
@@ -75,7 +77,11 @@
 	 */
 	public static final Integer BUFFERSCOPE = new Integer(-212);
 
-	/** A valid value for setLink() and getLink() */
+	/** A valid value for setLink() and getLink().
+	 * You should not use this directly. Only JPNodes of subtype BlockNode
+	 * will have this set, so use BlockNode.getBlock instead.
+	 * @see org.prorefactor.nodetypes.BlockNode.
+	 */
 	public static final Integer BLOCK = new Integer(-214);
 
 	static private ProparseLdr parser = ProparseLdr.getInstance();
@@ -124,7 +130,7 @@
 	}
 
 	private static JPNode getTree(int inHandle, TreeConfig config, JPNode parent) {
-		JPNode thisNode = new JPNode(inHandle, config);
+		JPNode thisNode = NodeFactory.create(inHandle).configure(config);
 		thisNode.parent = parent;
 		int handle = parser.getHandle();
 		if (parser.nodeFirstChildI(inHandle, handle) != 0) {
@@ -197,7 +203,8 @@
 
 
 
-	private void configure(TreeConfig config) {
+	private JPNode configure(TreeConfig config) {
+		if (config==null) return this;
 		if (config.disconnected) {
 			attrSet(JPNode.STATE2, parser.attrGetI(nodeHandle, IConstants.STATE2));
 			fileIndex = parser.getNodeFileIndex(nodeHandle);
@@ -211,6 +218,7 @@
 			column = parser.getNodeColumn(nodeHandle);
 		}
 		if (config.callback != null) config.callback.run(this);
+		return this;
 	} // configure
 
 

Added: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/BlockNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/BlockNode.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/BlockNode.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -0,0 +1,32 @@
+/* Created on Apr 29, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.nodetypes;
+
+import org.prorefactor.core.JPNode;
+import org.prorefactor.treeparser.Block;
+
+
+public class BlockNode extends JPNode {
+
+	public BlockNode(int handle) { super(handle); }
+	public BlockNode(int handle, TreeConfig config) { super(handle, config); }
+	public BlockNode(int file, int line, int column) { super(file, line, column); }
+
+	public Block getBlock() {
+		Block block = (Block) getLink(JPNode.BLOCK);
+		assert block != null;
+		return block;
+	}
+	public void setBlock(Block block) {
+		setLink(JPNode.BLOCK, block);
+	}
+	
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -0,0 +1,67 @@
+/* Created on Apr 29, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.nodetypes;
+
+import org.prorefactor.core.JPNode;
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.treeparser.BufferScope;
+import org.prorefactor.treeparser.FieldBuffer;
+import org.prorefactor.treeparser.Symbol;
+import org.prorefactor.treeparser.Variable;
+
+
+public class FieldRefNode extends JPNode {
+
+	public FieldRefNode(int handle) { super(handle); }
+	public FieldRefNode(int handle, TreeConfig config) { super(handle, config); }
+	public FieldRefNode(int file, int line, int column) { super(file, line, column); }
+
+	public BufferScope getBufferScope() {
+		BufferScope bufferScope = (BufferScope) getLink(JPNode.BUFFERSCOPE);
+		assert bufferScope!=null;
+		return bufferScope;
+	}
+	
+	/** We very often need to reference the ID node for a Field_ref node.
+	 * The Field_ref node is a synthetic node - it doesn't have any text.
+	 * If we want the field/variable name, or the file/line/column, then
+	 * we probably want to get those from the ID node.
+	 */
+	public JPNode getIdNode() {
+		JPNode idNode = findDirectChild(TokenTypes.ID);
+		assert idNode != null;
+		return idNode;
+	}
+	
+	/** Get the Symbol for a Field_ref node.
+	 * @return Always returns one of two Symbol types: Variable or FieldBuffer.
+	 */
+	public Symbol getSymbol() {
+		Symbol symbol = (Symbol) getLink(JPNode.SYMBOL);
+		assert symbol != null;
+		return symbol;
+	}
+	
+	public void setBufferScope(BufferScope bufferScope) {
+		assert bufferScope!=null;
+		setLink(JPNode.BUFFERSCOPE, bufferScope);
+	}
+	
+	public void setSymbol(FieldBuffer symbol) {
+		assert symbol!=null;
+		setLink(JPNode.SYMBOL, symbol);
+	}
+	public void setSymbol(Variable symbol) {
+		assert symbol!=null;
+		setLink(JPNode.SYMBOL, symbol);
+	}
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/NodeFactory.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/NodeFactory.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/NodeFactory.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -0,0 +1,77 @@
+/* Created on Apr 29, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.nodetypes;
+
+import org.prorefactor.core.IConstants;
+import org.prorefactor.core.JPNode;
+import org.prorefactor.core.TokenTypes;
+
+import com.joanju.ProparseLdr;
+
+
+/** Create a JPNode, or an object of the appropriate subclass.
+ * <p>
+ * <b>This factory is final - it may not be subclassed or replaced.<b><br>
+ * ProRefactor expects nodes to be of certain subtypes. If third parties
+ * were to use their own node factories, then when ProRefactor adds
+ * new JPNode subtypes, the third party factories would be out of date, and
+ * cause ProRefactor to fail.
+ * <p>
+ * An alternative implementation would have been to restrict ProRefactor to
+ * only reference JPNode, so that third parties could subclass JPNode any 
+ * which way. This was decided against, in favor of allowing JPNode subclasses
+ * to be used within ProRefactor itself. Third parties should use other
+ * mechanisms to extend JPNode, such as attributes and setLink/getLink.
+ * It is ProRefactor's responsibility to provide appropriate node subtypes so
+ * that the tree is easy to work with.
+ */
+public final class NodeFactory {
+	
+	private static ProparseLdr parser = ProparseLdr.getInstance();
+	
+	public static JPNode create(int handle) {
+		switch (parser.getNodeTypeI(handle)) {
+		case TokenTypes.Field_ref:
+			return new FieldRefNode(handle);
+		case TokenTypes.RECORD_NAME:
+			return new RecordNameNode(handle);
+		case TokenTypes.DO:
+		case TokenTypes.FOR:
+		case TokenTypes.REPEAT:
+		case TokenTypes.FUNCTION:
+		case TokenTypes.ON:
+		case TokenTypes.PROCEDURE:
+			// We check that these are statement heads, whether the keyword is reserved or not.
+			if (parser.attrGetI(handle, IConstants.STATEHEAD) != 0 )
+				return new BlockNode(handle);
+			else
+				return new JPNode(handle);
+		case TokenTypes.Program_root:
+		case TokenTypes.CANFIND:
+			// CANFIND is reserved, and only used in the syntax for the CAN-FIND function.
+			// It is a "block" because it has special buffer/index-cursor handling.
+			return new BlockNode(handle);
+		case TokenTypes.TRIGGERS:
+			{
+				int temp = parser.getHandle();
+				int childType = parser.nodeFirstChildI(handle, temp);
+				parser.releaseHandle(temp);
+				if (childType == TokenTypes.Code_block)
+					return new BlockNode(handle);
+				else
+					return new JPNode(handle);
+			}
+		default:
+			return new JPNode(handle);
+		}
+	}
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/RecordNameNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/RecordNameNode.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/RecordNameNode.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -0,0 +1,45 @@
+/* Created on Apr 29, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.nodetypes;
+
+import org.prorefactor.core.JPNode;
+import org.prorefactor.treeparser.BufferScope;
+import org.prorefactor.treeparser.TableBuffer;
+
+
+public class RecordNameNode extends JPNode {
+
+	public RecordNameNode(int handle) { super(handle); }
+	public RecordNameNode(int handle, TreeConfig config) { super(handle, config); }
+	public RecordNameNode(int file, int line, int column) { super(file, line, column); }
+
+	public BufferScope getBufferScope() {
+		BufferScope bufferScope = (BufferScope) getLink(JPNode.BUFFERSCOPE);
+		assert bufferScope!=null;
+		return bufferScope;
+	}
+	
+	public TableBuffer getTableBuffer() {
+		TableBuffer buffer = (TableBuffer) getLink(JPNode.SYMBOL);
+		assert buffer != null;
+		return buffer;
+	}
+
+	public void setBufferScope(BufferScope bufferScope) {
+		assert bufferScope!=null;
+		setLink(JPNode.BUFFERSCOPE, bufferScope);
+	}
+	
+	public void setTableBuffer(TableBuffer buffer) {
+		setLink(JPNode.SYMBOL, buffer);
+	}
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/package.html
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/package.html	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/package.html	2005-05-02 18:58:48 UTC (rev 22)
@@ -0,0 +1,24 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<!--
+ Copyright (c) 2005 Joanju (www.joanju.com)
+ All rights reserved. This program and the accompanying materials 
+ are made available under the terms of the Eclipse Public License v1.0
+ which accompanies this distribution, and is available at
+ http://www.eclipse.org/legal/epl-v10.html
+-->
+</head>
+<body bgcolor="white">
+
+Subtypes of org.prorefactor.core.JPNode, and related classes. 
+
+
+<h2>Package Specification</h2>
+
+<h2>Related Documentation</h2>
+
+<!-- Put @see and @since tags down here. -->
+
+</body>
+</html>

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Block.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Block.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Block.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -25,6 +25,7 @@
 import org.prorefactor.core.TokenTypes;
 import org.prorefactor.core.schema.Field;
 import org.prorefactor.core.schema.Schema;
+import org.prorefactor.nodetypes.RecordNameNode;
 
 
 
@@ -89,14 +90,13 @@
 	 * a CAN-FIND function. (2004.Sep:John: Maybe in triggers too? Haven't checked.)
 	 * @param node The RECORD_NAME node. Must have the BufferSymbol linked to it already.
 	 */
-	public void addHiddenCursor(JPNode node) {
-		TableBuffer symbol = (TableBuffer) node.getLink(JPNode.SYMBOL);
-		assert symbol != null;
+	public void addHiddenCursor(RecordNameNode node) {
+		TableBuffer symbol = node.getTableBuffer();
 		BufferScope buff = new BufferScope(this, symbol, BufferScope.HIDDEN_CURSOR);
 		bufferScopes.add(buff);
 		// Note the difference compared to addStrong and addWeak - we don't add
 		// BufferScope references to the enclosing blocks.
-		node.setLink(JPNode.BUFFERSCOPE, buff);
+		node.setBufferScope(buff);
 	}
 
 
@@ -108,13 +108,12 @@
 	 * @param node The RECORD_NAME node. It must already have
 	 * the BufferSymbol linked to it.
 	 */
-	public void addStrongBufferScope(JPNode node) {
-		TableBuffer symbol = (TableBuffer) node.getLink(JPNode.SYMBOL);
-		assert symbol != null;
+	public void addStrongBufferScope(RecordNameNode node) {
+		TableBuffer symbol = node.getTableBuffer();
 		BufferScope buff = new BufferScope(this, symbol, BufferScope.STRONG);
 		bufferScopes.add(buff);
 		addBufferScopeReferences(buff);
-		node.setLink(JPNode.BUFFERSCOPE, buff);
+		node.setBufferScope(buff);
 	} // addStrongBufferScope
 
 

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -23,6 +23,9 @@
 import org.prorefactor.core.schema.Field;
 import org.prorefactor.core.schema.Schema;
 import org.prorefactor.core.schema.Table;
+import org.prorefactor.nodetypes.BlockNode;
+import org.prorefactor.nodetypes.FieldRefNode;
+import org.prorefactor.nodetypes.RecordNameNode;
 import org.prorefactor.treeparser.Block;
 import org.prorefactor.treeparser.BufferScope;
 import org.prorefactor.treeparser.CQ;
@@ -110,9 +113,9 @@
 
 	/** Beginning of a block. */
 	public void blockBegin(AST blockAST) {
-		JPNode node = (JPNode) blockAST;
-		currentBlock = pushBlock(new Block(currentBlock, node));
-		node.setLink(JPNode.BLOCK, currentBlock);
+		BlockNode blockNode = (BlockNode) blockAST;
+		currentBlock = pushBlock(new Block(currentBlock, blockNode));
+		blockNode.setBlock(currentBlock);
 	}
 
 
@@ -135,7 +138,7 @@
 	 * making a local-scoped named buffer using that same name.
 	 */
 	protected void canFindBegin(AST canfindAST, AST recordAST) {
-		JPNode recordNode = (JPNode) recordAST;
+		RecordNameNode recordNode = (RecordNameNode) recordAST;
 		// Keep a ref to the current block...
 		Block b = currentBlock;
 		// ...create a can-find scope and block (assigns currentBlock)...
@@ -154,7 +157,7 @@
 			isDefault = true;
 		}
 		TableBuffer newBuff = currentScope.defineBuffer(isDefault ? "" : buffName, table);
-		recordNode.setLink(JPNode.SYMBOL, newBuff);
+		recordNode.setTableBuffer(newBuff);
 		currentBlock.addHiddenCursor(recordNode);
 	}
 
@@ -308,7 +311,7 @@
 	 */
 	public void field(AST refAST, AST idAST, int contextQualifier, int whichTable) {
 		JPNode idNode = (JPNode) idAST;
-		JPNode refNode = (JPNode) refAST;
+		FieldRefNode refNode = (FieldRefNode) refAST;
 		String name = idNode.getText();
 		FieldLookupResult result = null;
 
@@ -355,17 +358,17 @@
 			refNode.attrSet(IConstants.ABBREVIATED, IConstants.TRUE);
 		// Variable
 		if (result.variable != null) {
-			refNode.setLink(JPNode.SYMBOL, result.variable);
+			refNode.setSymbol(result.variable);
 			refNode.attrSet(IConstants.STORETYPE, IConstants.ST_VAR);
 			result.variable.noteReference(contextQualifier);
 		}
 		// Buffer attributes
 		if (result.bufferScope != null) {
-			refNode.setLink(JPNode.BUFFERSCOPE, result.bufferScope);
+			refNode.setBufferScope(result.bufferScope);
 		}
 		// Table field
 		if (result.field != null) {
-			refNode.setLink(JPNode.SYMBOL, result.field);
+			refNode.setSymbol(result.field);
 			result.field.noteReference(contextQualifier);
 		}
 
@@ -386,7 +389,7 @@
 		SymbolScope forwardScope = (SymbolScope) funcForwards.get(idAST.getText());
 		if (forwardScope==null) return;
 		scopeSwap(forwardScope);
-		((JPNode)funcAST).setLink(JPNode.BLOCK, currentBlock);
+		((BlockNode)funcAST).setBlock(currentBlock);
 	}
 
 
@@ -432,11 +435,11 @@
 	}
 
 	public void programRoot(AST rootAST) {
-		JPNode node = (JPNode) rootAST;
-		currentBlock = pushBlock(new Block(rootScope, node));
+		BlockNode blockNode = (BlockNode) rootAST;
+		currentBlock = pushBlock(new Block(rootScope, blockNode));
 		rootScope.setRootBlock(currentBlock);
-		node.setLink(JPNode.BLOCK, currentBlock);
-		parseUnit.setTopNode(node);
+		blockNode.setBlock(currentBlock);
+		parseUnit.setTopNode(blockNode);
 		parseUnit.setRootScope(rootScope);
 	}
 
@@ -488,8 +491,8 @@
 
 	/** Action to take at various RECORD_NAME nodes. */
 	public void recordNameNode(AST anode, int contextQualifier) {
-		JPNode node = (JPNode) anode;
-		node.attrSet(IConstants.CONTEXT_QUALIFIER, contextQualifier);
+		RecordNameNode recordNode = (RecordNameNode) anode;
+		recordNode.attrSet(IConstants.CONTEXT_QUALIFIER, contextQualifier);
 		TableBuffer buffer = null;
 		switch (contextQualifier) {
 			case CQ.INIT :
@@ -498,7 +501,7 @@
 			case CQ.REFUP :
 			case CQ.UPDATING :
 			case CQ.BUFFERSYMBOL :
-				buffer = currentScope.getBufferSymbol(node.getText());
+				buffer = currentScope.getBufferSymbol(recordNode.getText());
 				break;
 			case CQ.SYMBOL :
 				buffer = currentScope.lookupTableOrBufferSymbol(anode.getText());
@@ -513,21 +516,17 @@
 			default :
 				assert false;
 		}
-		recordNodeSymbol(node, buffer); // Does checks, sets attributes.
-		node.setLink(JPNode.SYMBOL, buffer);
+		recordNodeSymbol(recordNode, buffer); // Does checks, sets attributes.
+		recordNode.setTableBuffer(buffer);
 		switch (contextQualifier) {
 			case CQ.INIT :
 			case CQ.REF :
 			case CQ.REFUP :
 			case CQ.UPDATING :
-				node.setLink(
-					JPNode.BUFFERSCOPE
-					, currentBlock.getBufferForReference(buffer) );
+				recordNode.setBufferScope(currentBlock.getBufferForReference(buffer));
 				break;
 			case CQ.INITWEAK :
-				node.setLink(
-					JPNode.BUFFERSCOPE
-					, currentBlock.addWeakBufferScope(buffer) );
+				recordNode.setBufferScope(currentBlock.addWeakBufferScope(buffer));
 				break;
 		}
 		buffer.noteReference(contextQualifier);
@@ -536,11 +535,11 @@
 
 
 	public void scopeAdd(AST anode) {
-		JPNode node = (JPNode) anode;
+		BlockNode blockNode = (BlockNode) anode;
 		currentScope = currentScope.addScope();
-		currentBlock = pushBlock(new Block(currentScope, node));
+		currentBlock = pushBlock(new Block(currentScope, blockNode));
 		currentScope.setRootBlock(currentBlock);
-		node.setLink(JPNode.BLOCK, currentBlock);
+		blockNode.setBlock(currentBlock);
 	} // scopeAdd()
 
 
@@ -581,7 +580,7 @@
 	 * the BufferSymbol linked to it.
 	 */
 	public void strongScope(AST anode) {
-		currentBlock.addStrongBufferScope((JPNode)anode);
+		currentBlock.addStrongBufferScope((RecordNameNode)anode);
 	}
 
 

Modified: trunk/org.prorefactor.doc/manual.xml
===================================================================
--- trunk/org.prorefactor.doc/manual.xml	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.doc/manual.xml	2005-05-02 18:58:48 UTC (rev 22)
@@ -1589,6 +1589,17 @@
               Added data type attribute to fields and variables in the symbol
               table.</para>
             </listitem>
+
+            <listitem>
+              <para>Some classes and class members have been deprecated, and
+              will be removed soon. Please see the javadoc.</para>
+            </listitem>
+
+            <listitem>
+              <para>Subclassed JPNode. This allows JPNav to go away, and
+              allows us to add better functions for getting Symbols and such,
+              rather than working directly with the JPNode "links".</para>
+            </listitem>
           </itemizedlist>
         </listitem>
       </varlistentry>

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/ExtractMethod.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/ExtractMethod.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/ExtractMethod.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -19,9 +19,8 @@
 
 import org.prorefactor.core.ICallback;
 import org.prorefactor.core.IConstants;
-import org.prorefactor.core.JPNav;
 import org.prorefactor.core.JPNode;
-import org.prorefactor.core.TokenTypes;
+import org.prorefactor.nodetypes.FieldRefNode;
 import org.prorefactor.refactor.FileStuff;
 import org.prorefactor.refactor.RefactorException;
 import org.prorefactor.refactor.RefactorSession;
@@ -112,13 +111,13 @@
 	/** Check if a Field_ref is in the selection range.
 	 * Update our reference list if so.
 	 */
-	protected void checkFieldRef(JPNode refNode) {
-		JPNode idNode = JPNav.findFieldRefIdNode(refNode);
+	protected void checkFieldRef(FieldRefNode refNode) {
+		JPNode idNode = refNode.getIdNode();
 		if (idNode.getFileIndex() != selectionFile) return;
 		if (! org.prorefactor.core.Util.isInRange(
 			idNode.getLine(), idNode.getColumn(), selectionBegin, selectionEnd ) )
 			return;
-		Symbol symbol = (Symbol) refNode.getLink(JPNode.SYMBOL);
+		Symbol symbol = refNode.getSymbol();
 		assert symbol != null;
 		if (symbol instanceof Variable) {
 			// If the variable is scoped to the program block, parameter is not necessary.
@@ -220,8 +219,7 @@
 		selectionFile = FileStuff.getFileIndex(sourceFile);
 		ICallback callback = new ICallback() {
 			public Object run(Object obj) {
-				JPNode node = (JPNode) obj;
-				if (node.getType() == TokenTypes.Field_ref) checkFieldRef(node);
+				if (obj instanceof FieldRefNode) checkFieldRef((FieldRefNode)obj);
 				return null;
 			}
 		};

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/QualifyFieldsRefactor.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/QualifyFieldsRefactor.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/QualifyFieldsRefactor.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -17,10 +17,9 @@
 
 import org.prorefactor.core.ICallback;
 import org.prorefactor.core.IConstants;
-import org.prorefactor.core.JPNav;
 import org.prorefactor.core.JPNode;
 import org.prorefactor.core.PRCException;
-import org.prorefactor.core.TokenTypes;
+import org.prorefactor.nodetypes.FieldRefNode;
 import org.prorefactor.refactor.FileStuff;
 import org.prorefactor.refactor.RefactorException;
 import org.prorefactor.refactor.ScanLib;
@@ -42,21 +41,21 @@
 	private File sourceFile;
 	
 	protected class UnqualNode {
-		UnqualNode(JPNode idNode, JPNode refNode) {
+		UnqualNode(JPNode idNode, FieldRefNode refNode) {
 			this.idNode = idNode;
 			this.refNode = refNode;
 		}
 		JPNode idNode;
-		JPNode refNode;
+		FieldRefNode refNode;
 	}
 	
 
 
 	public ICallback callback = new ICallback() {
 		public Object run(Object obj) {
-			JPNode refNode = (JPNode) obj;
-			if (refNode.getType() != TokenTypes.Field_ref) return null;
-			JPNode idNode = JPNav.findFieldRefIdNode(refNode);
+			if (! (obj instanceof FieldRefNode)) return null;
+			FieldRefNode refNode = (FieldRefNode) obj;
+			JPNode idNode = refNode.getIdNode();
 			if (idNode.getFileIndex() != sourceFileIndex) return null;
 			if (refNode.attrGet(IConstants.UNQUALIFIED_FIELD) == IConstants.TRUE)
 				nodeList.add(new UnqualNode(idNode, refNode));
@@ -79,7 +78,7 @@
 			String fieldname = parser.getNodeText(handle);
 			if (fieldname.compareToIgnoreCase(uqn.idNode.getText()) != 0) continue;
 			// Can't be unqualified unless it's a Field - which must have a BufferSymbol.
-			FieldBuffer fieldBuff = (FieldBuffer) uqn.refNode.getLink(JPNode.SYMBOL);
+			FieldBuffer fieldBuff = (FieldBuffer) uqn.refNode.getSymbol();
 			assert fieldBuff != null;
 			parser.setNodeText(
 					handle

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/RenameSchema.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/RenameSchema.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/action/RenameSchema.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -18,12 +18,13 @@
 import java.util.StringTokenizer;
 import java.util.TreeSet;
 
-import org.prorefactor.core.JPNav;
 import org.prorefactor.core.JPNode;
 import org.prorefactor.core.TokenTypes;
 import org.prorefactor.core.schema.Field;
 import org.prorefactor.core.schema.Schema;
 import org.prorefactor.core.schema.Table;
+import org.prorefactor.nodetypes.FieldRefNode;
+import org.prorefactor.nodetypes.RecordNameNode;
 import org.prorefactor.refactor.IRefactor;
 import org.prorefactor.refactor.PUB;
 import org.prorefactor.refactor.Refactor;
@@ -103,24 +104,23 @@
 
 	private void checkNode(JPNode node) {
 		int type = node.getType();
-		if (type == TokenTypes.Field_ref) checkNodeDuField(node);
-		else if (type == TokenTypes.RECORD_NAME) checkNodeDuTable(node);
+		if (type == TokenTypes.Field_ref) checkNodeDuField((FieldRefNode)node);
+		else if (type == TokenTypes.RECORD_NAME) checkNodeDuTable((RecordNameNode)node);
 		return;
 	}
 	
 	
 	
-	private void checkNodeDuField(JPNode node) {
-		Symbol symbol = (Symbol) node.getLink(JPNode.SYMBOL);
-		assert symbol != null;
+	private void checkNodeDuField(FieldRefNode refNode) {
+		Symbol symbol = refNode.getSymbol();
 		if (! (symbol instanceof FieldBuffer)) return;
-		FieldBuffer fieldBuff = (FieldBuffer) node.getLink(JPNode.SYMBOL);
+		FieldBuffer fieldBuff = (FieldBuffer) symbol;
 		assert fieldBuff != null;
 		TableBuffer tableBuff = fieldBuff.getBuffer();
 		String mapFieldValue = (String) schemaMap.get(fieldBuff.getField());
 		String mapTableValue = (String) schemaMap.get(tableBuff.getTable());
 		if (mapFieldValue==null && mapTableValue==null) return;
-		JPNode idNode = JPNav.findFieldRefIdNode(node);
+		JPNode idNode = refNode.getIdNode();
 		String origText = idNode.getText();
 		Field.Name oldName = new Field.Name(origText);
 		Field.Name newName = new Field.Name(origText);
@@ -143,8 +143,8 @@
 	
 	
 	
-	private void checkNodeDuTable(JPNode node) {
-		TableBuffer buffer = (TableBuffer) node.getLink(JPNode.SYMBOL);
+	private void checkNodeDuTable(RecordNameNode node) {
+		TableBuffer buffer = node.getTableBuffer();
 		assert buffer != null;
 		// Check that this is a "default" schema buffer - not a named buffer.
 		if (! buffer.isDefaultSchema()) return;

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/tfnames/NamesLint.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/tfnames/NamesLint.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/tfnames/NamesLint.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -20,6 +20,8 @@
 import org.prorefactor.core.TokenTypes;
 import org.prorefactor.core.schema.Database;
 import org.prorefactor.core.schema.Table;
+import org.prorefactor.nodetypes.FieldRefNode;
+import org.prorefactor.nodetypes.RecordNameNode;
 import org.prorefactor.refactor.ILint;
 import org.prorefactor.treeparser.FieldBuffer;
 import org.prorefactor.treeparser.Symbol;
@@ -74,11 +76,11 @@
 		switch (node.getType()) {
 			case TokenTypes.Field_ref :
 				currTarget = new NamesTarget();
-				lintFieldRef(node);
+				lintFieldRef((FieldRefNode)node);
 				break;
 			case TokenTypes.RECORD_NAME :
 				currTarget = new NamesTarget();
-				lintRecordName(node);
+				lintRecordName((RecordNameNode)node);
 				break;
 		}
 	} // examineNode()
@@ -106,10 +108,9 @@
 
 
 
-	private void lintFieldRef(JPNode node) {
+	private void lintFieldRef(FieldRefNode node) {
 		int handle = node.getHandle();
-		Symbol symbol =  (Symbol) node.getLink(JPNode.SYMBOL);
-		assert symbol != null;
+		Symbol symbol =  node.getSymbol();
 		FieldBuffer fieldBuff = null;
 		TableBuffer tableBuff = null;
 		if (symbol instanceof FieldBuffer) { 
@@ -210,8 +211,8 @@
 	 * (Buffer names cannot be abbreviated, and we're not going to try to deal
 	 * with capitalization on buffer names. bCustomer might be very valid.)
 	 */
-	private void lintRecordName(JPNode node) {
-		TableBuffer tableBuff = (TableBuffer) node.getLink(JPNode.SYMBOL);
+	private void lintRecordName(RecordNameNode node) {
+		TableBuffer tableBuff = node.getTableBuffer();
 		Table table = tableBuff.getTable();
 
 		// Are we applying changes to work/temp tables?

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TP03Support.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TP03Support.java	2005-04-29 00:27:31 UTC (rev 21)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TP03Support.java	2005-05-02 18:58:48 UTC (rev 22)
@@ -39,6 +39,7 @@
 import org.prorefactor.core.CommentFinder;
 import org.prorefactor.core.IConstants;
 import org.prorefactor.core.JPNode;
+import org.prorefactor.nodetypes.FieldRefNode;
 import org.prorefactor.refactor.RefactorTarget;
 import org.prorefactor.refactor.noundo.NoundoTarget;
 import org.prorefactor.treeparser.Symbol;
@@ -177,10 +178,10 @@
 	 * @param refNode The Field_ref node.
 	 * @param idNode The ID node.
 	 */
-	public void fieldRef(AST refNode, AST idNode) {
+	public void fieldRef(AST refAST, AST idNode) {
 		if (!isUpdating) return;
-		Symbol symbol = (Symbol) ((JPNode)refNode).getLink(JPNode.SYMBOL);
-		assert symbol != null;
+		FieldRefNode refNode = (FieldRefNode) refAST;
+		Symbol symbol = refNode.getSymbol();
 		NoundoTarget target = (NoundoTarget) undoTargetsMap.get(symbol);
 		if (target==null) return;
 		((Block)blockList.getFirst()).undoTargetsAssignedList.add(target);



From johnallengreen at sheep.berlios.de  Wed May  4 23:17:53 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Wed, 4 May 2005 23:17:53 +0200
Subject: [Prorefactor-svn] r23 - in trunk/org.prorefactor.core/src/org/prorefactor: . nodetypes treeparser treeparser01 widgettypes
Message-ID: <200505042117.j44LHrW7019169@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-04 23:17:51 +0200 (Wed, 04 May 2005)
New Revision: 23

Added:
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Dataset.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Datasource.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Query.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Stream.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/SymbolFactory.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Widget.java
   trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/
   trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Browse.java
   trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Button.java
   trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Frame.java
   trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Image.java
   trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Menu.java
   trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/MenuItem.java
   trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Rectangle.java
   trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Submenu.java
Modified:
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Routine.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Symbol.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/SymbolScope.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Variable.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Action.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/treeparser01.g
Log:
Added separate symbol name spaces for each Progress type (FRAME, QUERY, STREAM, etc), as well as separate lookups for those.

Modified: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -13,7 +13,9 @@
 import org.prorefactor.core.JPNode;
 import org.prorefactor.core.TokenTypes;
 import org.prorefactor.treeparser.BufferScope;
+import org.prorefactor.treeparser.DataType;
 import org.prorefactor.treeparser.FieldBuffer;
+import org.prorefactor.treeparser.Primative;
 import org.prorefactor.treeparser.Symbol;
 import org.prorefactor.treeparser.Variable;
 
@@ -30,6 +32,8 @@
 		return bufferScope;
 	}
 	
+	public DataType getDataType() { return ((Primative)getSymbol()).getDataType(); }
+
 	/** We very often need to reference the ID node for a Field_ref node.
 	 * The Field_ref node is a synthetic node - it doesn't have any text.
 	 * If we want the field/variable name, or the file/line/column, then

Added: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Dataset.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Dataset.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Dataset.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,34 @@
+/** 3 May 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.treeparser;
+
+import org.prorefactor.core.TokenTypes;
+
+
+/** A Symbol defined with DEFINE DATASET. */
+public class Dataset extends Symbol {
+
+	public Dataset(String name, SymbolScope scope) {
+		super(scope);
+		setName(name);
+	}
+
+	/** For this subclass of Symbol, fullName() returns the same value as getName(). */
+	public String fullName() { return getName(); }
+
+	/** Returns TokenTypes.DATASET.
+	 * @see org.prorefactor.treeparser.Symbol#getProgressType()
+	 */
+	public int getProgressType() {
+		return TokenTypes.DATASET;
+	}
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Datasource.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Datasource.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Datasource.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,34 @@
+/** 3 May 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.treeparser;
+
+import org.prorefactor.core.TokenTypes;
+
+
+/** A Symbol defined with DEFINE DATA-SOURCE. */
+public class Datasource extends Symbol {
+
+	public Datasource(String name, SymbolScope scope) {
+		super(scope);
+		setName(name);
+	}
+
+	/** For this subclass of Symbol, fullName() returns the same value as getName(). */
+	public String fullName() { return getName(); }
+
+	/** Returns TokenTypes.DATASOURCE.
+	 * @see org.prorefactor.treeparser.Symbol#getProgressType()
+	 */
+	public int getProgressType() {
+		return TokenTypes.DATASOURCE;
+	}
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Query.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Query.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Query.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,34 @@
+/** 3 May 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.treeparser;
+
+import org.prorefactor.core.TokenTypes;
+
+
+/** A Symbol defined with DEFINE QUERY. */
+public class Query extends Symbol {
+
+	public Query(String name, SymbolScope scope) {
+		super(scope);
+		setName(name);
+	}
+
+	/** For this subclass of Symbol, fullName() returns the same value as getName(). */
+	public String fullName() { return getName(); }
+
+	/** Returns TokenTypes.QUERY.
+	 * @see org.prorefactor.treeparser.Symbol#getProgressType()
+	 */
+	public int getProgressType() {
+		return TokenTypes.QUERY;
+	}
+
+}

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Routine.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Routine.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Routine.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -15,6 +15,7 @@
 public class Routine extends Symbol {
 		
 	private SymbolScope routineScope;
+	private int progressType;
 	
 	public Routine (String name, SymbolScope definingScope, SymbolScope routineScope){
 		super(definingScope);
@@ -30,7 +31,13 @@
 		return getName();
 	}
 
+	/** Return TokenTypes: PROCEDURE or FUNCTION. */
+	public int getProgressType() { return progressType; }
+	
 	public SymbolScope getRoutineScope(){
 		return routineScope;
 	}
+	
+	public Routine setProgressType(int t) { progressType=t; return this; }
+
 }

Added: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Stream.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Stream.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Stream.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,36 @@
+/** 3 May 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.treeparser;
+
+import org.prorefactor.core.TokenTypes;
+
+
+/** A Symbol defined with DEFINE STREAM or any other
+ * syntax which implicitly define a stream.
+ */
+public class Stream extends Symbol {
+
+	public Stream(String name, SymbolScope scope) {
+		super(scope);
+		setName(name);
+	}
+
+	/** For this subclass of Symbol, fullName() returns the same value as getName(). */
+	public String fullName() { return getName(); }
+
+	/** Returns TokenTypes.STREAM.
+	 * @see org.prorefactor.treeparser.Symbol#getProgressType()
+	 */
+	public int getProgressType() {
+		return TokenTypes.STREAM;
+	}
+
+}

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Symbol.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Symbol.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Symbol.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -114,27 +114,12 @@
 	 * A TableBuffer object always returns BUFFER, regardless of whether
 	 * the object is a named buffer or a default buffer.
 	 * A FieldBuffer object always returns FIELD.
-	 * @see org.prorefactor.treeparser.TableBuffer#getProgressType().
 	 */
-	public int getProgressType() {
-		// If there is no DEFINE node, then we assume inline VARIABLE def,
-		// as in "message..update x as char"
-		if (	defNode == null
-			||	defNode.getType() != TokenTypes.DEFINE
-			) return TokenTypes.VARIABLE;
-		JPNode n = defNode.firstChild();
-		int type = n.getType();
-		if (type==TokenTypes.NEW || type==TokenTypes.SHARED) {
-			type = n.nextSibling().getType();
-		}
-		return type;
-	}
+	public abstract int getProgressType();
 	
 	
-	
 	public SymbolScope getScope() { return scope; }
 
-
 	
 	/** Defined as NEW [GLOBAL] SHARED? */
 	public boolean isExported() {

Added: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/SymbolFactory.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/SymbolFactory.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/SymbolFactory.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,53 @@
+/* Created on May 3, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.treeparser;
+
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.widgettypes.*;
+
+
+/** Create a Symbol of the appropriate subclass. */
+public final class SymbolFactory {
+
+	public static Symbol create(int symbolType, String name, SymbolScope scope) {
+		switch (symbolType) {
+		case TokenTypes.DATASET:
+			return new Dataset(name, scope);
+		case TokenTypes.DATASOURCE:
+			return new Datasource(name, scope);
+		case TokenTypes.QUERY:
+			return new Query(name, scope);
+		case TokenTypes.STREAM:
+			return new Stream(name, scope);
+		// Widgets
+		case TokenTypes.BROWSE:
+			return new Browse(name, scope);
+		case TokenTypes.BUTTON:
+			return new Button(name, scope);
+		case TokenTypes.FRAME:
+			return new Frame(name, scope);
+		case TokenTypes.IMAGE:
+			return new Image(name, scope);
+		case TokenTypes.MENU:
+			return new Menu(name, scope);
+		case TokenTypes.MENUITEM:
+			return new MenuItem(name, scope);
+		case TokenTypes.RECTANGLE:
+			return new Rectangle(name, scope);
+		case TokenTypes.SUBMENU:
+			return new Submenu(name, scope);
+		default:
+			assert false : "Unexpected values for SymbolFactory" + " " + symbolType + " " + name;
+			return null;
+		}
+	}
+
+}

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/SymbolScope.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/SymbolScope.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/SymbolScope.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -1,15 +1,12 @@
 /**
- * SymbolScope.java
  * @author John Green
  * 6-Nov-2002
- * www.joanju.com
  * 
- * Copyright (c) 2002-2004 Joanju Limited.
+ * Copyright (c) 2002-2005 Joanju (www.joanju.com)
  * All rights reserved. This program and the accompanying materials 
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
  */
 
 package org.prorefactor.treeparser;
@@ -23,6 +20,7 @@
 import java.util.Set;
 
 import org.prorefactor.core.IConstants;
+import org.prorefactor.core.TokenTypes;
 import org.prorefactor.core.schema.Schema;
 import org.prorefactor.core.schema.Table;
 
@@ -39,14 +37,6 @@
  */
 public class SymbolScope {
 
-	/** Only Scope and derivatives may create a Scope object.
-	 * @param parentScope null if called by the SymbolScopeRoot constructor.
-	 */
-	protected SymbolScope(SymbolScope parentScope) {
-		this.parentScope = parentScope;
-		if (parentScope!=null) this.rootScope = parentScope.rootScope;
-	}
-
 	private static Schema schema = Schema.getInstance();
 
 	private ArrayList allSymbols = new ArrayList();
@@ -55,12 +45,32 @@
 	protected Map bufferMap = new HashMap();
 	protected Map callMap = new HashMap();
 	protected Map routineMap = new HashMap();
+	protected Map unnamedBuffers = new HashMap();
+	protected Map typeMap = new HashMap();
 	protected Map variableMap = new HashMap();
-	protected Map unnamedBuffers = new HashMap();
 	private SymbolScope parentScope;
 	protected SymbolScopeRoot rootScope;
+	
+	private static final Integer DATASET = new Integer(TokenTypes.DATASET);
+	private static final Integer DATASOURCE = new Integer(TokenTypes.DATASOURCE);
+	private static final Integer QUERY = new Integer(TokenTypes.QUERY);
+	private static final Integer STREAM = new Integer(TokenTypes.STREAM);
 
+	/** Only Scope and derivatives may create a Scope object.
+	 * @param parentScope null if called by the SymbolScopeRoot constructor.
+	 */
+	protected SymbolScope(SymbolScope parentScope) {
+		this.parentScope = parentScope;
+		if (parentScope!=null) this.rootScope = parentScope.rootScope;
+	}
+	
+	// Initialization block
+	{
+		typeMap.put(new Integer(TokenTypes.VARIABLE), variableMap);
+	}
 
+
+	
 	/** Add a Routine for call handling. */
 	public void add(Routine routine){
 		routineMap.put(routine.getName().toLowerCase(), routine);
@@ -68,12 +78,23 @@
 
 	
 	/** Add a Variable for names lookup. */
-	public void add(Variable fieldSymbol) {
-		variableMap.put(fieldSymbol.getName().toLowerCase(), fieldSymbol);
+	public void add(Variable var) {
+		variableMap.put(var.getName().toLowerCase(), var);
 	}
 
+	/** Add a Symbol for names lookup. */
+	public void add(Symbol symbol) {
+		Integer type = new Integer(symbol.getProgressType());
+		Map map = (Map) typeMap.get(type);
+		if (map==null) {
+			map = new HashMap();
+			typeMap.put(type, map);
+		}
+		map.put(symbol.getName().toLowerCase(), symbol);
+	}
 
 
+
 	/** Add a new scope to this scope. */
 	public SymbolScope addScope() {
 		SymbolScope newScope = new SymbolScope(this);
@@ -251,9 +272,26 @@
 		}
 		return symbol;
 	} // lookupBuffer()
+	
+	
+	
+	public Dataset lookupDataset(String name) { return (Dataset) lookupSymbol(DATASET, name); }
+	
+	public Datasource lookupDatasource(String name) { return (Datasource) lookupSymbol(DATASOURCE, name); }
+	
+	public Query lookupQuery(String name) { return (Query) lookupSymbol(QUERY, name); }
+	
+	public Stream lookupStream(String name) { return (Stream) lookupSymbol(STREAM, name); }
 
+	
+	private Object lookupSymbol(Integer symbolType, String name) {
+		Map map = (Map) typeMap.get(symbolType);
+		if (map==null) return null;
+		return map.get(name.toLowerCase());
+	}
 
 
+
 	/** Lookup a Table or a BufferSymbol, schema table first.
 	 * It seems to work like this: unabbreviated schema name, then
 	 * buffer/temp/work name, then abbreviated schema names. Sheesh.
@@ -292,6 +330,13 @@
 
 
 
+	/** Lookup a Widget based on TokenType (FRAME, BUTTON, etc) and the name. */
+	public Widget lookupWidget(int widgetType, String name) {
+		return (Widget) lookupSymbol(new Integer(widgetType), name);
+	}
+
+
+
 	public void setRootBlock(Block block) { rootBlock = block; }
 
 

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Variable.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Variable.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Variable.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -1,26 +1,22 @@
-/**
- * Variable.java
- * @author John Green
- * 6-Nov-2002
- * www.joanju.com
+/** 6-Nov-2002
+ * Authors: John Green
  * 
- * Copyright (c) 2002, 2004 Joanju Limited.
+ * Copyright (c) 2002, 2004, 2005 Joanju (www.joanju.com)
  * All rights reserved. This program and the accompanying materials 
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
  */
 
 package org.prorefactor.treeparser;
 
+import org.prorefactor.core.TokenTypes;
 
 
+
 /**
- * Represents a defined symbol in a 4gl compile unit, such as a
- * variable, frame, menu, menu-item, etc.
- * @see org.prorefactor.treeparser.TableBuffer
- * @see org.prorefactor.treeparser.FieldBuffer
+ * A Symbol defined with DEFINE VARIABLE or any of the other various
+ * syntaxes which implicitly define a variable.
  */
 public class Variable extends Symbol implements Primative, Value {
 
@@ -45,6 +41,13 @@
 	
 	public void setDataType(DataType dataType) { this.dataType = dataType; }
 
+	/** Returns TokenTypes.VARIABLE.
+	 * @see org.prorefactor.treeparser.Symbol#getProgressType()
+	 */
+	public int getProgressType() {
+		return TokenTypes.VARIABLE;
+	}
+
 	/** @see org.prorefactor.treeparser.Value#setValue(java.lang.Object) */
 	public void setValue(Object value) { this.value = value; }
 

Added: trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Widget.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Widget.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser/Widget.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,29 @@
+/** 3 May 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.treeparser;
+
+
+/**
+ * A Symbol defined with DEFINE <widget-type> or any of the other various
+ * syntaxes which implicitly define a widget.
+ * This includes FRAMEs, WINDOWs, MENUs, etc.
+ */
+public abstract class Widget extends Symbol {
+
+	public Widget(String name, SymbolScope scope) {
+		super(scope);
+		setName(name);
+	}
+
+	/** For this subclass of Symbol, fullName() returns the same value as getName(). */
+	public String fullName() { return getName(); }
+
+}

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Action.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Action.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Action.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -13,6 +13,7 @@
 package org.prorefactor.treeparser01;
 
 
+import org.prorefactor.treeparser.Symbol;
 import org.prorefactor.treeparser.Variable;
 
 import antlr.collections.AST;
@@ -70,7 +71,13 @@
 	 */
 	public void defineBufferForTrigger(AST recAST) {}
 
+	
+	/** Called by the tree parser to define anything other than
+	 * buffers, temp/work tables, and variables/parameters.
+	 */
+	public Symbol defineSymbol(AST defAST, AST idAST, int symbolType) { return null; }
 
+	
 	/** Called by the tree parser at a temp or work table field definition. */
 	public void defineTableField(AST idNode) {}
 

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -20,6 +20,7 @@
 
 import org.prorefactor.core.IConstants;
 import org.prorefactor.core.JPNode;
+import org.prorefactor.core.TokenTypes;
 import org.prorefactor.core.schema.Field;
 import org.prorefactor.core.schema.Schema;
 import org.prorefactor.core.schema.Table;
@@ -36,6 +37,7 @@
 import org.prorefactor.treeparser.Primative;
 import org.prorefactor.treeparser.Routine;
 import org.prorefactor.treeparser.Symbol;
+import org.prorefactor.treeparser.SymbolFactory;
 import org.prorefactor.treeparser.SymbolScope;
 import org.prorefactor.treeparser.SymbolScopeRoot;
 import org.prorefactor.treeparser.TableBuffer;
@@ -225,6 +227,26 @@
 
 
 
+	public Symbol defineSymbol(AST defAST, AST idAST, int symbolType) {
+		/* Some notes:
+		 * We need to create the Symbol right away, because further
+		 * actions in the grammar might need to set attributes on it.
+		 * We can't add it to the scope yet, because of statements like this:
+		 *   def var xyz like xyz.
+		 * The tree parser is responsible for calling addToScope at the end of
+		 * the statement or when it is otherwise safe to do so.
+		 */
+		JPNode defNode = (JPNode) defAST;
+		JPNode idNode = (JPNode) idAST;
+		Symbol symbol = SymbolFactory.create(symbolType, idNode.getText(), currentScope);
+		symbol.setDefOrIdNode(defNode);
+		currSymbol = symbol;
+		idNode.setLink(JPNode.SYMBOL, symbol);
+		return symbol;
+	}
+
+	
+	
 	public void defineTableField(AST idAST) {
 		JPNode idNode = (JPNode)idAST;
 		FieldBuffer fieldBuff = rootScope.defineTableField(idNode.getText(), currDefTable);
@@ -375,33 +397,40 @@
 	} // field()
 
 
+	private static DataType fieldRefDataType(AST refAST) {
+		return ((FieldRefNode)refAST).getDataType();
+	}
 
+
 	/** If this function definition did not list any parameters, but it had a
 	 * function forward declaration, then we use the block and scope from that
 	 * declaration, in case it is where the parameters were listed.
 	 */
 	protected void funcDef(AST funcAST, AST idAST) {
+		SymbolScope forwardScope = (SymbolScope) funcForwards.get(idAST.getText());
+		if (forwardScope==null) funcSymbolCreate(idAST);
 		// If there are symbols (i.e. parameters, buffer params) already defined in
 		// this function scope, then we don't do anything.
 		if (	currentScope.getVariableSet().size() > 0
 			||	currentScope.getBufferSet().size() > 0
 			) return;
-		SymbolScope forwardScope = (SymbolScope) funcForwards.get(idAST.getText());
 		if (forwardScope==null) return;
 		scopeSwap(forwardScope);
 		((BlockNode)funcAST).setBlock(currentBlock);
 	}
 
-
-	/** This is a really good example of why we need to subclass JPNode! */
-	private static DataType fieldRefDataType(AST refAST) {
-		return ((Primative)((JPNode)refAST).getLink(JPNode.SYMBOL)).getDataType();
-	}
-
-
 	protected void funcForward(AST idAST) {
 		funcForwards.put(idAST.getText(), currentScope);
+		funcSymbolCreate(idAST);
 	}
+	
+	private Routine funcSymbolCreate(AST idAST) {
+		SymbolScope definingScope = currentScope.getParentScope();
+		Routine r = new Routine(idAST.getText(), definingScope, currentScope);
+		r.setProgressType(TokenTypes.FUNCTION);
+		definingScope.add(r);
+		return r;
+	}
 
 
 
@@ -426,6 +455,7 @@
 		SymbolScope definingScope = currentScope;
 		scopeAdd(procNode);
 		Routine r = new Routine(idNode.getText(), definingScope, currentScope);
+		r.setProgressType(TokenTypes.PROCEDURE);
 		definingScope.add(r);
 	}
 	

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/treeparser01.g
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/treeparser01.g	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/treeparser01.g	2005-05-04 21:17:51 UTC (rev 23)
@@ -1350,7 +1350,7 @@
 
 definebrowsestate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? BROWSE
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(BROWSE, #def, #id)); }
 			(#(QUERY ID))? (lockhow|NOWAIT)*
 			(	#(	DISPLAY
 					(	#(	Form_item
@@ -1394,7 +1394,7 @@
 
 definebuttonstate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? BUTTON 
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(BUTTON, #def, #id)); }
 			(	AUTOGO
 			|	AUTOENDKEY
 			|	DEFAULT
@@ -1423,7 +1423,7 @@
 
 definedatasetstate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? DATASET
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(DATASET, #def, #id)); }
 			FOR tbl[CQ.INIT] (COMMA tbl[CQ.INIT])*
 			( data_relation ( (COMMA)? data_relation)* )?
 			state_end
@@ -1442,7 +1442,7 @@
 
 definedatasourcestate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? DATASOURCE
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(DATASOURCE, #def, #id)); }
 			FOR (#(QUERY ID))?
 			(source_buffer_phrase)? (COMMA source_buffer_phrase)*
 			{ action.addToScope(pop()); }
@@ -1456,7 +1456,7 @@
 
 defineframestate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? FRAME
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(FRAME, #def, #id)); }
 			(form_item[CQ.SYMBOL])*
 			(	#(HEADER (display_item)+ )
 			|	#(BACKGROUND (display_item)+ )
@@ -1468,7 +1468,7 @@
 
 defineimagestate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? IMAGE
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(IMAGE, #def, #id)); }
 			(	#(LIKE fld[CQ.SYMBOL] (VALIDATE)?)
 			|	imagephrase_opt 
 			|	sizephrase
@@ -1486,7 +1486,7 @@
 
 definemenustate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? MENU
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(MENU, #def, #id)); }
 			(menu_opt)* (menu_list_item)* state_end
 			{ action.addToScope(pop()); }
 		)
@@ -1502,7 +1502,7 @@
 	;
 menu_list_item
 	:	(	#(	MENUITEM
-				id:ID { push(action.defineVariable(#id, #id)); }
+				id:ID { push(action.defineSymbol(MENUITEM, #id, #id)); }
 				(	#(ACCELERATOR expression )
 				|	color_expr
 				|	DISABLED
@@ -1515,7 +1515,7 @@
 				{ action.addToScope(pop()); }
 			)
 		|	#(	SUBMENU
-				id2:ID { push(action.defineVariable(#id2, #id2)); }
+				id2:ID { push(action.defineSymbol(SUBMENU, #id2, #id2)); }
 				(DISABLED | label_constant | #(FONT expression) | color_expr)*
 				{ action.addToScope(pop()); }
 			)
@@ -1563,7 +1563,7 @@
 
 definequerystate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? QUERY
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(QUERY, #def, #id)); }
 			FOR tbl[CQ.INIT] (record_fields)?
 			(COMMA tbl[CQ.INIT] (record_fields)?)*
 			( #(CACHE expression) | SCROLLING | RCODEINFORMATION)*
@@ -1574,7 +1574,7 @@
 
 definerectanglestate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? RECTANGLE
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(RECTANGLE, #def, #id)); }
 			(	NOFILL
 			|	#(EDGECHARS expression )
 			|	#(EDGEPIXELS expression )
@@ -1592,12 +1592,12 @@
 
 definestreamstate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? STREAM id:ID state_end )
-		{ action.addToScope(action.defineVariable(#def, #id)); }
+		{ action.addToScope(action.defineSymbol(STREAM, #def, #id)); }
 	;
 
 definesubmenustate
 	:	#(	def:DEFINE (#(NEW (GLOBAL)? SHARED ) | SHARED)? SUBMENU
-			id:ID { push(action.defineVariable(#def, #id)); }
+			id:ID { push(action.defineSymbol(SUBMENU, #def, #id)); }
 			(menu_opt)* (menu_list_item)* state_end
 		)
 		{ action.addToScope(pop()); }

Added: trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Browse.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Browse.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Browse.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,24 @@
+/* Created on May 3, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.prorefactor.widgettypes;
+
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.treeparser.SymbolScope;
+import org.prorefactor.treeparser.Widget;
+
+
+public class Browse extends Widget {
+
+	public Browse(String name, SymbolScope scope) { super(name, scope); }
+
+	/** Returns TokenTypes.BROWSE. */
+	public int getProgressType() { return TokenTypes.BROWSE; }
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Button.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Button.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Button.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,24 @@
+/* Created on May 3, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.prorefactor.widgettypes;
+
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.treeparser.SymbolScope;
+import org.prorefactor.treeparser.Widget;
+
+
+public class Button extends Widget {
+
+	public Button(String name, SymbolScope scope) { super(name, scope); }
+
+	/** Returns TokenTypes.BUTTON. */
+	public int getProgressType() { return TokenTypes.BUTTON; }
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Frame.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Frame.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Frame.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,24 @@
+/* Created on May 3, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.prorefactor.widgettypes;
+
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.treeparser.SymbolScope;
+import org.prorefactor.treeparser.Widget;
+
+
+public class Frame extends Widget {
+
+	public Frame(String name, SymbolScope scope) { super(name, scope); }
+
+	/** Returns TokenTypes.FRAME. */
+	public int getProgressType() { return TokenTypes.FRAME; }
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Image.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Image.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Image.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,24 @@
+/* Created on May 3, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.prorefactor.widgettypes;
+
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.treeparser.SymbolScope;
+import org.prorefactor.treeparser.Widget;
+
+
+public class Image extends Widget {
+
+	public Image(String name, SymbolScope scope) { super(name, scope); }
+
+	/** Returns TokenTypes.IMAGE. */
+	public int getProgressType() { return TokenTypes.IMAGE; }
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Menu.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Menu.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Menu.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,24 @@
+/* Created on May 3, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.prorefactor.widgettypes;
+
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.treeparser.SymbolScope;
+import org.prorefactor.treeparser.Widget;
+
+
+public class Menu extends Widget {
+
+	public Menu(String name, SymbolScope scope) { super(name, scope); }
+
+	/** Returns TokenTypes.MENU. */
+	public int getProgressType() { return TokenTypes.MENU; }
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/MenuItem.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/MenuItem.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/MenuItem.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,24 @@
+/* Created on May 3, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.prorefactor.widgettypes;
+
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.treeparser.SymbolScope;
+import org.prorefactor.treeparser.Widget;
+
+
+public class MenuItem extends Widget {
+
+	public MenuItem(String name, SymbolScope scope) { super(name, scope); }
+
+	/** Returns TokenTypes.MENUITEM. */
+	public int getProgressType() { return TokenTypes.MENUITEM; }
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Rectangle.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Rectangle.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Rectangle.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,24 @@
+/* Created on May 3, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.prorefactor.widgettypes;
+
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.treeparser.SymbolScope;
+import org.prorefactor.treeparser.Widget;
+
+
+public class Rectangle extends Widget {
+
+	public Rectangle(String name, SymbolScope scope) { super(name, scope); }
+
+	/** Returns TokenTypes.RECTANGLE. */
+	public int getProgressType() { return TokenTypes.RECTANGLE; }
+
+}

Added: trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Submenu.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Submenu.java	2005-05-02 18:58:48 UTC (rev 22)
+++ trunk/org.prorefactor.core/src/org/prorefactor/widgettypes/Submenu.java	2005-05-04 21:17:51 UTC (rev 23)
@@ -0,0 +1,24 @@
+/* Created on May 3, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+package org.prorefactor.widgettypes;
+
+import org.prorefactor.core.TokenTypes;
+import org.prorefactor.treeparser.SymbolScope;
+import org.prorefactor.treeparser.Widget;
+
+
+public class Submenu extends Widget {
+
+	public Submenu(String name, SymbolScope scope) { super(name, scope); }
+
+	/** Returns TokenTypes.SUBMENU. */
+	public int getProgressType() { return TokenTypes.SUBMENU; }
+
+}



From johnallengreen at sheep.berlios.de  Thu May  5 20:46:29 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Thu, 5 May 2005 20:46:29 +0200
Subject: [Prorefactor-svn] r24 - in trunk: org.prorefactor.core/src/org/prorefactor/treeparser01 org.prorefactor.refactor/data/pub org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/pub org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/rename/t01/orig org.prorefactor.refactor/src/org/prorefactor/refactor org.prorefactor.refactor/src/org/prorefactor/refactor/unittest
Message-ID: <200505051846.j45IkTp0001255@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-05 20:46:27 +0200 (Thu, 05 May 2005)
New Revision: 24

Modified:
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Action.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01.java
   trunk/org.prorefactor.refactor/data/pub/test01.p
   trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/pub/test01.p.pub
   trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/rename/t01/orig/t01.p.pub
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/unittest/PUBTest.java
Log:
Good grief. I forgot to rebuild TreeParser01 before committing my changes related to Symbol subtypes. Done now, and fixed a bug with that.
Added initial import/export tables to the Parse Unit Binaries. Currently, just tables of symbols defined with SHARED and NEW SHARED.

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Action.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Action.java	2005-05-04 21:17:51 UTC (rev 23)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Action.java	2005-05-05 18:46:27 UTC (rev 24)
@@ -75,7 +75,7 @@
 	/** Called by the tree parser to define anything other than
 	 * buffers, temp/work tables, and variables/parameters.
 	 */
-	public Symbol defineSymbol(AST defAST, AST idAST, int symbolType) { return null; }
+	public Symbol defineSymbol(int symbolType, AST defAST, AST idAST) { return null; }
 
 	
 	/** Called by the tree parser at a temp or work table field definition. */

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java	2005-05-04 21:17:51 UTC (rev 23)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TP01Support.java	2005-05-05 18:46:27 UTC (rev 24)
@@ -99,7 +99,7 @@
 
 	
 	public void addToScope(Object o) {
-		currentScope.add((Variable)o);
+		currentScope.add((Symbol)o);
 	}
 
 	
@@ -227,7 +227,7 @@
 
 
 
-	public Symbol defineSymbol(AST defAST, AST idAST, int symbolType) {
+	public Symbol defineSymbol(int symbolType, AST defAST, AST idAST) {
 		/* Some notes:
 		 * We need to create the Symbol right away, because further
 		 * actions in the grammar might need to set attributes on it.

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01.java	2005-05-04 21:17:51 UTC (rev 23)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01.java	2005-05-05 18:46:27 UTC (rev 24)
@@ -10322,7 +10322,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(BROWSE, def, id));
 		}
 		{
 		if (_t==null) _t=ASTNULL;
@@ -10991,7 +10991,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(BUTTON, def, id));
 		}
 		{
 		_loop813:
@@ -11426,7 +11426,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(DATASET, def, id));
 		}
 		AST tmp729_AST_in = (AST)_t;
 		match(_t,FOR);
@@ -11584,7 +11584,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(DATASOURCE, def, id));
 		}
 		AST tmp737_AST_in = (AST)_t;
 		match(_t,FOR);
@@ -11732,7 +11732,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(FRAME, def, id));
 		}
 		{
 		_loop857:
@@ -11955,7 +11955,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(IMAGE, def, id));
 		}
 		{
 		_loop880:
@@ -12178,7 +12178,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(MENU, def, id));
 		}
 		{
 		_loop888:
@@ -12732,7 +12732,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(QUERY, def, id));
 		}
 		AST tmp797_AST_in = (AST)_t;
 		match(_t,FOR);
@@ -12924,7 +12924,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(RECTANGLE, def, id));
 		}
 		{
 		_loop973:
@@ -13135,7 +13135,7 @@
 		_t = __t976;
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			action.addToScope(action.defineVariable(def, id));
+			action.addToScope(action.defineSymbol(STREAM, def, id));
 		}
 		_retTree = _t;
 	}
@@ -13210,7 +13210,7 @@
 		match(_t,ID);
 		_t = _t.getNextSibling();
 		if ( inputState.guessing==0 ) {
-			push(action.defineVariable(def, id));
+			push(action.defineSymbol(SUBMENU, def, id));
 		}
 		{
 		_loop986:
@@ -44070,7 +44070,7 @@
 			match(_t,ID);
 			_t = _t.getNextSibling();
 			if ( inputState.guessing==0 ) {
-				push(action.defineVariable(id, id));
+				push(action.defineSymbol(MENUITEM, id, id));
 			}
 			{
 			_loop902:
@@ -44181,7 +44181,7 @@
 			match(_t,ID);
 			_t = _t.getNextSibling();
 			if ( inputState.guessing==0 ) {
-				push(action.defineVariable(id2, id2));
+				push(action.defineSymbol(SUBMENU, id2, id2));
 			}
 			{
 			_loop907:

Modified: trunk/org.prorefactor.refactor/data/pub/test01.p
===================================================================
--- trunk/org.prorefactor.refactor/data/pub/test01.p	2005-05-04 21:17:51 UTC (rev 23)
+++ trunk/org.prorefactor.refactor/data/pub/test01.p	2005-05-05 18:46:27 UTC (rev 24)
@@ -1,6 +1,7 @@
 /* test01.p - test file for "parse unit binary" unit tests.
  */
 
+def shared var sharedChar as char.
 def new shared frame myFrame.
 
 def var myChar as char no-undo.

Modified: trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/pub/test01.p.pub
===================================================================
(Binary files differ)

Modified: trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/rename/t01/orig/t01.p.pub
===================================================================
(Binary files differ)

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java	2005-05-04 21:17:51 UTC (rev 23)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java	2005-05-05 18:46:27 UTC (rev 24)
@@ -4,7 +4,7 @@
  * Sep 1, 2004
  * www.joanju.com
  *
- * Copyright (C) 2004 Joanju Limited.
+ * Copyright (C) 2004-2005 Joanju Limited.
  * All rights reserved. This program and the accompanying materials 
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -26,6 +26,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.List;
 import java.util.TreeMap;
 
 import org.prorefactor.core.IConstants;
@@ -33,7 +34,7 @@
 import org.prorefactor.core.schema.Table;
 import org.prorefactor.refactor.source.CompileUnit;
 import org.prorefactor.treeparser.FieldBuffer;
-import org.prorefactor.treeparser.SymbolScopeRoot;
+import org.prorefactor.treeparser.Symbol;
 import org.prorefactor.treeparser.TableBuffer;
 
 import com.joanju.ProparseLdr;
@@ -54,7 +55,7 @@
 		pubFile = new File(refpack.getProRefactorProjectDir() + "/pubs/" + relPath + ".pub");
 	}
 	
-	public static final int LAYOUT_VERSION = 1;
+	public static final int LAYOUT_VERSION = 2;
 
 	/** loadTo(PUBFILE_TIMESTAMP) - just check if the binary exists and
 	 * check that it is newer than the compile unit file. Does not read anything
@@ -76,24 +77,42 @@
 	/** loadTo(END) - all binary file segments will be loaded. */
 	public static final int END = 100;
 
+	private ArrayList exportList;
 	private ArrayList fileList;
+	private ArrayList importList;
 	private File cuFile;
 	private File pubFile;
 	private ProparseLdr parser = ProparseLdr.getInstance();
 	private RefactorSession refpack = RefactorSession.getInstance();
 	private TreeMap tableMap;
+
+	/** A record of symbol type and name, for import/export tables. */
+	public class SymbolRef {
+		SymbolRef(int progressType, String symbolName) {
+			this.progressType = progressType;
+			this.symbolName = symbolName;
+		}
+		/** The TokenType, ex: TokenTypes.VARIABLE */
+		public int progressType;
+		/** The symbol name (Symbol.fullName), with caseAsDefined. */
+		public String symbolName;
+	}
 	
 	private class TableRef {
 		TableRef(String name) { this.name = name; }
 		String name;
 		TreeMap fieldMap = new TreeMap();
 	}
+
 	
+	
 	/** It's possible, maybe even sensible, to reuse a PUB object.
 	 * This method clears out old lists in preparation for reloading or rebuilding.
 	 */
 	private void _refresh() {
+		exportList = new ArrayList();
 		fileList = new ArrayList();
+		importList = new ArrayList();
 		tableMap = new TreeMap();
 	}
 
@@ -115,7 +134,10 @@
 		ObjectOutputStream out = new ObjectOutputStream(fileOut);
 		writeVersion(out);
 		writeFileIndex(out);
-		writeSchemaSegment(out, cu.getRootScope());
+		ArrayList allSymbols = cu.getRootScope().getAllSymbols();
+		writeSchemaSegment(out, allSymbols);
+		writeImportSegment(out, allSymbols);
+		writeExportSegment(out, allSymbols);
 		out.close();
 		return cu;
 	}
@@ -153,6 +175,17 @@
 	}
 	
 	
+	
+	/** Get the array of exported symbols, in no particular order.
+	 * Currently just for DEF NEW [GLOBAL] SHARED symbols.
+	 */
+	public SymbolRef [] getExportTable() {
+		SymbolRef [] ret = new SymbolRef[exportList.size()];
+		exportList.toArray(ret);
+		return ret;
+	}
+	
+	
 
 	/** Get the array of file names. The file at index zero is always the compile unit.
 	 * The others are include files. The array index position corresponds to JPNode.getFileIndex().
@@ -166,6 +199,17 @@
 	
 	
 	
+	/** Get the array of imported symbols, in no particular order.
+	 * Currently just for DEF SHARED symbols.
+	 */
+	public SymbolRef [] getImportTable() {
+		SymbolRef [] ret = new SymbolRef[importList.size()];
+		importList.toArray(ret);
+		return ret;
+	}
+	
+	
+
 	private ObjectInputStream getObjectInputStream() {
 		try {
 			InputStream fileIn = new BufferedInputStream(new FileInputStream(pubFile));
@@ -205,6 +249,10 @@
 			if (lastSegmentToLoad==PUB.HEADER) return true;
 			readSchema(inStream);
 			if (lastSegmentToLoad==PUB.SCHEMA) return true;
+			readImportSegment(inStream);
+			if (lastSegmentToLoad==PUB.IMPORTS) return true;
+			readExportSegment(inStream);
+			if (lastSegmentToLoad==PUB.EXPORTS) return true;
 		} catch (IOException e1) {
 			return false;
 		} finally {
@@ -215,6 +263,16 @@
 	
 	
 	
+	private void readExportSegment(ObjectInputStream in) throws IOException {
+		for (;;) {
+			SymbolRef symbolRef = new SymbolRef(in.readInt(), in.readUTF());
+			if (symbolRef.progressType == -1) break;
+			exportList.add(symbolRef);
+		}
+	}
+	
+
+	
 	private void readFileIndex(ObjectInputStream in) throws IOException {
 		int index;
 		String filename;
@@ -228,6 +286,16 @@
 	
 	
 	
+	private void readImportSegment(ObjectInputStream in) throws IOException {
+		for (;;) {
+			SymbolRef symbolRef = new SymbolRef(in.readInt(), in.readUTF());
+			if (symbolRef.progressType == -1) break;
+			importList.add(symbolRef);
+		}
+	}
+	
+
+	
 	private void readSchema(ObjectInputStream in) throws IOException {
 		for (;;) {
 			String tableName = in.readUTF();
@@ -266,6 +334,20 @@
 	
 	
 	
+	private void writeExportSegment(ObjectOutputStream out, List allSymbols) throws IOException {
+		for (Iterator it = allSymbols.iterator(); it.hasNext();) {
+			Symbol symbol = (Symbol) it.next();
+			if (symbol.isExported()) {
+				out.writeInt(symbol.getProgressType());
+				out.writeUTF(symbol.fullName()); // We write caseAsDefined
+			}
+		}
+		out.writeInt(-1);
+		out.writeUTF("");
+	}
+	
+	
+	
 	private void writeFileIndex(ObjectOutputStream out) throws IOException {
 		String [] files = parser.getFilenameArray();
 		for (int i = 0; i < files.length; i++) {
@@ -278,9 +360,22 @@
 	
 	
 	
-	private void writeSchemaSegment(ObjectOutputStream out, SymbolScopeRoot rootScope) throws IOException {
-		ArrayList allSymbols = rootScope.getAllSymbols();
+	private void writeImportSegment(ObjectOutputStream out, List allSymbols) throws IOException {
 		for (Iterator it = allSymbols.iterator(); it.hasNext();) {
+			Symbol symbol = (Symbol) it.next();
+			if (symbol.isImported()) {
+				out.writeInt(symbol.getProgressType());
+				out.writeUTF(symbol.fullName()); // We write caseAsDefined
+			}
+		}
+		out.writeInt(-1);
+		out.writeUTF("");
+	}
+	
+	
+	
+	private void writeSchemaSegment(ObjectOutputStream out, List allSymbols) throws IOException {
+		for (Iterator it = allSymbols.iterator(); it.hasNext();) {
 			Object obj = it.next();
 			if (obj instanceof TableBuffer) {
 				Table table = ((TableBuffer)obj).getTable();

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/unittest/PUBTest.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/unittest/PUBTest.java	2005-05-04 21:17:51 UTC (rev 23)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/unittest/PUBTest.java	2005-05-05 18:46:27 UTC (rev 24)
@@ -15,6 +15,7 @@
 import java.io.File;
 import java.util.ArrayList;
 
+import org.prorefactor.core.TokenTypes;
 import org.prorefactor.core.unittest.UnitTestBase2;
 import org.prorefactor.refactor.PUB;
 import org.prorefactor.refactor.RefactorSession;
@@ -72,6 +73,18 @@
 		assertTrue(fields.size() == 1);
 		assertTrue(fields.get(0).toString().equals("name"));
 
+		// Test the import table.
+		PUB.SymbolRef [] imports = pub.getImportTable();
+		PUB.SymbolRef imp = imports[0];
+		assertTrue(imp.progressType == TokenTypes.VARIABLE);
+		assertTrue(imp.symbolName.equals("sharedChar"));
+		
+		// Test the export table.
+		PUB.SymbolRef [] exports = pub.getExportTable();
+		PUB.SymbolRef exp = exports[0];
+		assertTrue(exp.progressType == TokenTypes.FRAME);
+		assertTrue(exp.symbolName.equals("myFrame"));
+		
 	}
 
 }



From johnallengreen at sheep.berlios.de  Thu May  5 20:49:59 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Thu, 5 May 2005 20:49:59 +0200
Subject: [Prorefactor-svn] r25 - in trunk: org.prorefactor.antlr org.prorefactor.core
Message-ID: <200505051849.j45Inxp4001588@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-05 20:49:58 +0200 (Thu, 05 May 2005)
New Revision: 25

Modified:
   trunk/org.prorefactor.antlr/
   trunk/org.prorefactor.core/
Log:
Ignore some files/folders created at build time.


Property changes on: trunk/org.prorefactor.antlr
___________________________________________________________________
Name: svn:ignore
   - bin
antlrsrc.zip

   + bin
antlrsrc.zip
antlr.jar
temp.folder
build.xml



Property changes on: trunk/org.prorefactor.core
___________________________________________________________________
Name: svn:ignore
   - bin
coresrc.zip

   + bin
coresrc.zip
temp.folder
core.jar
build.xml




From johnallengreen at sheep.berlios.de  Fri May  6 22:42:59 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Fri, 6 May 2005 22:42:59 +0200
Subject: [Prorefactor-svn] r26 - in trunk/org.prorefactor.lib: . hibernate jakarta jakarta/commons-collections
Message-ID: <200505062042.j46Kgx82016409@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-06 22:42:56 +0200 (Fri, 06 May 2005)
New Revision: 26

Added:
   trunk/org.prorefactor.lib/jakarta/commons-collections/
   trunk/org.prorefactor.lib/jakarta/commons-collections/LICENSE.txt
   trunk/org.prorefactor.lib/jakarta/commons-collections/RELEASE-NOTES.html
   trunk/org.prorefactor.lib/jakarta/commons-collections/commons-collections.jar
   trunk/org.prorefactor.lib/jakarta/commons-collections/src.zip
Removed:
   trunk/org.prorefactor.lib/hibernate/commons-collections-2.1.1.jar
   trunk/org.prorefactor.lib/jakarta/commons-io-1.0/
Modified:
   trunk/org.prorefactor.lib/.classpath
   trunk/org.prorefactor.lib/build.properties
   trunk/org.prorefactor.lib/plugin.xml
Log:
Remembered how to properly associate a jar libraries source with the jar file, which allowed me to remove the source files for commons-io.
Updated commons-collections to version 3.1.

Modified: trunk/org.prorefactor.lib/.classpath
===================================================================
--- trunk/org.prorefactor.lib/.classpath	2005-05-05 18:49:58 UTC (rev 25)
+++ trunk/org.prorefactor.lib/.classpath	2005-05-06 20:42:56 UTC (rev 26)
@@ -1,11 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="jakarta/commons-io-1.0/src/java"/>
 	<classpathentry exported="true" kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/cglib-full-2.0.2.jar"/>
 	<classpathentry exported="true" kind="lib" path="hsqldb/hsqldb.jar"/>
-	<classpathentry exported="true" kind="lib" path="hibernate/commons-collections-2.1.1.jar"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/commons-lang-1.0.1.jar"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/commons-logging-1.0.4.jar"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/dom4j-1.4.jar"/>
@@ -15,5 +13,7 @@
 	<classpathentry exported="true" kind="lib" path="hibernate/odmg-3.0.jar"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/xerces-2.4.0.jar"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/xml-apis.jar"/>
+	<classpathentry exported="true" sourcepath="jakarta/commons-collections/src.zip" kind="lib" path="jakarta/commons-collections/commons-collections.jar"/>
+	<classpathentry exported="true" sourcepath="jakarta/commons-io/src.zip" kind="lib" path="jakarta/commons-io/commons-io.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: trunk/org.prorefactor.lib/build.properties
===================================================================
--- trunk/org.prorefactor.lib/build.properties	2005-05-05 18:49:58 UTC (rev 25)
+++ trunk/org.prorefactor.lib/build.properties	2005-05-06 20:42:56 UTC (rev 26)
@@ -8,7 +8,8 @@
                hsqldb/,\
                jakarta/,\
                readme.txt,\
-               bin/
+               bin/,\
+               prorefactor.lib.jar
 src.includes = .classpath,\
                .project,\
                build.properties,\
@@ -33,4 +34,6 @@
                readme.txt,\
                jakarta/,\
                bin/
-jars.compile.order = 
+jars.compile.order = prorefactor.lib.jar
+source.prorefactor.lib.jar = jakarta/commons-io-1.0/src/
+output.prorefactor.lib.jar = bin/

Deleted: trunk/org.prorefactor.lib/hibernate/commons-collections-2.1.1.jar
===================================================================
(Binary files differ)

Added: trunk/org.prorefactor.lib/jakarta/commons-collections/LICENSE.txt
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-collections/LICENSE.txt	2005-05-05 18:49:58 UTC (rev 25)
+++ trunk/org.prorefactor.lib/jakarta/commons-collections/LICENSE.txt	2005-05-06 20:42:56 UTC (rev 26)
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.

Added: trunk/org.prorefactor.lib/jakarta/commons-collections/RELEASE-NOTES.html
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-collections/RELEASE-NOTES.html	2005-05-05 18:49:58 UTC (rev 25)
+++ trunk/org.prorefactor.lib/jakarta/commons-collections/RELEASE-NOTES.html	2005-05-06 20:42:56 UTC (rev 26)
@@ -0,0 +1,126 @@
+ <!--
+   Copyright 2003-2004 The Apache Software Foundation
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+  -->
+<title>RELEASE NOTES: COLLECTIONS 3.1</title>
+
+<center><h2>RELEASE NOTES: COLLECTIONS 3.1</h2></center>
+
+<p>
+This release adds various new classes and fixes a number of bugs.
+All feedback should be directed to commons-user at jakarta.apache.org.
+
+<hr />
+
+<center><h3>COMPATABILITY</h3></center>
+<p>
+This release is fully source and binary compatible with v3.0.
+(Checks performed using JDiff and Clirr, thanks).
+</p>
+<p>
+The only new deprecations are in AbstractDualBidiMap.
+These only impact non commons-collections subclasses, and existing code will still work.
+</p>
+<p>
+This release also enables a workaround of the binary compatability issue with IteratorUtils in v3.0.
+Collections v2.1.1 (with deprecations solved) and v3.1 are compatible with regards to iterators.
+</p>
+
+<center><h3>NEW CLASSES</h3></center>
+<ul>
+<li>TreeList - A list implementation that is faster than ArrayList for insertions and removals</li>
+<li>MultiKeyMap - A map that allows multiple keys to be used to map the value</li>
+<li>SingletonMap - fully featured singleton Map implementation</li>
+<li>ObjectGraphIterator - An iterator that can iterate over a graph of objects</li>
+<li>MapBackedSet - Set created by decorating a map</li>
+<li>ReferenceIdentityMap - Similar to ReferenceMap, but matching keys and values by identity [26503]</li>
+<li>AbstractReferenceMap - New base class for reference maps [26503]</li>
+<li>Empty*Iterator - Iterators over empty collections</li>
+<li>TransformedPredicate - A predicate where the input object is transformed [26946]</li>
+<li>PredicateDecorator - An interface to provide a uniform interface to the decorated predicates</li>
+<li>AbstractSerializable*Decorator - Abstract classes for decorators that are Serializable</li>
+</ul>
+
+<center><h3>ENHANCEMENTS</h3></center>
+<ul>
+<li>ReferenceMap - Changed to extend AbstractReferenceMap, thus gaining a mapIterator() and subclassability [26503]</li>
+<li>Fast3Map - Add clone() method</li>
+<li>MultiKey - Add getKey(index) and size() methods and make constructor public</li>
+<li>MultiHashMap - Add five methods to improve the API</li>
+<li>AbstractHashedMap,AbstractLinkedMap - Add methods to access entry methods when protected scope blocks</li>
+<li>Functors - Add get methods to retrieve internal state [27515]</li>
+<li>Functors - Add additional getInstance() methods for consistency [27856,27857]</li>
+<li>CollectionUtils - get(Object,int) method now supports primitive arrays</li>
+<li>CollectionUtils - cardinality() now works faster for Set and Bag instances [28629]</li>
+<li>CollectionUtils - Add size(Object) method to find the size of various collection-like objects [27909]</li>
+<li>SingletonIterator - make remove() functionality optional</li>
+<li>AbstractLinkedList/NodeCachingLinkedList - added getValue() and setValue() to Node, and made everything use them</li>
+<li>LRUMap - The addMapping() method now uses isFull() to determine whether it is full</li>
+<li>LRUMap - Add boolean flag, scanUntilRemovable, giving the removeLRU() method more power [28887]</li>
+<li>InvokerTransformer - Add additional getInstance() method</li>
+<li>Reduced inter-class and inter-package dependencies, especially via *Utils classes</li>
+<li>ListOrderedSet - Add new factory method decorate(Set,List)</li>
+<li>ListOrderedSet - Add public constructor that uses a HashSet and ArrayList</li>
+<li>ListOrderedMap - Add public constructor that uses a HashMap and ArrayList</li>
+</ul>
+
+<h4>Made Serializable</h4>
+<ul>
+<li>Fast3Map [27946]</li>
+<li>ReferenceMap</li>
+<li>UnboundedFifoBuffer</li>
+<li>BoundedFifoBuffer</li>
+<li>CircularFifoBuffer</li>
+<li>TiedMapEntry</li>
+<li>FixedSize* [18815]</li>
+<li>Predicated* [18815]</li>
+<li>Synchronized* [18815]</li>
+<li>Transformed* [18815]</li>
+<li>Typed* [18815]</li>
+<li>Unmodifiable* [18815]</li>
+<li>Lazy* [18815]</li>
+<li>ListOrdered* [18815]</li>
+<li>SetUniqueList [18815]</li>
+</ul>
+
+<center><h3>BUG FIXES</h3></center>
+<ul>
+<li>Map/BidiMap implementations only checked key and not value in entry set contains(Object) and remove(Object)</li>
+<li>AbstractHashedMap subclasses failed to clone() correctly [27159]</li>
+<li>ExtendedProperties - Close input stream in constructor [27737]</li>
+<li>ExtendedProperties - Handle comma separated data in multiple keys</li>
+<li>Flat3Map - Handle infinite loops in toString</li>
+<li>LRUMap - The removeLRU() method was passed the wrong LinkEntry [28433]</li>
+<li>EnumIterator/MapUtils - Changed enum references to enable JDK 1.5 compliance</li>
+<li>UnmodifiableSortedBag - Fix to ensure unmodifiable</li>
+<li>MultiHashMap - Fix copy constructor and clone to work properly [28972]</li>
+<li>ListOrderedSet - Fix to throw IllegalArgumentException instead of NPE on null factory decorate(List)</li>
+<li>*Dual*BidiMap - Fix poorly designed subclass method call from superclass constructor [29519]</li>
+</ul>
+
+<center><h3>JAVADOC</h3></center>
+<ul>
+<li>Bag - Indicate that no changes are likely to the interface despite its problems</li>
+<li>TreeBidiMap - Add javadoc about requiring Comparable entries [26470]</li>
+<li>MultiKey - Add extra explanatations, examples and warnings</li>
+<li>MultiMap,MultiHashMap - Add extra documentation to clarify the interface and implementation</li>
+<li>XxxUtils - Clarify the internal workings of the predicated decorator classes [28115]</li>
+<li>BidiMap - Clarify 1 to 1 nature of the map</li>
+<li>AbstractHashedMap - Fix isEqualValue() javadoc to refer to value not key</li>
+<li>LRUMap - Added extra javadoc about method implementations</li>
+<li>BoundedCollection/UnmodifiableBoundedCollection - reword to avoid misunderstandings</li>
+<li>Closure/Predicate/Transformer/Factory - Additional javadoc with links</li>
+<li>ClosureUtils/PredicateUtils/TransformerUtils/FactoryUtils - Additional links to implementations</li>
+<li>Predicated* - Additional usage explanation [29018]</li>
+</ul>

Added: trunk/org.prorefactor.lib/jakarta/commons-collections/commons-collections.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-collections/commons-collections.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/jakarta/commons-collections/src.zip
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-collections/src.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/org.prorefactor.lib/plugin.xml
===================================================================
--- trunk/org.prorefactor.lib/plugin.xml	2005-05-05 18:49:58 UTC (rev 25)
+++ trunk/org.prorefactor.lib/plugin.xml	2005-05-06 20:42:56 UTC (rev 26)
@@ -13,9 +13,6 @@
       <library name="hsqldb/hsqldb.jar">
          <export name="*"/>
       </library>
-      <library name="hibernate/commons-collections-2.1.1.jar">
-         <export name="*"/>
-      </library>
       <library name="hibernate/commons-lang-1.0.1.jar">
          <export name="*"/>
       </library>
@@ -43,9 +40,15 @@
       <library name="hibernate/xml-apis.jar">
          <export name="*"/>
       </library>
-      <library name="jakarta/commons-io-1.0/commons-io-1.0.jar">
+      <library name="prorefactor.lib.jar">
          <export name="*"/>
       </library>
+      <library name="jakarta/commons-collections/commons-collections.jar">
+         <export name="*"/>
+      </library>
+      <library name="jakarta/commons-io/commons-io.jar">
+         <export name="*"/>
+      </library>
    </runtime>
 
 </plugin>



From johnallengreen at sheep.berlios.de  Fri May  6 23:01:37 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Fri, 6 May 2005 23:01:37 +0200
Subject: [Prorefactor-svn] r27 - in trunk/org.prorefactor.lib/jakarta: . commons-io
Message-ID: <200505062101.j46L1b08017300@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-06 23:01:36 +0200 (Fri, 06 May 2005)
New Revision: 27

Added:
   trunk/org.prorefactor.lib/jakarta/commons-io/
   trunk/org.prorefactor.lib/jakarta/commons-io/LICENSE.txt
   trunk/org.prorefactor.lib/jakarta/commons-io/commons-io.jar
   trunk/org.prorefactor.lib/jakarta/commons-io/src.zip
   trunk/org.prorefactor.lib/jakarta/commons-io/version.txt
Log:
Re-added commons-io.

Added: trunk/org.prorefactor.lib/jakarta/commons-io/LICENSE.txt
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io/LICENSE.txt	2005-05-06 20:42:56 UTC (rev 26)
+++ trunk/org.prorefactor.lib/jakarta/commons-io/LICENSE.txt	2005-05-06 21:01:36 UTC (rev 27)
@@ -0,0 +1,203 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+

Added: trunk/org.prorefactor.lib/jakarta/commons-io/commons-io.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-io/commons-io.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/jakarta/commons-io/src.zip
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-io/src.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/jakarta/commons-io/version.txt
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-io/version.txt	2005-05-06 20:42:56 UTC (rev 26)
+++ trunk/org.prorefactor.lib/jakarta/commons-io/version.txt	2005-05-06 21:01:36 UTC (rev 27)
@@ -0,0 +1 @@
+Jakarta Commons IO Version 1.0



From johnallengreen at sheep.berlios.de  Fri May 13 23:40:07 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Fri, 13 May 2005 23:40:07 +0200
Subject: [Prorefactor-svn] r29 - in trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data: pub rename/t01/orig
Message-ID: <200505132140.j4DLe7Ld029872@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-13 23:40:06 +0200 (Fri, 13 May 2005)
New Revision: 29

Modified:
   trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/pub/test01.p.pub
   trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/rename/t01/orig/t01.p.pub
Log:
Commit binaries missed from last checkin.

Modified: trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/pub/test01.p.pub
===================================================================
(Binary files differ)

Modified: trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/rename/t01/orig/t01.p.pub
===================================================================
(Binary files differ)



From johnallengreen at sheep.berlios.de  Fri May 13 23:38:00 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Fri, 13 May 2005 23:38:00 +0200
Subject: [Prorefactor-svn] r28 - in trunk: org.prorefactor.core org.prorefactor.core/src/org/prorefactor/core org.prorefactor.core/src/org/prorefactor/nodetypes org.prorefactor.core/src/org/prorefactor/treeparserbase org.prorefactor.lib org.prorefactor.lib/jakarta org.prorefactor.lib/jakarta/commons-lang org.prorefactor.refactor org.prorefactor.refactor/src/org/prorefactor/refactor org.prorefactor.refactor/src/org/prorefactor/refactor/unittest
Message-ID: <200505132138.j4DLc0nS029801@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-13 23:37:59 +0200 (Fri, 13 May 2005)
New Revision: 28

Added:
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/ProparseDirectiveNode.java
   trunk/org.prorefactor.lib/jakarta/commons-lang/
   trunk/org.prorefactor.lib/jakarta/commons-lang/LICENSE.txt
   trunk/org.prorefactor.lib/jakarta/commons-lang/RELEASE-NOTES.txt
   trunk/org.prorefactor.lib/jakarta/commons-lang/commons-lang.jar
   trunk/org.prorefactor.lib/jakarta/commons-lang/src.zip
Modified:
   trunk/org.prorefactor.core/.classpath
   trunk/org.prorefactor.core/plugin.xml
   trunk/org.prorefactor.core/src/org/prorefactor/core/IConstants.java
   trunk/org.prorefactor.core/src/org/prorefactor/core/JPNode.java
   trunk/org.prorefactor.core/src/org/prorefactor/core/TokenTypes.java
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/BlockNode.java
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/NodeFactory.java
   trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/RecordNameNode.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.txt
   trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/ProParserTokenTypes.txt
   trunk/org.prorefactor.lib/.classpath
   trunk/org.prorefactor.lib/plugin.xml
   trunk/org.prorefactor.refactor/.classpath
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/unittest/PUBTest.java
Log:
Updated the libraries with more recent Jakarta Commons-Lang.
Added support for storing the syntax tree in the PUB files.
Changed TokenTypes to a static class instead of an interface. Added several static methods to it.


Modified: trunk/org.prorefactor.core/.classpath
===================================================================
--- trunk/org.prorefactor.core/.classpath	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/.classpath	2005-05-13 21:37:59 UTC (rev 28)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src/"/>
-	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry exported="true" kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: trunk/org.prorefactor.core/plugin.xml
===================================================================
--- trunk/org.prorefactor.core/plugin.xml	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/plugin.xml	2005-05-13 21:37:59 UTC (rev 28)
@@ -17,6 +17,7 @@
    <requires>
       <import plugin="org.junit" export="true"/>
       <import plugin="org.prorefactor.antlr" export="true"/>
+      <import plugin="org.prorefactor.lib" export="true"/>
    </requires>
 
 </plugin>

Modified: trunk/org.prorefactor.core/src/org/prorefactor/core/IConstants.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/core/IConstants.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/core/IConstants.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -106,5 +106,8 @@
 	/** A scanner token which is scheduled to be cut from the token list */
 	public int TO_BE_CUT = 11010;
 
+	
+	// Joanju uses 49000+ for scratch and otherwise non-persistent attributes.
 
+
 } // interface IConstants

Modified: trunk/org.prorefactor.core/src/org/prorefactor/core/JPNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/core/JPNode.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/core/JPNode.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -1,32 +1,29 @@
-/**
- * JPNode
- * @author John Green
- * October, 2002
- * www.joanju.com
+/** Created: October, 2002
+ * Authors: John Green
  * 
- * Copyright (c) 2002-2004 Joanju Limited.
+ * Copyright (c) 2002-2005 Joanju (www.joanju.com)
  * All rights reserved. This program and the accompanying materials 
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- * 
  */
 
 package org.prorefactor.core;
 
 
-import com.joanju.ProparseLdr;
+import java.util.ArrayList;
+import java.util.HashMap;
 
+import org.prorefactor.nodetypes.NodeFactory;
+
 import antlr.BaseAST;
 import antlr.Token;
 import antlr.collections.AST;
 
-import java.util.HashMap;
+import com.joanju.ProparseLdr;
 
-import org.prorefactor.nodetypes.NodeFactory;
 
 
-
 /**
  * Extension to antlr.BaseAST, which allows us to extract an
  * external "antlr" AST view of a Proparse AST, which we can
@@ -37,6 +34,8 @@
  */
 public class JPNode extends BaseAST implements IJPNode {
 
+	/** For creating from persistent storage */
+	public JPNode() { }
 
 	public JPNode(int handle) {
 		nodeHandle = handle;
@@ -62,12 +61,11 @@
 	/** Just an Integer object for the int IConstants.CONTEXT_QUALIFIER */
 	public static final Integer CONTEXT_QUALIFIER = new Integer(IConstants.CONTEXT_QUALIFIER);
 
+	
 	/** A valid value for setLink() and getLink() */
 	public static final Integer SYMBOL = new Integer(-210);
-
 	/** A valid value for setLink() and getLink() */
 	public static final Integer TETNode = new Integer(-211);
-
 	/** A valid value for setLink() and getLink().
 	 * Link to a BufferScope object, set by tp01 for RECORD_NAME nodes
 	 * and for Field_ref nodes for Field (not for Variable).
@@ -76,14 +74,16 @@
 	 * @see #BUFFERSYMBOL
 	 */
 	public static final Integer BUFFERSCOPE = new Integer(-212);
-
 	/** A valid value for setLink() and getLink().
 	 * You should not use this directly. Only JPNodes of subtype BlockNode
 	 * will have this set, so use BlockNode.getBlock instead.
 	 * @see org.prorefactor.nodetypes.BlockNode.
 	 */
 	public static final Integer BLOCK = new Integer(-214);
+	/** A valid value for setLink() and getLink() */
+	private static final Integer COMMENTS = new Integer(-215);
 
+	
 	static private ProparseLdr parser = ProparseLdr.getInstance();
 
 	private int column = -1;
@@ -114,6 +114,11 @@
 		 * Note that if "disconnected", this flag is meaningless.
 		 */
 		public boolean storePosition = false;
+		/** Store the comments?
+		 * By default, a "disconnected" tree does not store comments.
+		 * @see JPNode#getComments().
+		 */
+		public boolean storeComments = false;
 	} // class TreeConfig
 
 
@@ -148,9 +153,9 @@
 
 
 	//// Member funcs
-
-
-
+	
+	
+	
 	/** Get an attribute from proparse if connected, from JPNode if disconnected */
 	public int attrGet(int key) {
 		if (nodeHandle!=0) return parser.attrGetI(nodeHandle, key);
@@ -211,6 +216,8 @@
 			filename = config.filenames[fileIndex];
 			line = parser.getNodeLine(nodeHandle);
 			column = parser.getNodeColumn(nodeHandle);
+			if (config.storeComments) setComments(getComments());
+			// And, the final step in making this node "disconnected"...
 			nodeHandle = 0;
 		} else if (config.storePosition) {  // storePosition is meaningless if disconnected
 			fileIndex = parser.getNodeFileIndex(nodeHandle);
@@ -261,16 +268,16 @@
 	/**
 	 * First Natural Child is found by repeating firstChild() until a natural node is found.
 	 * If the start node is a natural node, then it is returned.
-	 * The test for "natural" node is line number. Synthetic node line numbers == 0.
 	 * Note: This is very different than Prolint's "NextNaturalNode" in lintsuper.p.
+	 * @see TokenTypes#isNatural(int)
 	 */
 	public JPNode firstNaturalChild() {
-		if (getLine()>0) return this;
-		for (JPNode n = (JPNode)getFirstChild(); n!=null; n = (JPNode)n.getFirstChild()) {
-			if (n.getLine()>0) return n;
+		if (TokenTypes.isNatural(getType())) return this;
+		for (JPNode n = firstChild(); n!=null; n = n.firstChild()) {
+			if (TokenTypes.isNatural(n.getType())) return n;
 		}
 		return null;
-	} // firstNaturalChild()
+	}
 
 
 
@@ -278,6 +285,42 @@
 		if (column == -1) return parser.getNodeColumn(nodeHandle);
 		return column;
 	}
+	
+	
+	
+	/** Get the comments that precede this node.
+	 * Gets the comments from Proparse if "connected", otherwise gets
+	 * the comments stored within this node object.
+	 * CAUTION: We want to know if line breaks exist between comments and nodes,
+	 * and if they exist between consecutive comments. To preserve that information,
+	 * the String returned here may have "\n" in front of the first comment,
+	 * may have "\n" separating comments, and may have "\n" appended to the
+	 * last comment. We do not preserve the number of newlines, nor do we
+	 * preserve any other whitespace.
+	 * @return null if no comments.
+	 */
+	public String getComments() {
+		if (nodeHandle==0) return (String) getLink(COMMENTS);
+		StringBuffer buff = new StringBuffer();
+		boolean newline = false;
+		for (	int isAvail = parser.hiddenGetFirst(nodeHandle)
+			;	isAvail>0
+			;	isAvail=parser.hiddenGetNext()
+			) {
+			if (	parser.hiddenGetType().equals("WS")
+				&&	parser.hiddenGetText().indexOf('\n') > -1
+				)
+				newline = true;
+			if (parser.hiddenGetType().equals("COMMENT")) {
+				if (newline) buff.append("\n");
+				buff.append(parser.hiddenGetText());
+			}
+		}
+		if (buff.length()==0) return null;
+		// Trailine newline(s)?
+		if (newline) buff.append("\n");
+		return buff.toString();
+	}
 
 
 
@@ -332,15 +375,34 @@
 	public int getState2() {
 		return attrGet(JPNode.STATE2);
 	}
+	
+	
+	/** Every JPNode subtype has its own index. Used for persistent storage. */
+	public int getSubtypeIndex() { return 1; }
 
 
 
 	private void initMap() {
 		if (attrMap==null) attrMap = new HashMap();
 	}
-
-
-
+	
+	
+	
+	/** Is this a natural node (from real source text)?
+	 * If not, then it is a synthetic node, added just for tree structure.
+	 * @see TokenTypes#isNatural(int)
+	 */
+	public boolean isNatural() { return TokenTypes.isNatural(type); }
+	
+	
+	
+	/** Does this node have the Proparse STATEHEAD attribute? */
+	public boolean isStateHead() {
+		return attrGet(IConstants.STATEHEAD) == IConstants.TRUE;
+	}
+	
+	
+	
 	/** Return the last immediate child (no grandchildren). */
 	public JPNode lastChild() {
 		JPNode ret = firstChild();
@@ -384,8 +446,38 @@
 		}
 		throw new AssertionError("JPNode.prevNode() failed - corrupt tree?");
 	}
+	
+	
+	
+	/** Get an array of all descendant nodes (including this node) of a given type.
+	 * Same idea as Proparse's "query" functions.
+	 */
+	public JPNode [] query(int type) {
+		ArrayList list = new ArrayList();
+		if (this.type == type) list.add(this);
+		queryHelper(this.firstChild(), type, list);
+		JPNode [] ret = new JPNode[list.size()];
+		list.toArray(ret);
+		return ret;
+	}
+	private static void queryHelper(JPNode node, int type, ArrayList list) {
+		if (node==null) return;
+		if (node.type == type) list.add(node);
+		queryHelper(node.firstChild(), type, list);
+		queryHelper(node.nextSibling(), type, list);
+	}
 
 
+
+	/** Set the comments preceding this node.
+	 * CAUTION: Does not change any values in Proparse. Only use this
+	 * if the JPNode tree is "disconnected", because getComments returns
+	 * the comments from the "hidden tokens" in Proparse in "connected" mode.
+	 */
+	public void setComments(String comments) { setLink(COMMENTS, comments); }
+
+	
+
 	/** @see #getLink(Integer) */
 	public void setLink(Integer key, Object value) {
 		if (attrMap==null) initMap(); 
@@ -394,9 +486,9 @@
 
 
 
-	private void setParentInChildren() {
-		for (AST child = getFirstChild(); child!=null; child = child.getNextSibling()) {
-			((JPNode)child).parent = this;
+	public void setParentInChildren() {
+		for (JPNode child = firstChild(); child!=null; child = child.nextSibling()) {
+			child.parent = this;
 		}
 	}
 

Modified: trunk/org.prorefactor.core/src/org/prorefactor/core/TokenTypes.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/core/TokenTypes.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/core/TokenTypes.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -2,7 +2,7 @@
  * Created on Nov 20, 2003
  * John Green
  *
- * Copyright (C) 2003 Joanju Limited
+ * Copyright (C) 2003, 2005 Joanju (www.joanju.com)
  * All rights reserved. This program and the accompanying materials 
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
@@ -12,10 +12,1054 @@
 
 import org.prorefactor.treeparserbase.JPTreeParserTokenTypes;
 
+import com.joanju.ProparseLdr;
+
 /**
- * Ick. This interface is just a hack to get us a nice short
- * interface to the token types that exist in the tree parsers.
- * I don't know of a more elegant way.
+ * This static class provides information about Proparse's token types
+ * as well as all of the static, final names for each token type.
  */
-public interface TokenTypes extends JPTreeParserTokenTypes {
+public class TokenTypes implements JPTreeParserTokenTypes {
+
+	private static TokenInfo [] allTokens = new TokenInfo[Last_Token_Number + 1];
+	private static ProparseLdr parser = ProparseLdr.getInstance();
+	
+	private static class TokenInfo {
+		boolean isNatural = true;
+		String keywordText = null;
+	}
+
+	static
+	{
+		for (int i = 0; i <= Last_Token_Number; i++) {
+			String typeName = parser.getTokenTypeName(i);
+			if (typeName.length()==0) continue;
+			TokenInfo info = new TokenInfo();
+			info.isNatural = typeName.equals(typeName.toUpperCase());
+			allTokens[i] = info;
+		}
+		
+		// Deal with Proparse's 10877/1087 token number issue.
+		TokenInfo info = new TokenInfo();
+		info.isNatural = true;
+		allTokens[1087] = info;
+
+		assignKeywordsText();
+	}
+	
+	private static TokenInfo getInfo(int tokenType) {
+		// One stupid mistake in Proparse's token numbers causes us headaches.
+		// Is an issue in Proparse 2.2b01, hopefully will be fixed next release.
+		if (tokenType == 10877) return allTokens[1087];
+		if (tokenType < 1 || tokenType > Last_Token_Number) return null;
+		return allTokens[tokenType];
+	}
+	
+	/** For integer token types that represent a keyword in the
+	 * syntax, this returns the full keyword text/name.
+	 * @return null if invalid token type or is not a keyword according to Proparse.
+	 * @see #isKeyword(int)
+	 */
+	public static String getKeywordText(int tokenType) {
+		TokenInfo info = getInfo(tokenType);
+		if (info==null) return null;
+		return info.keywordText;
+	}
+
+	/** Get the token name for this token type.
+	 * Uses ProparseLdr.getTokenTypeName(int tokenType), but returns
+	 * null if the input type is invalid.
+	 * @return null if invalid token type.
+	 * @see ProparseLdr#getTokenTypeName(int)
+	 */
+	public static String getTokenName(int tokenType) {
+		TokenInfo info = getInfo(tokenType);
+		if (info==null) return null;
+		return parser.getTokenTypeName(tokenType);
+	}
+	
+	/** A "natural" node is one that represents a real token in the
+	 * original source code. A "synthetic" token is one that was created
+	 * by the parser just for syntax tree organization.
+	 * By convention, a natural node has a node name that is ALLCAPS, and
+	 * a synthetic node has a node name which is Mixed_Case.
+	 */
+	public static boolean isNatural(int tokenType) {
+		TokenInfo info = getInfo(tokenType);
+		if (info==null) return false;
+		return info.isNatural;
+	}
+	
+	/** Proparse tracks keywords that are part of the syntax, but does not
+	 * track keywords that are only attribute/method names. DISPLAY is
+	 * a keyword type, ID is not.
+	 * See Proparse's node attribute documentation for NODE_TYPE_KEYWORD.
+	 */
+	public static boolean isKeyword(int tokenType) {
+		TokenInfo info = getInfo(tokenType);
+		if (info==null) return false;
+		return (info.keywordText != null);
+	}
+	
+	/** Is the integer a valid token type? */
+	public static boolean isValid(int tokenType) {
+		return (getInfo(tokenType) != null);
+	}
+
+	
+	private static void assignKeywordsText() {
+		allTokens[AACBIT].keywordText = "_CBIT";
+		allTokens[AACONTROL].keywordText = "_CONTROL";
+		allTokens[AALIST].keywordText = "_LIST";
+		allTokens[AAMEMORY].keywordText = "_MEMORY";
+		allTokens[AAMSG].keywordText = "_MSG";
+		allTokens[AAPCONTROL].keywordText = "_PCONTROL";
+		allTokens[AASERIAL].keywordText = "_SERIAL-NUM";
+		allTokens[AATRACE].keywordText = "_TRACE";
+		allTokens[ABSOLUTE].keywordText = "ABSOLUTE";
+		allTokens[ACCELERATOR].keywordText = "ACCELERATOR";
+		allTokens[ACCUMULATE].keywordText = "ACCUMULATE";
+		allTokens[ACTIVEWINDOW].keywordText = "ACTIVE-WINDOW";
+		allTokens[ADD].keywordText = "ADD";
+		allTokens[ADVISE].keywordText = "ADVISE";
+		allTokens[ALERTBOX].keywordText = "ALERT-BOX";
+		allTokens[ALIAS].keywordText = "ALIAS";
+		allTokens[ALL].keywordText = "ALL";
+		allTokens[ALLOWREPLICATION].keywordText = "ALLOW-REPLICATION";
+		allTokens[ALTER].keywordText = "ALTER";
+		allTokens[ALTERNATEKEY].keywordText = "ALTERNATE-KEY";
+		allTokens[AMBIGUOUS].keywordText = "AMBIGUOUS";
+		allTokens[ANALYZE].keywordText = "ANALYZE";
+		allTokens[AND].keywordText = "AND";
+		allTokens[ANSIONLY].keywordText = "ANSI-ONLY";
+		allTokens[ANY].keywordText = "ANY";
+		allTokens[ANYWHERE].keywordText = "ANYWHERE";
+		allTokens[APPEND].keywordText = "APPEND";
+		allTokens[APPLICATION].keywordText = "APPLICATION";
+		allTokens[APPLY].keywordText = "APPLY";
+		allTokens[ARRAYMESSAGE].keywordText = "ARRAY-MESSAGE";
+		allTokens[AS].keywordText = "AS";
+		allTokens[ASC].keywordText = "ASC";
+		allTokens[ASCENDING].keywordText = "ASCENDING";
+		allTokens[ASKOVERWRITE].keywordText = "ASK-OVERWRITE";
+		allTokens[ASSIGN].keywordText = "ASSIGN";
+		allTokens[ASYNCHRONOUS].keywordText = "ASYNCHRONOUS";
+		allTokens[AT].keywordText = "AT";
+		allTokens[ATTACHMENT].keywordText = "ATTACHMENT";
+		allTokens[ATTRSPACE].keywordText = "ATTR-SPACE";
+		allTokens[AUTHORIZATION].keywordText = "AUTHORIZATION";
+		allTokens[AUTOCOMPLETION].keywordText = "AUTO-COMPLETION";
+		allTokens[AUTOENDKEY].keywordText = "AUTO-END-KEY";
+		allTokens[AUTOGO].keywordText = "AUTO-GO";
+		allTokens[AUTOMATIC].keywordText = "AUTOMATIC";
+		allTokens[AUTORETURN].keywordText = "AUTO-RETURN";
+		allTokens[AVAILABLE].keywordText = "AVAILABLE";
+		allTokens[AVERAGE].keywordText = "AVERAGE";
+		allTokens[AVG].keywordText = "AVG";
+		allTokens[BACKGROUND].keywordText = "BACKGROUND";
+		allTokens[BACKWARDS].keywordText = "BACKWARDS";
+		allTokens[BASEKEY].keywordText = "BASE-KEY";
+		allTokens[BEFOREHIDE].keywordText = "BEFORE-HIDE";
+		allTokens[BEGINS].keywordText = "BEGINS";
+		allTokens[BELL].keywordText = "BELL";
+		allTokens[BETWEEN].keywordText = "BETWEEN";
+		allTokens[BGCOLOR].keywordText = "BGCOLOR";
+		allTokens[BIGENDIAN].keywordText = "BIG-ENDIAN";
+		allTokens[BINARY].keywordText = "BINARY";
+		allTokens[BINDWHERE].keywordText = "BIND-WHERE";
+		allTokens[BLANK].keywordText = "BLANK";
+		allTokens[BOTH].keywordText = "BOTH";
+		allTokens[BOTTOM].keywordText = "BOTTOM";
+		allTokens[BREAK].keywordText = "BREAK";
+		allTokens[BROWSE].keywordText = "BROWSE";
+		allTokens[BTOS].keywordText = "BTOS";
+		allTokens[BUFFER].keywordText = "BUFFER";
+		allTokens[BUFFERCHARS].keywordText = "BUFFER-CHARS";
+		allTokens[BUFFERCOMPARE].keywordText = "BUFFER-COMPARE";
+		allTokens[BUFFERCOPY].keywordText = "BUFFER-COPY";
+		allTokens[BUFFERLINES].keywordText = "BUFFER-LINES";
+		allTokens[BUFFERNAME].keywordText = "BUFFER-NAME";
+		allTokens[BUTTON].keywordText = "BUTTON";
+		allTokens[BUTTONS].keywordText = "BUTTONS";
+		allTokens[BY].keywordText = "BY";
+		allTokens[BYPOINTER].keywordText = "BY-POINTER";
+		allTokens[BYTE].keywordText = "BYTE";
+		allTokens[BYVARIANTPOINTER].keywordText = "BY-VARIANT-POINTER";
+		allTokens[CACHE].keywordText = "CACHE";
+		allTokens[CACHESIZE].keywordText = "CACHE-SIZE";
+		allTokens[CALL].keywordText = "CALL";
+		allTokens[CANDO].keywordText = "CAN-DO";
+		allTokens[CANFIND].keywordText = "CAN-FIND";
+		allTokens[CANQUERY].keywordText = "CAN-QUERY";
+		allTokens[CANSET].keywordText = "CAN-SET";
+		allTokens[CANCELBUTTON].keywordText = "CANCEL-BUTTON";
+		allTokens[CAPS].keywordText = "UPPER";
+		allTokens[CASE].keywordText = "CASE";
+		allTokens[CASESENSITIVE].keywordText = "CASE-SENSITIVE";
+		allTokens[CDECL_KW].keywordText = "CDECL";
+		allTokens[CENTERED].keywordText = "CENTERED";
+		allTokens[CHAINED].keywordText = "CHAINED";
+		allTokens[CHARACTER].keywordText = "CHARACTER";
+		allTokens[CHARACTERLENGTH].keywordText = "CHARACTERLENGTH";
+		allTokens[CHECK].keywordText = "CHECK";
+		allTokens[CHOOSE].keywordText = "CHOOSE";
+		allTokens[CHR].keywordText = "CHR";
+		allTokens[CLEAR].keywordText = "CLEAR";
+		allTokens[CLIPBOARD].keywordText = "CLIPBOARD";
+		allTokens[CLOSE].keywordText = "CLOSE";
+		allTokens[CODEBASELOCATOR].keywordText = "CODEBASE-LOCATOR";
+		allTokens[CODEPAGECONVERT].keywordText = "CODEPAGE-CONVERT";
+		allTokens[COLLATE].keywordText = "COLLATE";
+		allTokens[COLOF].keywordText = "COL-OF";
+		allTokens[COLON].keywordText = "COLON";
+		allTokens[COLONALIGNED].keywordText = "COLON-ALIGNED";
+		allTokens[COLOR].keywordText = "COLOR";
+		allTokens[COLORTABLE].keywordText = "COLOR-TABLE";
+		allTokens[COLUMN].keywordText = "COLUMN";
+		allTokens[COLUMNBGCOLOR].keywordText = "COLUMN-BGCOLOR";
+		allTokens[COLUMNDCOLOR].keywordText = "COLUMN-DCOLOR";
+		allTokens[COLUMNFGCOLOR].keywordText = "COLUMN-FGCOLOR";
+		allTokens[COLUMNFONT].keywordText = "COLUMN-FONT";
+		allTokens[COLUMNLABEL].keywordText = "COLUMN-LABEL";
+		allTokens[COLUMNOF].keywordText = "COLUMN-OF";
+		allTokens[COLUMNPFCOLOR].keywordText = "COLUMN-PFCOLOR";
+		allTokens[COLUMNS].keywordText = "COLUMNS";
+		allTokens[COMHANDLE].keywordText = "COMPONENT-HANDLE";
+		allTokens[COMBOBOX].keywordText = "COMBO-BOX";
+		allTokens[COMMAND].keywordText = "COMMAND";
+		allTokens[COMPARE].keywordText = "COMPARE";
+		allTokens[COMPARES].keywordText = "COMPARES";
+		allTokens[COMPLETE].keywordText = "COMPLETE";
+		allTokens[COMPILE].keywordText = "COMPILE";
+		allTokens[COMPILER].keywordText = "COMPILER";
+		allTokens[COMSELF].keywordText = "COM-SELF";
+		allTokens[CONFIGNAME].keywordText = "CONFIG-NAME";
+		allTokens[CONNECT].keywordText = "CONNECT";
+		allTokens[CONNECTED].keywordText = "CONNECTED";
+		allTokens[CONTAINS].keywordText = "CONTAINS";
+		allTokens[CONTENTS].keywordText = "CONTENTS";
+		allTokens[CONTEXT].keywordText = "CONTEXT";
+		allTokens[CONTEXTHELP].keywordText = "CONTEXT-HELP";
+		allTokens[CONTEXTHELPFILE].keywordText = "CONTEXT-HELP-FILE";
+		allTokens[CONTEXTHELPID].keywordText = "CONTEXT-HELP-ID";
+		allTokens[CONTEXTPOPUP].keywordText = "CONTEXT-POPUP";
+		allTokens[CONTROL].keywordText = "CONTROL";
+		allTokens[CONTROLFRAME].keywordText = "CONTROL-FRAME";
+		allTokens[CONVERT].keywordText = "CONVERT";
+		allTokens[CONVERT3DCOLORS].keywordText = "CONVERT-3D-COLORS";
+		allTokens[COUNT].keywordText = "COUNT";
+		allTokens[COUNTOF].keywordText = "COUNT-OF";
+		allTokens[CREATE].keywordText = "CREATE";
+		allTokens[CREATETESTFILE].keywordText = "CREATE-TEST-FILE";
+		allTokens[CURRENT].keywordText = "CURRENT";
+		allTokens[CURRENTCHANGED].keywordText = "CURRENT-CHANGED";
+		allTokens[CURRENTENVIRONMENT].keywordText = "CURRENT-ENVIRONMENT";
+		allTokens[CURRENTLANGUAGE].keywordText = "CURRENT-LANGUAGE";
+		allTokens[CURRENTRESULTROW].keywordText = "CURRENT-RESULT-ROW";
+		allTokens[CURRENTVALUE].keywordText = "CURRENT-VALUE";
+		allTokens[CURRENTWINDOW].keywordText = "CURRENT-WINDOW";
+		allTokens[CURSOR].keywordText = "CURSOR";
+		allTokens[DATABASE].keywordText = "DATABASE";
+		allTokens[DATABIND].keywordText = "DATA-BIND";
+		allTokens[DATASERVERS].keywordText = "DATASERVERS";
+		allTokens[DATE].keywordText = "DATE";
+		allTokens[DAY].keywordText = "DAY";
+		allTokens[DBCODEPAGE].keywordText = "DBCODEPAGE";
+		allTokens[DBCOLLATION].keywordText = "DBCOLLATION";
+		allTokens[DBIMS].keywordText = "DBIMS";
+		allTokens[DBNAME].keywordText = "DBNAME";
+		allTokens[DBPARAM].keywordText = "DBPARAM";
+		allTokens[DBRESTRICTIONS].keywordText = "DBRESTRICTIONS";
+		allTokens[DBTASKID].keywordText = "DBTASKID";
+		allTokens[DBTYPE].keywordText = "DBTYPE";
+		allTokens[DBVERSION].keywordText = "DBVERSION";
+		allTokens[DCOLOR].keywordText = "DCOLOR";
+		allTokens[DDE].keywordText = "DDE";
+		allTokens[DEBLANK].keywordText = "DEBLANK";
+		allTokens[DEBUG].keywordText = "DEBUG";
+		allTokens[DEBUGLIST].keywordText = "DEBUG-LIST";
+		allTokens[DEBUGGER].keywordText = "DEBUGGER";
+		allTokens[DECIMAL].keywordText = "DECIMAL";
+		allTokens[DECIMALS].keywordText = "DECIMALS";
+		allTokens[DECLARE].keywordText = "DECLARE";
+		allTokens[DEFAULT].keywordText = "DEFAULT";
+		allTokens[DEFAULTBUTTON].keywordText = "DEFAULT-BUTTON";
+		allTokens[DEFAULTEXTENSION].keywordText = "DEFAULT-EXTENSION";
+		allTokens[DEFAULTNOXLATE].keywordText = "DEFAULT-NOXLATE";
+		allTokens[DEFAULTWINDOW].keywordText = "DEFAULT-WINDOW";
+		allTokens[DEFERLOBFETCH].keywordText = "DEFER-LOB-FETCH";
+		allTokens[DEFINE].keywordText = "DEFINE";
+		allTokens[DEFINED].keywordText = "DEFINED";
+		allTokens[DELETE_KW].keywordText = "DELETE";
+		allTokens[DELETERESULTLISTENTRY].keywordText = "DELETE-RESULT-LIST-ENTRY";
+		allTokens[DELIMITER].keywordText = "DELIMITER";
+		allTokens[DESCENDING].keywordText = "DESCENDING";
+		allTokens[DESELECTION].keywordText = "DESELECTION";
+		allTokens[DIALOGBOX].keywordText = "DIALOG-BOX";
+		allTokens[DIALOGHELP].keywordText = "DIALOG-HELP";
+		allTokens[DICTIONARY].keywordText = "DICTIONARY";
+		allTokens[DIR].keywordText = "DIR";
+		allTokens[DISABLE].keywordText = "DISABLE";
+		allTokens[DISABLEAUTOZAP].keywordText = "DISABLE-AUTO-ZAP";
+		allTokens[DISABLED].keywordText = "DISABLED";
+		allTokens[DISCONNECT].keywordText = "DISCONNECT";
+		allTokens[DISPLAY].keywordText = "DISPLAY";
+		allTokens[DISTINCT].keywordText = "DISTINCT";
+		allTokens[DO].keywordText = "DO";
+		allTokens[DOS].keywordText = "DOS";
+		allTokens[DOUBLE].keywordText = "DOUBLE";
+		allTokens[DOWN].keywordText = "DOWN";
+		allTokens[DROP].keywordText = "DROP";
+		allTokens[DROPDOWN].keywordText = "DROP-DOWN";
+		allTokens[DROPDOWNLIST].keywordText = "DROP-DOWN-LIST";
+		allTokens[DROPFILENOTIFY].keywordText = "DROP-FILE-NOTIFY";
+		allTokens[DROPTARGET].keywordText = "DROP-TARGET";
+		allTokens[DUMP].keywordText = "DUMP";
+		allTokens[DYNAMIC].keywordText = "DYNAMIC";
+		allTokens[DYNAMICFUNCTION].keywordText = "DYNAMIC-FUNCTION";
+		allTokens[EACH].keywordText = "EACH";
+		allTokens[ECHO].keywordText = "ECHO";
+		allTokens[EDGECHARS].keywordText = "EDGE-CHARS";
+		allTokens[EDGEPIXELS].keywordText = "EDGE-PIXELS";
+		allTokens[EDITUNDO].keywordText = "EDIT-UNDO";
+		allTokens[EDITING].keywordText = "EDITING";
+		allTokens[EDITOR].keywordText = "EDITOR";
+		allTokens[ELSE].keywordText = "ELSE";
+		allTokens[EMPTY].keywordText = "EMPTY";
+		allTokens[ENABLE].keywordText = "ENABLE";
+		allTokens[ENCODE].keywordText = "ENCODE";
+		allTokens[END].keywordText = "END";
+		allTokens[ENDMOVE].keywordText = "END-MOVE";
+		allTokens[ENDRESIZE].keywordText = "END-RESIZE";
+		allTokens[ENDROWRESIZE].keywordText = "END-ROW-RESIZE";
+		allTokens[ENDKEY].keywordText = "END-KEY";
+		allTokens[ENTERED].keywordText = "ENTERED";
+		allTokens[ENTRY].keywordText = "ENTRY";
+		allTokens[EQ].keywordText = "EQ";
+		allTokens[ERROR].keywordText = "ERROR";
+		allTokens[ERRORSTATUS].keywordText = "ERROR-STATUS";
+		allTokens[ESCAPE].keywordText = "ESCAPE";
+		allTokens[ETIME_KW].keywordText = "ETIME";
+		allTokens[EVENTPROCEDURE].keywordText = "EVENT-PROCEDURE";
+		allTokens[EVENTS].keywordText = "EVENTS";
+		allTokens[EXCEPT].keywordText = "EXCEPT";
+		allTokens[EXCLUSIVEID].keywordText = "EXCLUSIVE-ID";
+		allTokens[EXCLUSIVELOCK].keywordText = "EXCLUSIVE-LOCK";
+		allTokens[EXCLUSIVEWEBUSER].keywordText = "EXCLUSIVE-WEB-USER";
+		allTokens[EXECUTE].keywordText = "EXECUTE";
+		allTokens[EXISTS].keywordText = "EXISTS";
+		allTokens[EXP].keywordText = "EXP";
+		allTokens[EXPAND].keywordText = "EXPAND";
+		allTokens[EXPANDABLE].keywordText = "EXPANDABLE";
+		allTokens[EXPLICIT].keywordText = "EXPLICIT";
+		allTokens[EXPORT].keywordText = "EXPORT";
+		allTokens[EXTENDED].keywordText = "EXTENDED";
+		allTokens[EXTENT].keywordText = "EXTENT";
+		allTokens[EXTERNAL].keywordText = "EXTERNAL";
+		allTokens[FALSE_KW].keywordText = "FALSE";
+		allTokens[FETCH].keywordText = "FETCH";
+		allTokens[FGCOLOR].keywordText = "FGCOLOR";
+		allTokens[FIELD].keywordText = "FIELD";
+		allTokens[FIELDS].keywordText = "FIELDS";
+		allTokens[FILE].keywordText = "FILE-NAME";
+		allTokens[FILEINFORMATION].keywordText = "FILE-INFORMATION";
+		allTokens[FILL].keywordText = "FILL";
+		allTokens[FILLIN].keywordText = "FILL-IN";
+		allTokens[FILTERS].keywordText = "FILTERS";
+		allTokens[FIND].keywordText = "FIND";
+		allTokens[FINDCASESENSITIVE].keywordText = "FIND-CASE-SENSITIVE";
+		allTokens[FINDER].keywordText = "FINDER";
+		allTokens[FINDGLOBAL].keywordText = "FIND-GLOBAL";
+		allTokens[FINDNEXTOCCURRENCE].keywordText = "FIND-NEXT-OCCURRENCE";
+		allTokens[FINDPREVOCCURRENCE].keywordText = "FIND-PREV-OCCURRENCE";
+		allTokens[FINDSELECT].keywordText = "FIND-SELECT";
+		allTokens[FINDWRAPAROUND].keywordText = "FIND-WRAP-AROUND";
+		allTokens[FIRST].keywordText = "FIRST";
+		allTokens[FIRSTOF].keywordText = "FIRST-OF";
+		allTokens[FITLASTCOLUMN].keywordText = "FIT-LAST-COLUMN";
+		allTokens[FIXEDONLY].keywordText = "FIXED-ONLY";
+		allTokens[FLATBUTTON].keywordText = "FLAT-BUTTON";
+		allTokens[FLOAT].keywordText = "FLOAT";
+		allTokens[FOCUS].keywordText = "FOCUS";
+		allTokens[FONT].keywordText = "FONT";
+		allTokens[FONTBASEDLAYOUT].keywordText = "FONT-BASED-LAYOUT";
+		allTokens[FONTTABLE].keywordText = "FONT-TABLE";
+		allTokens[FOR].keywordText = "FOR";
+		allTokens[FORCEFILE].keywordText = "FORCE-FILE";
+		allTokens[FORMINPUT].keywordText = "FORMINPUT";
+		allTokens[FORMAT].keywordText = "FORMAT";
+		allTokens[FORWARDS].keywordText = "FORWARDS";
+		allTokens[FRAME].keywordText = "FRAME";
+		allTokens[FRAMECOL].keywordText = "FRAME-COL";
+		allTokens[FRAMEDB].keywordText = "FRAME-DB";
+		allTokens[FRAMEDOWN].keywordText = "FRAME-DOWN";
+		allTokens[FRAMEFIELD].keywordText = "FRAME-FIELD";
+		allTokens[FRAMEFILE].keywordText = "FRAME-FILE";
+		allTokens[FRAMEINDEX].keywordText = "FRAME-INDEX";
+		allTokens[FRAMELINE].keywordText = "FRAME-LINE";
+		allTokens[FRAMENAME].keywordText = "FRAME-NAME";
+		allTokens[FRAMEROW].keywordText = "FRAME-ROW";
+		allTokens[FRAMEVALUE].keywordText = "FRAME-VALUE";
+		allTokens[FREQUENCY].keywordText = "FREQUENCY";
+		allTokens[FROM].keywordText = "FROM";
+		allTokens[FROMCURRENT].keywordText = "FROM-CURRENT";
+		allTokens[FUNCTION].keywordText = "FUNCTION";
+		allTokens[GE].keywordText = "GE";
+		allTokens[GENERATEMD5].keywordText = "GENERATE-MD5";
+		allTokens[GET].keywordText = "GET";
+		allTokens[GETBITS].keywordText = "GET-BITS";
+		allTokens[GETBUFFERHANDLE].keywordText = "GET-BUFFER-HANDLE";
+		allTokens[GETBYTE].keywordText = "GET-BYTE";
+		allTokens[GETBYTES].keywordText = "GET-BYTES";
+		allTokens[GETBYTEORDER].keywordText = "GET-BYTE-ORDER";
+		allTokens[GETCGILIST].keywordText = "GET-CGI-LIST";
+		allTokens[GETCGIVALUE].keywordText = "GET-CGI-VALUE";
+		allTokens[GETCODEPAGES].keywordText = "GET-CODEPAGES";
+		allTokens[GETCOLLATIONS].keywordText = "GET-COLLATIONS";
+		allTokens[GETCONFIGVALUE].keywordText = "GET-CONFIG-VALUE";
+		allTokens[GETDOUBLE].keywordText = "GET-DOUBLE";
+		allTokens[GETFILE].keywordText = "GET-FILE";
+		allTokens[GETFLOAT].keywordText = "GET-FLOAT";
+		allTokens[GETKEYVALUE].keywordText = "GET-KEY-VALUE";
+		allTokens[GETLICENSE].keywordText = "GET-LICENSE";
+		allTokens[GETLONG].keywordText = "GET-LONG";
+		allTokens[GETPOINTERVALUE].keywordText = "GET-POINTER-VALUE";
+		allTokens[GETSHORT].keywordText = "GET-SHORT";
+		allTokens[GETSIZE].keywordText = "GET-SIZE";
+		allTokens[GETSTRING].keywordText = "GET-STRING";
+		allTokens[GETUNSIGNEDSHORT].keywordText = "GET-UNSIGNED-SHORT";
+		allTokens[GLOBAL].keywordText = "GLOBAL";
+		allTokens[GOON].keywordText = "GO-ON";
+		allTokens[GOPENDING].keywordText = "GO-PENDING";
+		allTokens[GRANT].keywordText = "GRANT";
+		allTokens[GRAPHICEDGE].keywordText = "GRAPHIC-EDGE";
+		allTokens[GROUP].keywordText = "GROUP";
+		allTokens[GTHAN].keywordText = "GT";
+		allTokens[HANDLE].keywordText = "HANDLE";
+		allTokens[HAVING].keywordText = "HAVING";
+		allTokens[HEADER].keywordText = "HEADER";
+		allTokens[HEIGHT].keywordText = "HEIGHT";
+		allTokens[HELP].keywordText = "HELP";
+		allTokens[HELPTOPIC].keywordText = "HELP-TOPIC";
+		allTokens[HIDE].keywordText = "HIDE";
+		allTokens[HINT].keywordText = "HINT";
+		allTokens[HORIZONTAL].keywordText = "HORIZONTAL";
+		allTokens[HOSTBYTEORDER].keywordText = "HOST-BYTE-ORDER";
+		allTokens[HTMLENDOFLINE].keywordText = "HTML-END-OF-LINE";
+		allTokens[HTMLFRAMEBEGIN].keywordText = "HTML-FRAME-BEGIN";
+		allTokens[HTMLFRAMEEND].keywordText = "HTML-FRAME-END";
+		allTokens[HTMLHEADERBEGIN].keywordText = "HTML-HEADER-BEGIN";
+		allTokens[HTMLHEADEREND].keywordText = "HTML-HEADER-END";
+		allTokens[HTMLTITLEBEGIN].keywordText = "HTML-TITLE-BEGIN";
+		allTokens[HTMLTITLEEND].keywordText = "HTML-TITLE-END";
+		allTokens[IF].keywordText = "IF";
+		allTokens[IMAGE].keywordText = "IMAGE";
+		allTokens[IMAGEDOWN].keywordText = "IMAGE-DOWN";
+		allTokens[IMAGEINSENSITIVE].keywordText = "IMAGE-INSENSITIVE";
+		allTokens[IMAGESIZE].keywordText = "IMAGE-SIZE";
+		allTokens[IMAGESIZECHARS].keywordText = "IMAGE-SIZE-CHARS";
+		allTokens[IMAGESIZEPIXELS].keywordText = "IMAGE-SIZE-PIXELS";
+		allTokens[IMAGEUP].keywordText = "IMAGE-UP";
+		allTokens[IMPORT].keywordText = "IMPORT";
+		allTokens[IN_KW].keywordText = "IN";
+		allTokens[INCREMENTEXCLUSIVEID].keywordText = "INCREMENT-EXCLUSIVE-ID";
+		allTokens[INDEX].keywordText = "INDEX";
+		allTokens[INDEXHINT].keywordText = "INDEX-HINT";
+		allTokens[INDEXEDREPOSITION].keywordText = "INDEXED-REPOSITION";
+		allTokens[INDICATOR].keywordText = "INDICATOR";
+		allTokens[INFORMATION].keywordText = "INFORMATION";
+		allTokens[INITIAL].keywordText = "INITIAL";
+		allTokens[INITIALDIR].keywordText = "INITIAL-DIR";
+		allTokens[INITIALFILTER].keywordText = "INITIAL-FILTER";
+		allTokens[INITIATE].keywordText = "INITIATE";
+		allTokens[INNER].keywordText = "INNER";
+		allTokens[INNERCHARS].keywordText = "INNER-CHARS";
+		allTokens[INNERLINES].keywordText = "INNER-LINES";
+		allTokens[INPUT].keywordText = "INPUT";
+		allTokens[INPUTOUTPUT].keywordText = "INPUT-OUTPUT";
+		allTokens[INSERT].keywordText = "INSERT";
+		allTokens[INTEGER].keywordText = "INTEGER";
+		allTokens[INTO].keywordText = "INTO";
+		allTokens[IS].keywordText = "IS";
+		allTokens[ISATTRSPACE].keywordText = "IS-ATTR-SPACE";
+		allTokens[ISLEADBYTE].keywordText = "IS-LEAD-BYTE";
+		allTokens[ITEM].keywordText = "ITEM";
+		allTokens[JOIN].keywordText = "JOIN";
+		allTokens[JOINBYSQLDB].keywordText = "JOIN-BY-SQLDB";
+		allTokens[KBLABEL].keywordText = "KBLABEL";
+		allTokens[KEEPMESSAGES].keywordText = "KEEP-MESSAGES";
+		allTokens[KEEPTABORDER].keywordText = "KEEP-TAB-ORDER";
+		allTokens[KEY].keywordText = "KEY";
+		allTokens[KEYCODE].keywordText = "KEY-CODE";
+		allTokens[KEYFUNCTION].keywordText = "KEY-FUNCTION";
+		allTokens[KEYLABEL].keywordText = "KEY-LABEL";
+		allTokens[KEYS].keywordText = "KEYS";
+		allTokens[KEYWORD].keywordText = "KEYWORD";
+		allTokens[KEYWORDALL].keywordText = "KEYWORD-ALL";
+		allTokens[LABEL].keywordText = "LABEL";
+		allTokens[LABELBGCOLOR].keywordText = "LABEL-BGCOLOR";
+		allTokens[LABELDCOLOR].keywordText = "LABEL-DCOLOR";
+		allTokens[LABELFGCOLOR].keywordText = "LABEL-FGCOLOR";
+		allTokens[LABELFONT].keywordText = "LABEL-FONT";
+		allTokens[LANDSCAPE].keywordText = "LANDSCAPE";
+		allTokens[LANGUAGES].keywordText = "LANGUAGES";
+		allTokens[LARGE].keywordText = "LARGE";
+		allTokens[LARGETOSMALL].keywordText = "LARGE-TO-SMALL";
+		allTokens[LAST].keywordText = "LAST";
+		allTokens[LASTEVENT].keywordText = "LAST-EVENT";
+		allTokens[LASTOF].keywordText = "LAST-OF";
+		allTokens[LASTKEY].keywordText = "LAST-KEY";
+		allTokens[LC].keywordText = "LOWER";
+		allTokens[LDBNAME].keywordText = "LDBNAME";
+		allTokens[LE].keywordText = "LE";
+		allTokens[LEAVE].keywordText = "LEAVE";
+		allTokens[LEFT].keywordText = "LEFT";
+		allTokens[LEFTALIGNED].keywordText = "LEFT-ALIGNED";
+		allTokens[LEFTTRIM].keywordText = "LEFT-TRIM";
+		allTokens[LENGTH].keywordText = "LENGTH";
+		allTokens[LIBRARY].keywordText = "LIBRARY";
+		allTokens[LIKE].keywordText = "LIKE";
+		allTokens[LINECOUNTER].keywordText = "LINE-COUNTER";
+		allTokens[LISTEVENTS].keywordText = "LIST-EVENTS";
+		allTokens[LISTITEMPAIRS].keywordText = "LIST-ITEM-PAIRS";
+		allTokens[LISTITEMS].keywordText = "LIST-ITEMS";
+		allTokens[LISTQUERYATTRS].keywordText = "LIST-QUERY-ATTRS";
+		allTokens[LISTSETATTRS].keywordText = "LIST-SET-ATTRS";
+		allTokens[LISTWIDGETS].keywordText = "LIST-WIDGETS";
+		allTokens[LISTING].keywordText = "LISTING";
+		allTokens[LITTLEENDIAN].keywordText = "LITTLE-ENDIAN";
+		allTokens[LOAD].keywordText = "LOAD";
+		allTokens[LOADPICTURE].keywordText = "LOAD-PICTURE";
+		allTokens[LOCKED].keywordText = "LOCKED";
+		allTokens[LOG].keywordText = "LOG";
+		allTokens[LOGICAL].keywordText = "LOGICAL";
+		allTokens[LONG].keywordText = "LONG";
+		allTokens[LOOKAHEAD].keywordText = "LOOKAHEAD";
+		allTokens[LOOKUP].keywordText = "LOOKUP";
+		allTokens[LTHAN].keywordText = "LT";
+		allTokens[MACHINECLASS].keywordText = "MACHINE-CLASS";
+		allTokens[MAP].keywordText = "MAP";
+		allTokens[MARGINEXTRA].keywordText = "MARGIN-EXTRA";
+		allTokens[MATCHES].keywordText = "MATCHES";
+		allTokens[MAXCHARS].keywordText = "MAX-CHARS";
+		allTokens[MAXROWS].keywordText = "MAX-ROWS";
+		allTokens[MAXSIZE].keywordText = "MAX-SIZE";
+		allTokens[MAXVALUE].keywordText = "MAX-VALUE";
+		allTokens[MAXIMIZE].keywordText = "MAXIMIZE";
+		allTokens[MAXIMUM].keywordText = "MAXIMUM";
+		allTokens[MEMBER].keywordText = "MEMBER";
+		allTokens[MEMPTR].keywordText = "MEMPTR";
+		allTokens[MENU].keywordText = "MENU";
+		allTokens[MENUITEM].keywordText = "MENU-ITEM";
+		allTokens[MENUBAR].keywordText = "MENU-BAR";
+		allTokens[MESSAGE].keywordText = "MESSAGE";
+		allTokens[MESSAGELINE].keywordText = "MESSAGE-LINE";
+		allTokens[MESSAGELINES].keywordText = "MESSAGE-LINES";
+		allTokens[MINSIZE].keywordText = "MIN-SIZE";
+		allTokens[MINVALUE].keywordText = "MIN-VALUE";
+		allTokens[MINIMUM].keywordText = "MINIMUM";
+		allTokens[MODULO].keywordText = "MODULO";
+		allTokens[MONTH].keywordText = "MONTH";
+		allTokens[MOUSE].keywordText = "MOUSE";
+		allTokens[MOUSEPOINTER].keywordText = "MOUSE-POINTER";
+		allTokens[MPE].keywordText = "MPE";
+		allTokens[MULTIPLE].keywordText = "MULTIPLE";
+		allTokens[MULTIPLEKEY].keywordText = "MULTIPLE-KEY";
+		allTokens[MUSTEXIST].keywordText = "MUST-EXIST";
+		allTokens[NATIVE].keywordText = "NATIVE";
+		allTokens[NE].keywordText = "NE";
+		allTokens[NEW].keywordText = "NEW";
+		allTokens[NEXT].keywordText = "NEXT";
+		allTokens[NEXTPROMPT].keywordText = "NEXT-PROMPT";
+		allTokens[NEXTVALUE].keywordText = "NEXT-VALUE";
+		allTokens[NO].keywordText = "NO";
+		allTokens[NOAPPLY].keywordText = "NO-APPLY";
+		allTokens[NOARRAYMESSAGE].keywordText = "NO-ARRAY-MESSAGE";
+		allTokens[NOASSIGN].keywordText = "NO-ASSIGN";
+		allTokens[NOATTRLIST].keywordText = "NO-ATTR-LIST";
+		allTokens[NOATTRSPACE].keywordText = "NO-ATTR-SPACE";
+		allTokens[NOAUTOVALIDATE].keywordText = "NO-AUTO-VALIDATE";
+		allTokens[NOBINDWHERE].keywordText = "NO-BIND-WHERE";
+		allTokens[NOBOX].keywordText = "NO-BOX";
+		allTokens[NOCOLUMNSCROLLING].keywordText = "NO-COLUMN-SCROLLING";
+		allTokens[NOCONSOLE].keywordText = "NO-CONSOLE";
+		allTokens[NOCONVERT].keywordText = "NO-CONVERT";
+		allTokens[NOCONVERT3DCOLORS].keywordText = "NO-CONVERT-3D-COLORS";
+		allTokens[NOCURRENTVALUE].keywordText = "NO-CURRENT-VALUE";
+		allTokens[NODEBUG].keywordText = "NO-DEBUG";
+		allTokens[NODRAG].keywordText = "NO-DRAG";
+		allTokens[NOECHO].keywordText = "NO-ECHO";
+		allTokens[NOEMPTYSPACE].keywordText = "NO-EMPTY-SPACE";
+		allTokens[NOERROR_KW].keywordText = "NO-ERROR";
+		allTokens[NOFILL].keywordText = "NO-FILL";
+		allTokens[NOFOCUS].keywordText = "NO-FOCUS";
+		allTokens[NOHELP].keywordText = "NO-HELP";
+		allTokens[NOHIDE].keywordText = "NO-HIDE";
+		allTokens[NOINDEXHINT].keywordText = "NO-INDEX-HINT";
+		allTokens[NOJOINBYSQLDB].keywordText = "NO-JOIN-BY-SQLDB";
+		allTokens[NOLABELS].keywordText = "NO-LABELS";
+		allTokens[NOLOCK].keywordText = "NO-LOCK";
+		allTokens[NOLOOKAHEAD].keywordText = "NO-LOOKAHEAD";
+		allTokens[NOMAP].keywordText = "NO-MAP";
+		allTokens[NOMESSAGE].keywordText = "NO-MESSAGE";
+		allTokens[NONE].keywordText = "NONE";
+		allTokens[NOPAUSE].keywordText = "NO-PAUSE";
+		allTokens[NOPREFETCH].keywordText = "NO-PREFETCH";
+		allTokens[NORETURNVALUE].keywordText = "NO-RETURN-VALUE";
+		allTokens[NORMAL].keywordText = "NORMAL";
+		allTokens[NOROWMARKERS].keywordText = "NO-ROW-MARKERS";
+		allTokens[NOSCROLLBARVERTICAL].keywordText = "NO-SCROLLBAR-VERTICAL";
+		allTokens[NOSEPARATECONNECTION].keywordText = "NO-SEPARATE-CONNECTION";
+		allTokens[NOSEPARATORS].keywordText = "NO-SEPARATORS";
+		allTokens[NOTABSTOP].keywordText = "NO-TAB-STOP";
+		allTokens[NOUNDERLINE].keywordText = "NO-UNDERLINE";
+		allTokens[NOUNDO].keywordText = "NO-UNDO";
+		allTokens[NOVALIDATE].keywordText = "NO-VALIDATE";
+		allTokens[NOWAIT].keywordText = "NO-WAIT";
+		allTokens[NOWORDWRAP].keywordText = "NO-WORD-WRAP";
+		allTokens[NOT].keywordText = "NOT";
+		allTokens[NULL_KW].keywordText = "NULL";
+		allTokens[NUMALIASES].keywordText = "NUM-ALIASES";
+		allTokens[NUMCOPIES].keywordText = "NUM-COPIES";
+		allTokens[NUMDBS].keywordText = "NUM-DBS";
+		allTokens[NUMENTRIES].keywordText = "NUM-ENTRIES";
+		allTokens[NUMRESULTS].keywordText = "NUM-RESULTS";
+		allTokens[NUMERIC].keywordText = "NUMERIC";
+		allTokens[OBJECT].keywordText = "OBJECT";
+		allTokens[OCTETLENGTH].keywordText = "OCTET-LENGTH";
+		allTokens[OF].keywordText = "OF";
+		allTokens[OFF].keywordText = "OFF";
+		allTokens[OK].keywordText = "OK";
+		allTokens[OKCANCEL].keywordText = "OK-CANCEL";
+		allTokens[OLD].keywordText = "OLD";
+		allTokens[ON].keywordText = "ON";
+		allTokens[ONLY].keywordText = "ONLY";
+		allTokens[OPEN].keywordText = "OPEN";
+		allTokens[OPSYS].keywordText = "OPSYS";
+		allTokens[OPTION].keywordText = "OPTION";
+		allTokens[OR].keywordText = "OR";
+		allTokens[ORDER].keywordText = "ORDER";
+		allTokens[ORDEREDJOIN].keywordText = "ORDERED-JOIN";
+		allTokens[ORDINAL].keywordText = "ORDINAL";
+		allTokens[OS2].keywordText = "OS2";
+		allTokens[OS400].keywordText = "OS400";
+		allTokens[OSAPPEND].keywordText = "OS-APPEND";
+		allTokens[OSCOMMAND].keywordText = "OS-COMMAND";
+		allTokens[OSCOPY].keywordText = "OS-COPY";
+		allTokens[OSCREATEDIR].keywordText = "OS-CREATE-DIR";
+		allTokens[OSDELETE].keywordText = "OS-DELETE";
+		allTokens[OSDIR].keywordText = "OS-DIR";
+		allTokens[OSDRIVES].keywordText = "OS-DRIVES";
+		allTokens[OSERROR].keywordText = "OS-ERROR";
+		allTokens[OSGETENV].keywordText = "OS-GETENV";
+		allTokens[OSRENAME].keywordText = "OS-RENAME";
+		allTokens[OTHERWISE].keywordText = "OTHERWISE";
+		allTokens[OUTER].keywordText = "OUTER";
+		allTokens[OUTERJOIN].keywordText = "OUTER-JOIN";
+		allTokens[OUTPUT].keywordText = "OUTPUT";
+		allTokens[OVERLAY].keywordText = "OVERLAY";
+		allTokens[OVERRIDE].keywordText = "OVERRIDE";
+		allTokens[PAGE].keywordText = "PAGE";
+		allTokens[PAGEBOTTOM].keywordText = "PAGE-BOTTOM";
+		allTokens[PAGENUMBER].keywordText = "PAGE-NUMBER";
+		allTokens[PAGESIZE_KW].keywordText = "PAGE-SIZE";
+		allTokens[PAGETOP].keywordText = "PAGE-TOP";
+		allTokens[PAGEWIDTH].keywordText = "PAGE-WIDTH";
+		allTokens[PAGED].keywordText = "PAGED";
+		allTokens[PARAMETER].keywordText = "PARAMETER";
+		allTokens[PARENT].keywordText = "PARENT";
+		allTokens[PARTIALKEY].keywordText = "PARTIAL-KEY";
+		allTokens[PASCAL_KW].keywordText = "PASCAL";
+		allTokens[PAUSE].keywordText = "PAUSE";
+		allTokens[PDBNAME].keywordText = "PDBNAME";
+		allTokens[PERFORMANCE].keywordText = "PERFORMANCE";
+		allTokens[PERSISTENT].keywordText = "PERSISTENT";
+		allTokens[PFCOLOR].keywordText = "PFCOLOR";
+		allTokens[PINNABLE].keywordText = "PINNABLE";
+		allTokens[PORTRAIT].keywordText = "PORTRAIT";
+		allTokens[POSITION].keywordText = "POSITION";
+		allTokens[PRECISION].keywordText = "PRECISION";
+		allTokens[PREPROCESS].keywordText = "PREPROCESS";
+		allTokens[PRESELECT].keywordText = "PRESELECT";
+		allTokens[PREV].keywordText = "PREV";
+		allTokens[PRIMARY].keywordText = "PRIMARY";
+		allTokens[PRINTER].keywordText = "PRINTER";
+		allTokens[PRINTERSETUP].keywordText = "PRINTER-SETUP";
+		allTokens[PRIVATE].keywordText = "PRIVATE";
+		allTokens[PRIVILEGES].keywordText = "PRIVILEGES";
+		allTokens[PROCTEXT].keywordText = "PROC-TEXT";
+		allTokens[PROCTEXTBUFFER].keywordText = "PROC-TEXT-BUFFER";
+		allTokens[PROCHANDLE].keywordText = "PROC-HANDLE";
+		allTokens[PROCSTATUS].keywordText = "PROC-STATUS";
+		allTokens[PROCEDURE].keywordText = "PROCEDURE";
+		allTokens[PROCESS].keywordText = "PROCESS";
+		allTokens[PROFILER].keywordText = "PROFILER";
+		allTokens[PROGRAMNAME].keywordText = "PROGRAM-NAME";
+		allTokens[PROGRESS].keywordText = "PROGRESS";
+		allTokens[PROMPT].keywordText = "PROMPT";
+		allTokens[PROMPTFOR].keywordText = "PROMPT-FOR";
+		allTokens[PROMSGS].keywordText = "PROMSGS";
+		allTokens[PROPATH].keywordText = "PROPATH";
+		allTokens[PROVERSION].keywordText = "PROVERSION";
+		allTokens[PUBLIC].keywordText = "PUBLIC";
+		allTokens[PUBLISH].keywordText = "PUBLISH";
+		allTokens[PUT].keywordText = "PUT";
+		allTokens[PUTBITS].keywordText = "PUT-BITS";
+		allTokens[PUTBYTE].keywordText = "PUT-BYTE";
+		allTokens[PUTBYTES].keywordText = "PUT-BYTES";
+		allTokens[PUTDOUBLE].keywordText = "PUT-DOUBLE";
+		allTokens[PUTFLOAT].keywordText = "PUT-FLOAT";
+		allTokens[PUTKEYVALUE].keywordText = "PUT-KEY-VALUE";
+		allTokens[PUTLONG].keywordText = "PUT-LONG";
+		allTokens[PUTSHORT].keywordText = "PUT-SHORT";
+		allTokens[PUTSTRING].keywordText = "PUT-STRING";
+		allTokens[PUTUNSIGNEDSHORT].keywordText = "PUT-UNSIGNED-SHORT";
+		allTokens[QUERY].keywordText = "QUERY";
+		allTokens[QUERYCLOSE].keywordText = "QUERY-CLOSE";
+		allTokens[QUERYOFFEND].keywordText = "QUERY-OFF-END";
+		allTokens[QUERYTUNING].keywordText = "QUERY-TUNING";
+		allTokens[QUESTION].keywordText = "QUESTION";
+		allTokens[QUIT].keywordText = "QUIT";
+		allTokens[QUOTER].keywordText = "QUOTER";
+		allTokens[RINDEX].keywordText = "R-INDEX";
+		allTokens[RADIOBUTTONS].keywordText = "RADIO-BUTTONS";
+		allTokens[RADIOSET].keywordText = "RADIO-SET";
+		allTokens[RANDOM].keywordText = "RANDOM";
+		allTokens[RAW].keywordText = "RAW";
+		allTokens[RAWTRANSFER].keywordText = "RAW-TRANSFER";
+		allTokens[RCODEINFORMATION].keywordText = "RCODE-INFORMATION";
+		allTokens[READ].keywordText = "READ";
+		allTokens[READAVAILABLE].keywordText = "READ-AVAILABLE";
+		allTokens[READEXACTNUM].keywordText = "READ-EXACT-NUM";
+		allTokens[READONLY].keywordText = "READ-ONLY";
+		allTokens[READKEY].keywordText = "READKEY";
+		allTokens[REAL].keywordText = "REAL";
+		allTokens[RECID].keywordText = "RECID";
+		allTokens[RECORDLENGTH].keywordText = "RECORD-LENGTH";
+		allTokens[RECTANGLE].keywordText = "RECTANGLE";
+		allTokens[RECURSIVE].keywordText = "RECURSIVE";
+		allTokens[RELEASE].keywordText = "RELEASE";
+		allTokens[REPEAT].keywordText = "REPEAT";
+		allTokens[REPLACE].keywordText = "REPLACE";
+		allTokens[REPLICATIONCREATE].keywordText = "REPLICATION-CREATE";
+		allTokens[REPLICATIONDELETE].keywordText = "REPLICATION-DELETE";
+		allTokens[REPLICATIONWRITE].keywordText = "REPLICATION-WRITE";
+		allTokens[REPOSITION].keywordText = "REPOSITION";
+		allTokens[REPOSITIONFORWARD].keywordText = "REPOSITION-FORWARD";
+		allTokens[REPOSITIONBACKWARD].keywordText = "REPOSITION-BACKWARD";
+		allTokens[REPOSITIONTOROW].keywordText = "REPOSITION-TO-ROW";
+		allTokens[REPOSITIONTOROWID].keywordText = "REPOSITION-TO-ROWID";
+		allTokens[REQUEST].keywordText = "REQUEST";
+		allTokens[RESULT].keywordText = "RESULT";
+		allTokens[RETAIN].keywordText = "RETAIN";
+		allTokens[RETAINSHAPE].keywordText = "RETAIN-SHAPE";
+		allTokens[RETRY].keywordText = "RETRY";
+		allTokens[RETRYCANCEL].keywordText = "RETRY-CANCEL";
+		allTokens[RETURN].keywordText = "RETURN";
+		allTokens[RETURNTOSTARTDIR].keywordText = "RETURN-TO-START-DIR";
+		allTokens[RETURNVALUE].keywordText = "RETURN-VALUE";
+		allTokens[RETURNS].keywordText = "RETURNS";
+		allTokens[REVERSEFROM].keywordText = "REVERSE-FROM";
+		allTokens[REVERT].keywordText = "REVERT";
+		allTokens[REVOKE].keywordText = "REVOKE";
+		allTokens[RGBVALUE].keywordText = "RGB-VALUE";
+		allTokens[RIGHT].keywordText = "RIGHT";
+		allTokens[RIGHTALIGNED].keywordText = "RIGHT-ALIGNED";
+		allTokens[RIGHTTRIM].keywordText = "RIGHT-TRIM";
+		allTokens[ROUND].keywordText = "ROUND";
+		allTokens[ROW].keywordText = "ROW";
+		allTokens[ROWHEIGHTCHARS].keywordText = "ROW-HEIGHT-CHARS";
+		allTokens[ROWHEIGHTPIXELS].keywordText = "ROW-HEIGHT-PIXELS";
+		allTokens[ROWID].keywordText = "ROWID";
+		allTokens[ROWOF].keywordText = "ROW-OF";
+		allTokens[RULE].keywordText = "RULE";
+		allTokens[RUN].keywordText = "RUN";
+		allTokens[RUNPROCEDURE].keywordText = "RUN-PROCEDURE";
+		allTokens[SAVE].keywordText = "SAVE";
+		allTokens[SAVECACHE].keywordText = "SAVECACHE";
+		allTokens[SAVEAS].keywordText = "SAVE-AS";
+		allTokens[SAXREADER].keywordText = "SAX-READER";
+		allTokens[SCHEMA].keywordText = "SCHEMA";
+		allTokens[SCREEN].keywordText = "SCREEN";
+		allTokens[SCREENIO].keywordText = "SCREEN-IO";
+		allTokens[SCREENLINES].keywordText = "SCREEN-LINES";
+		allTokens[SCROLL].keywordText = "SCROLL";
+		allTokens[SCROLLABLE].keywordText = "SCROLLABLE";
+		allTokens[SCROLLBARHORIZONTAL].keywordText = "SCROLLBAR-HORIZONTAL";
+		allTokens[SCROLLBARVERTICAL].keywordText = "SCROLLBAR-VERTICAL";
+		allTokens[SCROLLING].keywordText = "SCROLLING";
+		allTokens[SDBNAME].keywordText = "SDBNAME";
+		allTokens[SEARCH].keywordText = "SEARCH";
+		allTokens[SEARCHSELF].keywordText = "SEARCH-SELF";
+		allTokens[SEARCHTARGET].keywordText = "SEARCH-TARGET";
+		allTokens[SECTION].keywordText = "SECTION";
+		allTokens[SEEK].keywordText = "SEEK";
+		allTokens[SELECT].keywordText = "SELECT";
+		allTokens[SELECTION].keywordText = "SELECTION";
+		allTokens[SELECTIONLIST].keywordText = "SELECTION-LIST";
+		allTokens[SELF].keywordText = "SELF";
+		allTokens[SEND].keywordText = "SEND";
+		allTokens[SENDSQLSTATEMENT].keywordText = "SEND-SQL-STATEMENT";
+		allTokens[SEPARATECONNECTION].keywordText = "SEPARATE-CONNECTION";
+		allTokens[SEPARATORS].keywordText = "SEPARATORS";
+		allTokens[SERVER].keywordText = "SERVER";
+		allTokens[SERVERSOCKET].keywordText = "SERVER-SOCKET";
+		allTokens[SESSION].keywordText = "SESSION";
+		allTokens[SET].keywordText = "SET";
+		allTokens[SETBYTEORDER].keywordText = "SET-BYTE-ORDER";
+		allTokens[SETCONTENTS].keywordText = "SET-CONTENTS";
+		allTokens[SETCURRENTVALUE].keywordText = "SET-CURRENT-VALUE";
+		allTokens[SETPOINTERVALUE].keywordText = "SET-POINTER-VALUE";
+		allTokens[SETSIZE].keywordText = "SET-SIZE";
+		allTokens[SETUSERID].keywordText = "SETUSERID";
+		allTokens[SHARELOCK].keywordText = "SHARE-LOCK";
+		allTokens[SHARED].keywordText = "SHARED";
+		allTokens[SHOWSTATS].keywordText = "SHOW-STATS";
+		allTokens[SIDELABELS].keywordText = "SIDE-LABELS";
+		allTokens[SILENT].keywordText = "SILENT";
+		allTokens[SIMPLE].keywordText = "SIMPLE";
+		allTokens[SINGLE].keywordText = "SINGLE";
+		allTokens[SIZE].keywordText = "SIZE";
+		allTokens[SIZECHARS].keywordText = "SIZE-CHARS";
+		allTokens[SIZEPIXELS].keywordText = "SIZE-PIXELS";
+		allTokens[SKIP].keywordText = "SKIP";
+		allTokens[SKIPDELETEDRECORD].keywordText = "SKIP-DELETED-RECORD";
+		allTokens[SLIDER].keywordText = "SLIDER";
+		allTokens[SMALLINT].keywordText = "SMALLINT";
+		allTokens[SOCKET].keywordText = "SOCKET";
+		allTokens[SOME].keywordText = "SOME";
+		allTokens[SORT].keywordText = "SORT";
+		allTokens[SOURCE].keywordText = "SOURCE";
+		allTokens[SOURCEPROCEDURE].keywordText = "SOURCE-PROCEDURE";
+		allTokens[SPACE].keywordText = "SPACE";
+		allTokens[SQL].keywordText = "SQL";
+		allTokens[SQRT].keywordText = "SQRT";
+		allTokens[START].keywordText = "START";
+		allTokens[STARTMOVE].keywordText = "START-MOVE";
+		allTokens[STARTRESIZE].keywordText = "START-RESIZE";
+		allTokens[STARTROWRESIZE].keywordText = "START-ROW-RESIZE";
+		allTokens[STATUS].keywordText = "STATUS";
+		allTokens[STATUSBAR].keywordText = "STATUS-BAR";
+		allTokens[STDCALL_KW].keywordText = "STDCALL";
+		allTokens[STRETCHTOFIT].keywordText = "STRETCH-TO-FIT";
+		allTokens[STOP].keywordText = "STOP";
+		allTokens[STOREDPROCEDURE].keywordText = "STORED-PROCEDURE";
+		allTokens[STREAM].keywordText = "STREAM";
+		allTokens[STREAMIO].keywordText = "STREAM-IO";
+		allTokens[STRING].keywordText = "STRING";
+		allTokens[STRINGXREF].keywordText = "STRING-XREF";
+		allTokens[SUBAVERAGE].keywordText = "SUB-AVERAGE";
+		allTokens[SUBCOUNT].keywordText = "SUB-COUNT";
+		allTokens[SUBMAXIMUM].keywordText = "SUB-MAXIMUM";
+		allTokens[SUBMENU].keywordText = "SUB-MENU";
+		allTokens[SUBMENUHELP].keywordText = "SUB-MENU-HELP";
+		allTokens[SUBMINIMUM].keywordText = "SUB-MINIMUM";
+		allTokens[SUBTOTAL].keywordText = "SUB-TOTAL";
+		allTokens[SUBSCRIBE].keywordText = "SUBSCRIBE";
+		allTokens[SUBSTITUTE].keywordText = "SUBSTITUTE";
+		allTokens[SUBSTRING].keywordText = "SUBSTRING";
+		allTokens[SUM].keywordText = "SUM";
+		allTokens[SUMMARY].keywordText = "SUMMARY";
+		allTokens[SUPER].keywordText = "SUPER";
+		allTokens[SYSTEMDIALOG].keywordText = "SYSTEM-DIALOG";
+		allTokens[SYSTEMHELP].keywordText = "SYSTEM-HELP";
+		allTokens[TABLE].keywordText = "TABLE";
+		allTokens[TABLEHANDLE].keywordText = "TABLE-HANDLE";
+		allTokens[TABLENUMBER].keywordText = "TABLE-NUMBER";
+		allTokens[TARGET].keywordText = "TARGET";
+		allTokens[TARGETPROCEDURE].keywordText = "TARGET-PROCEDURE";
+		allTokens[TEMPTABLE].keywordText = "TEMP-TABLE";
+		allTokens[TERMINAL].keywordText = "TERMINAL";
+		allTokens[TERMINATE].keywordText = "TERMINATE";
+		allTokens[TEXT].keywordText = "TEXT";
+		allTokens[TEXTCURSOR].keywordText = "TEXT-CURSOR";
+		allTokens[TEXTSEGGROW].keywordText = "TEXT-SEG-GROWTH";
+		allTokens[THEN].keywordText = "THEN";
+		allTokens[THISPROCEDURE].keywordText = "THIS-PROCEDURE";
+		allTokens[THREED].keywordText = "THREE-D";
+		allTokens[THROUGH].keywordText = "THROUGH";
+		allTokens[TICMARKS].keywordText = "TIC-MARKS";
+		allTokens[TIME].keywordText = "TIME";
+		allTokens[TITLE].keywordText = "TITLE";
+		allTokens[TO].keywordText = "TO";
+		allTokens[TOOLBAR].keywordText = "TOOL-BAR";
+		allTokens[TOOLTIP].keywordText = "TOOLTIP";
+		allTokens[TOROWID].keywordText = "TO-ROWID";
+		allTokens[TODAY].keywordText = "TODAY";
+		allTokens[TOGGLEBOX].keywordText = "TOGGLE-BOX";
+		allTokens[TOP].keywordText = "TOP";
+		allTokens[TOPONLY].keywordText = "TOP-ONLY";
+		allTokens[TOPIC].keywordText = "TOPIC";
+		allTokens[TOTAL].keywordText = "TOTAL";
+		allTokens[TRANSACTION].keywordText = "TRANSACTION";
+		allTokens[TRANSACTIONMODE].keywordText = "TRANSACTION-MODE";
+		allTokens[TRANSPARENT].keywordText = "TRANSPARENT";
+		allTokens[TRAILING].keywordText = "TRAILING";
+		allTokens[TRIGGER].keywordText = "TRIGGER";
+		allTokens[TRIGGERS].keywordText = "TRIGGERS";
+		allTokens[TRIM].keywordText = "TRIM";
+		allTokens[TRUE_KW].keywordText = "TRUE";
+		allTokens[TRUNCATE].keywordText = "TRUNCATE";
+		allTokens[UNBUFFERED].keywordText = "UNBUFFERED";
+		allTokens[UNDERLINE].keywordText = "UNDERLINE";
+		allTokens[UNDO].keywordText = "UNDO";
+		allTokens[UNFORMATTED].keywordText = "UNFORMATTED";
+		allTokens[UNION].keywordText = "UNION";
+		allTokens[UNIQUE].keywordText = "UNIQUE";
+		allTokens[UNIQUEMATCH].keywordText = "UNIQUE-MATCH";
+		allTokens[UNIX].keywordText = "UNIX";
+		allTokens[UNLESSHIDDEN].keywordText = "UNLESS-HIDDEN";
+		allTokens[UNLOAD].keywordText = "UNLOAD";
+		allTokens[UNSUBSCRIBE].keywordText = "UNSUBSCRIBE";
+		allTokens[UP].keywordText = "UP";
+		allTokens[UPDATE].keywordText = "UPDATE";
+		allTokens[URLDECODE].keywordText = "URL-DECODE";
+		allTokens[URLENCODE].keywordText = "URL-ENCODE";
+		allTokens[USE].keywordText = "USE";
+		allTokens[USEDICTEXPS].keywordText = "USE-DICT-EXPS";
+		allTokens[USEFILENAME].keywordText = "USE-FILENAME";
+		allTokens[USEINDEX].keywordText = "USE-INDEX";
+		allTokens[USER].keywordText = "USER";
+		allTokens[USERID].keywordText = "USERID";
+		allTokens[USEREVVIDEO].keywordText = "USE-REVVIDEO";
+		allTokens[USETEXT].keywordText = "USE-TEXT";
+		allTokens[USEUNDERLINE].keywordText = "USE-UNDERLINE";
+		allTokens[USING].keywordText = "USING";
+		allTokens[V6FRAME].keywordText = "V6FRAME";
+		allTokens[VALIDEVENT].keywordText = "VALID-EVENT";
+		allTokens[VALIDHANDLE].keywordText = "VALID-HANDLE";
+		allTokens[VALIDATE].keywordText = "VALIDATE";
+		allTokens[VALUE].keywordText = "VALUE";
+		allTokens[VALUECHANGED].keywordText = "VALUE-CHANGED";
+		allTokens[VALUES].keywordText = "VALUES";
+		allTokens[VARIABLE].keywordText = "VARIABLE";
+		allTokens[VERBOSE].keywordText = "VERBOSE";
+		allTokens[VERTICAL].keywordText = "VERTICAL";
+		allTokens[VIEW].keywordText = "VIEW";
+		allTokens[VIEWAS].keywordText = "VIEW-AS";
+		allTokens[VMS].keywordText = "VMS";
+		allTokens[WAIT].keywordText = "WAIT";
+		allTokens[WAITFOR].keywordText = "WAIT-FOR";
+		allTokens[WARNING].keywordText = "WARNING";
+		allTokens[WEBCONTEXT].keywordText = "WEB-CONTEXT";
+		allTokens[WEEKDAY].keywordText = "WEEKDAY";
+		allTokens[WHEN].keywordText = "WHEN";
+		allTokens[WHERE].keywordText = "WHERE";
+		allTokens[WHILE].keywordText = "WHILE";
+		allTokens[WIDGET].keywordText = "WIDGET";
+		allTokens[WIDGETHANDLE].keywordText = "WIDGET-HANDLE";
+		allTokens[WIDGETPOOL].keywordText = "WIDGET-POOL";
+		allTokens[WIDTH].keywordText = "WIDTH";
+		allTokens[WIDTHCHARS].keywordText = "WIDTH-CHARS";
+		allTokens[WIDTHPIXELS].keywordText = "WIDTH-PIXELS";
+		allTokens[WINDOW].keywordText = "WINDOW";
+		allTokens[WINDOWDELAYEDMINIMIZE].keywordText = "WINDOW-DELAYED-MINIMIZE";
+		allTokens[WINDOWMAXIMIZED].keywordText = "WINDOW-MAXIMIZED";
+		allTokens[WINDOWMINIMIZED].keywordText = "WINDOW-MINIMIZED";
+		allTokens[WINDOWNAME].keywordText = "WINDOW-NAME";
+		allTokens[WINDOWNORMAL].keywordText = "WINDOW-NORMAL";
+		allTokens[WITH].keywordText = "WITH";
+		allTokens[WORDINDEX].keywordText = "WORD-INDEX";
+		allTokens[WORKTABLE].keywordText = "WORK-TABLE";
+		allTokens[WRITE].keywordText = "WRITE";
+		allTokens[X].keywordText = "X";
+		allTokens[XDOCUMENT].keywordText = "X-DOCUMENT";
+		allTokens[XNODEREF].keywordText = "X-NODEREF";
+		allTokens[XOF].keywordText = "X-OF";
+		allTokens[XCODE].keywordText = "XCODE";
+		allTokens[XREF].keywordText = "XREF";
+		allTokens[Y].keywordText = "Y";
+		allTokens[YOF].keywordText = "Y-OF";
+		allTokens[YEAR].keywordText = "YEAR";
+		allTokens[YES].keywordText = "YES";
+		allTokens[YESNO].keywordText = "YES-NO";
+		allTokens[YESNOCANCEL].keywordText = "YES-NO-CANCEL";
+		allTokens[FUNCTIONCALLTYPE].keywordText = "FUNCTION-CALL-TYPE";
+		allTokens[GETATTRCALLTYPE].keywordText = "GET-ATTR-CALL-TYPE";
+		allTokens[PROCEDURECALLTYPE].keywordText = "PROCEDURE-CALL-TYPE";
+		allTokens[SAXCOMPLETE].keywordText = "SAX-COMPLETE";
+		allTokens[SAXPARSERERROR].keywordText = "SAX-PARSER-ERROR";
+		allTokens[SAXRUNNING].keywordText = "SAX-RUNNING";
+		allTokens[SAXUNINITIALIZED].keywordText = "SAX-UNINITIALIZED";
+		allTokens[SETATTRCALLTYPE].keywordText = "SET-ATTR-CALL-TYPE";
+		allTokens[COPYLOB].keywordText = "COPY-LOB";
+		allTokens[DATARELATION].keywordText = "DATA-RELATION";
+		allTokens[DATASOURCE].keywordText = "DATA-SOURCE";
+		allTokens[DATASET].keywordText = "DATASET";
+		allTokens[DATASETHANDLE].keywordText = "DATASET-HANDLE";
+		allTokens[LOGMANAGER].keywordText = "LOG-MANAGER";
+		allTokens[NOLOBS].keywordText = "NO-LOBS";
+		allTokens[NOW].keywordText = "NOW";
+		allTokens[STARTING].keywordText = "STARTING";
+		allTokens[BASE64].keywordText = "BASE64";
+		allTokens[SOAPHEADER].keywordText = "SOAP-HEADER";
+		allTokens[SOAPHEADERENTRYREF].keywordText = "SOAP-HEADER-ENTRYREF";
+		allTokens[BLOB].keywordText = "BLOB";
+		allTokens[CLOB].keywordText = "CLOB";
+		allTokens[DATETIME].keywordText = "DATETIME";
+		allTokens[DATETIMETZ].keywordText = "DATETIME-TZ";
+		allTokens[LONGCHAR].keywordText = "LONGCHAR";
+		allTokens[RELATIONFIELDS].keywordText = "RELATION-FIELDS";
+		allTokens[TTCODEPAGE].keywordText = "TTCODEPAGE";
+		allTokens[COLUMNCODEPAGE].keywordText = "COLUMN-CODEPAGE";
+		allTokens[DYNAMICCURRENTVALUE].keywordText = "DYNAMIC-CURRENT-VALUE";
+		allTokens[DYNAMICNEXTVALUE].keywordText = "DYNAMIC-NEXT-VALUE";
+		allTokens[FIXCODEPAGE].keywordText = "FIX-CODEPAGE";
+		allTokens[INTERVAL].keywordText = "INTERVAL";
+		allTokens[ISCODEPAGEFIXED].keywordText = "IS-CODEPAGE-FIXED";
+		allTokens[ISCOLUMNCODEPAGE].keywordText = "IS-COLUMN-CODEPAGE";
+		allTokens[ISODATE].keywordText = "ISO-DATE";
+		allTokens[MTIME].keywordText = "MTIME";
+		allTokens[LOBDIR].keywordText = "LOB-DIR";
+		allTokens[TIMEZONE].keywordText = "TIMEZONE";
+		allTokens[BYVALUE].keywordText = "BY-VALUE";
+		allTokens[BYREFERENCE].keywordText = "BY-REFERENCE";
+		allTokens[ADDINTERVAL].keywordText = "ADD-INTERVAL";
+		allTokens[GETDIR].keywordText = "GET-DIR";
+		allTokens[CURRENCY].keywordText = "CURRENCY";
+		allTokens[ERRORCODE].keywordText = "ERROR-CODE";
+		allTokens[IUNKNOWN].keywordText = "IUNKNOWN";
+		allTokens[SHORT].keywordText = "SHORT";
+		allTokens[UNSIGNEDBYTE].keywordText = "UNSIGNED-BYTE";
+		allTokens[UNSIGNEDSHORT].keywordText = "UNSIGNED-SHORT";
+		allTokens[CODEPAGE].keywordText = "CODEPAGE";
+		allTokens[BASE64DECODE].keywordText = "BASE64-DECODE";
+		allTokens[BASE64ENCODE].keywordText = "BASE64-ENCODE";
+		allTokens[BATCHSIZE].keywordText = "BATCH-SIZE";
+		allTokens[BEFORETABLE].keywordText = "BEFORE-TABLE";
+		allTokens[COPYDATASET].keywordText = "COPY-DATASET";
+		allTokens[COPYTEMPTABLE].keywordText = "COPY-TEMP-TABLE";
+		allTokens[DATASOURCEMODIFIED].keywordText = "DATA-SOURCE-MODIFIED";
+		allTokens[DECRYPT].keywordText = "DECRYPT";
+		allTokens[DELETECHARACTER].keywordText = "DELETE-CHARACTER";
+		allTokens[ENABLEDFIELDS].keywordText = "ENABLED-FIELDS";
+		allTokens[ENCRYPT].keywordText = "ENCRYPT";
+		allTokens[ENCRYPTIONSALT].keywordText = "ENCRYPTION-SALT";
+		allTokens[FORMLONGINPUT].keywordText = "FORM-LONG-INPUT";
+		allTokens[GENERATEPBEKEY].keywordText = "GENERATE-PBE-KEY";
+		allTokens[GENERATEPBESALT].keywordText = "GENERATE-PBE-SALT";
+		allTokens[GENERATERANDOMKEY].keywordText = "GENERATE-RANDOM-KEY";
+		allTokens[GETCGILONGVALUE].keywordText = "GET-CGI-LONG-VALUE";
+		allTokens[LASTBATCH].keywordText = "LAST-BATCH";
+		allTokens[MD5DIGEST].keywordText = "MD5-DIGEST";
+		allTokens[MERGEBYFIELD].keywordText = "MERGE-BY-FIELD";
+		allTokens[NORMALIZE].keywordText = "NORMALIZE";
+		allTokens[PBEHASHALGORITHM].keywordText = "PBE-HASH-ALGORITHM";
+		allTokens[PBEKEYROUNDS].keywordText = "PBE-KEY-ROUNDS";
+		allTokens[PREFERDATASET].keywordText = "PREFER-DATASET";
+		allTokens[REJECTED].keywordText = "REJECTED";
+		allTokens[REPOSITIONMODE].keywordText = "REPOSITION-MODE";
+		allTokens[ROWSTATE].keywordText = "ROW-STATE";
+		allTokens[ROWUNMODIFIED].keywordText = "ROW-UNMODIFIED";
+		allTokens[ROWDELETED].keywordText = "ROW-DELETED";
+		allTokens[ROWMODIFIED].keywordText = "ROW-MODIFIED";
+		allTokens[ROWCREATED].keywordText = "ROW-CREATED";
+		allTokens[SECURITYPOLICY].keywordText = "SECURITY-POLICY";
+		allTokens[SHA1DIGEST].keywordText = "SHA1-DIGEST";
+		allTokens[SSLSERVERNAME].keywordText = "SSL-SERVER-NAME";
+		allTokens[1087].keywordText = "SYMMETRIC-ENCRYPTION-ALGORITHM";
+		allTokens[SYMMETRICENCRYPTIONIV].keywordText = "SYMMETRIC-ENCRYPTION-IV";
+		allTokens[SYMMETRICENCRYPTIONKEY].keywordText = "SYMMETRIC-ENCRYPTION-KEY";
+		allTokens[SYMMETRICSUPPORT].keywordText = "SYMMETRIC-SUPPORT";
+		allTokens[TRANSINITPROCEDURE].keywordText = "TRANS-INIT-PROCEDURE";
+	}
 }

Modified: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/BlockNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/BlockNode.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/BlockNode.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -16,6 +16,9 @@
 
 public class BlockNode extends JPNode {
 
+	/** For creating from persistent storage */
+	public BlockNode() { super(); }
+
 	public BlockNode(int handle) { super(handle); }
 	public BlockNode(int handle, TreeConfig config) { super(handle, config); }
 	public BlockNode(int file, int line, int column) { super(file, line, column); }
@@ -25,6 +28,10 @@
 		assert block != null;
 		return block;
 	}
+
+	/** Every JPNode subtype has its own index. Used for persistent storage. */
+	public int getSubtypeIndex() { return 2; }
+
 	public void setBlock(Block block) {
 		setLink(JPNode.BLOCK, block);
 	}

Modified: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/FieldRefNode.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -22,6 +22,9 @@
 
 public class FieldRefNode extends JPNode {
 
+	/** For creating from persistent storage */
+	public FieldRefNode() { super(); }
+
 	public FieldRefNode(int handle) { super(handle); }
 	public FieldRefNode(int handle, TreeConfig config) { super(handle, config); }
 	public FieldRefNode(int file, int line, int column) { super(file, line, column); }
@@ -45,6 +48,9 @@
 		return idNode;
 	}
 	
+	/** Every JPNode subtype has its own index. Used for persistent storage. */
+	public int getSubtypeIndex() { return 3; }
+
 	/** Get the Symbol for a Field_ref node.
 	 * @return Always returns one of two Symbol types: Variable or FieldBuffer.
 	 */

Modified: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/NodeFactory.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/NodeFactory.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/NodeFactory.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -43,6 +43,8 @@
 			return new FieldRefNode(handle);
 		case TokenTypes.RECORD_NAME:
 			return new RecordNameNode(handle);
+		case TokenTypes.PROPARSEDIRECTIVE:
+			return new ProparseDirectiveNode(handle);
 		case TokenTypes.DO:
 		case TokenTypes.FOR:
 		case TokenTypes.REPEAT:
@@ -73,5 +75,22 @@
 			return new JPNode(handle);
 		}
 	}
+	
+	public static JPNode createByIndex(int index) {
+		switch (index) {
+		case 1:
+			return new JPNode();
+		case 2:
+			return new BlockNode();
+		case 3:
+			return new FieldRefNode();
+		case 4:
+			return new RecordNameNode();
+		case 5:
+			return new ProparseDirectiveNode();
+		default:
+			throw new IllegalArgumentException();
+		}
+	}
 
 }

Added: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/ProparseDirectiveNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/ProparseDirectiveNode.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/ProparseDirectiveNode.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -0,0 +1,42 @@
+/* Created Apr, 2005
+ * Authors: John Green
+ * 
+ * Copyright (c) 2005 Joanju (www.joanju.com)
+ * All rights reserved. This program and the accompanying materials 
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.prorefactor.nodetypes;
+
+import org.prorefactor.core.JPNode;
+
+import com.joanju.ProparseLdr;
+
+
+public class ProparseDirectiveNode extends JPNode {
+
+	/** For creating from persistent storage */
+	public ProparseDirectiveNode() { super(); }
+
+	public ProparseDirectiveNode(int handle) { super(handle); }
+	public ProparseDirectiveNode(int handle, TreeConfig config) { super(handle, config); }
+	public ProparseDirectiveNode(int file, int line, int column) { super(file, line, column); }
+	
+	private String directiveText = "";
+
+	/** Get the directive text. Might return empty, but should not return null. */
+	public String getDirectiveText() {
+		if (getHandle()!=0)
+			return ProparseLdr.getInstance().attrGetS(getHandle(), "PROPARSEDIRECTIVE");
+		else
+			return directiveText;
+	}
+
+	/** Every JPNode subtype has its own index. Used for persistent storage. */
+	public int getSubtypeIndex() { return 5; }
+
+	public void setDirectiveText(String text) { directiveText = text; }
+	
+}

Modified: trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/RecordNameNode.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/RecordNameNode.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/nodetypes/RecordNameNode.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -17,6 +17,9 @@
 
 public class RecordNameNode extends JPNode {
 
+	/** For creating from persistent storage */
+	public RecordNameNode() { super(); }
+
 	public RecordNameNode(int handle) { super(handle); }
 	public RecordNameNode(int handle, TreeConfig config) { super(handle, config); }
 	public RecordNameNode(int file, int line, int column) { super(file, line, column); }
@@ -27,6 +30,9 @@
 		return bufferScope;
 	}
 	
+	/** Every JPNode subtype has its own index. Used for persistent storage. */
+	public int getSubtypeIndex() { return 4; }
+
 	public TableBuffer getTableBuffer() {
 		TableBuffer buffer = (TableBuffer) getLink(JPNode.SYMBOL);
 		assert buffer != null;

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -1099,4 +1099,5 @@
 	int BIGINT = 1092;
 	int TIMESTAMP = 1093;
 	int FIXCHAR = 1094;
+	int Last_Token_Number = 1094;
 }

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.txt
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.txt	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.txt	2005-05-13 21:37:59 UTC (rev 28)
@@ -1090,3 +1090,4 @@
 BIGINT=1092
 TIMESTAMP=1093
 FIXCHAR=1094
+Last_Token_Number=1094

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/ProParserTokenTypes.txt
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/ProParserTokenTypes.txt	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/ProParserTokenTypes.txt	2005-05-13 21:37:59 UTC (rev 28)
@@ -1089,3 +1089,4 @@
 BIGINT=1092
 TIMESTAMP=1093
 FIXCHAR=1094
+Last_Token_Number=1094

Modified: trunk/org.prorefactor.lib/.classpath
===================================================================
--- trunk/org.prorefactor.lib/.classpath	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.lib/.classpath	2005-05-13 21:37:59 UTC (rev 28)
@@ -4,7 +4,6 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/cglib-full-2.0.2.jar"/>
 	<classpathentry exported="true" kind="lib" path="hsqldb/hsqldb.jar"/>
-	<classpathentry exported="true" kind="lib" path="hibernate/commons-lang-1.0.1.jar"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/commons-logging-1.0.4.jar"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/dom4j-1.4.jar"/>
 	<classpathentry exported="true" kind="lib" path="hibernate/ehcache-0.9.jar"/>
@@ -15,5 +14,6 @@
 	<classpathentry exported="true" kind="lib" path="hibernate/xml-apis.jar"/>
 	<classpathentry exported="true" sourcepath="jakarta/commons-collections/src.zip" kind="lib" path="jakarta/commons-collections/commons-collections.jar"/>
 	<classpathentry exported="true" sourcepath="jakarta/commons-io/src.zip" kind="lib" path="jakarta/commons-io/commons-io.jar"/>
+	<classpathentry exported="true" sourcepath="jakarta/commons-lang/src.zip" kind="lib" path="jakarta/commons-lang/commons-lang.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Added: trunk/org.prorefactor.lib/jakarta/commons-lang/LICENSE.txt
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-lang/LICENSE.txt	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.lib/jakarta/commons-lang/LICENSE.txt	2005-05-13 21:37:59 UTC (rev 28)
@@ -0,0 +1,53 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution, if
+ *    any, must include the following acknowledgement:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgement may appear in the software itself,
+ *    if and wherever such third-party acknowledgements normally appear.
+ *
+ * 4. The names "The Jakarta Project", "Commons", and "Apache Software
+ *    Foundation" must not be used to endorse or promote products derived
+ *    from this software without prior written permission. For written
+ *    permission, please contact apache at apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */

Added: trunk/org.prorefactor.lib/jakarta/commons-lang/RELEASE-NOTES.txt
===================================================================
--- trunk/org.prorefactor.lib/jakarta/commons-lang/RELEASE-NOTES.txt	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.lib/jakarta/commons-lang/RELEASE-NOTES.txt	2005-05-13 21:37:59 UTC (rev 28)
@@ -0,0 +1,661 @@
+$Id: RELEASE-NOTES.txt,v 1.26 2003/08/19 02:39:59 bayard Exp $
+
+                        Commons Lang Package
+                            Version 2.0
+                           Release Notes
+
+
+INTRODUCTION:
+
+This document contains the release notes for this version of the Commons
+Lang package. Commons Lang is a set of utility functions and reusable 
+components that should be a help in any Java environment.
+
+This release has involved a major clean and tidy exercise.
+Javadoc and Tests are now much more thorough.
+All methods should now be much clearer in what they do in unusual cases.
+
+
+INCOMPATIBLE CHANGES:
+Some StringUtils methods have changed functionality from 1.0:
+    isEmpty()
+    chomp(String)
+    chomp(String,String)
+    swapCase(String)
+Numerous other methods have changed null handling to accept nulls gracefully.
+As with all major version releases, check your code for incompatibilities.
+
+
+NEW FEATURES:
+
+Since the release of the 1.0 package the following classes have been added:
+
+lang package:
+    ArrayUtils
+    BitField
+    BooleanUtils
+    CharRange (previously package scoped)
+    ClassUtils
+    StringEscapeUtils
+    WordUtils
+    IllegalClassException
+    IncompleteArgumentException
+    NotImplementedException
+    NullArgumentException
+    SerializationException
+    UnhandledException
+    Validate
+
+
+math sub-package:
+    IntRange
+    LongRange
+    Range
+    DoubleRange
+    JVMRandom
+    NumberRange
+    FloatRange
+    NumberUtils
+    Fraction
+    RandomUtils
+
+time sub-package: 
+    DateFormatUtils
+    FastDateFormat
+    DateUtils
+    StopWatch
+
+Since the release of the 1.0 package the following classes have been changed:
+
+lang:
+    CharSet:
+        Added factory method, equals and hashCode().
+        Better defined and tested the set syntax.
+    CharSetUtils:
+        added keep method:  keep any characters specified in the CharSet string
+    RandomStringUtils:
+        random method:  overloaded to allow passing in of a Random class
+    SerializationUtils:
+        added empty constructor
+    StringUtils:
+        isEmpty() changed to not trim
+        chomp() changed to be more like Perl.
+        swapCase() no longer word based, but no difference if you pass in ASCII
+        Various methods changed in the handling of null (less exceptions).
+        Many new methods.
+        Various methods deprecated.
+    SystemUtils:
+        isJavaVersionAtLeast(int) added. getJavaVersion() deprecated.
+        host of new constants.
+
+enum:
+    Enum:
+        getEnumClass(Class) added
+    EnumUtils:
+        Removed irrelevant Comparable/Serializable interfaces.
+
+exception:
+    NestableDelegate:
+        Gained many new methods for dissecting an Exception.
+    ExceptionUtils:
+        Gained many new methods to improve handling of nested stack traces.
+        
+builder:
+    ReflectionToStringBuilder:
+        Handy class added for creating default toStrings.
+    All other builder classes received a set of new methods.
+
+
+BUG FIXES:
+
+ID Sev Pri Plt Owner State Result Summary 
+13367  [PATCH] StringUtil enhancement  
+13391  Javadoc nit  
+13771  Additional Lang Method Suggestions  
+14306  NullPointerException in CompareToBuilder  
+14357  static option for reversing the stacktrace  
+14447  ToStringBuilder doesn't work well in subclasses  
+14883  StringUtils.countMatches loops forever if substring empty  
+14884  NumberRange inaccurate for Long, etc.  
+14985  More flexibility for getRootCause in ExceptionUtils  
+15154  SystemUtils.IS_JAVA_1_5 Javadoc is wrong  
+15257  Hierarchy support in ToStringBuilder.reflectionToString()  
+15438  ArrayUtils.contains()  
+15439  Enum does not support inner sub-classes  
+15986  Infinite loop in ToStringBuilder.reflectionToString for inne  
+16076  Example in Javadoc for ToStringBuilder wrong for append.  
+16193  Hierarchy support in EqualsBuilder.reflectionEquals()  
+16202  typo in the javadoc example code  
+16204  Infinite loop in StringUtils.replace(text, repl, with) + FIX  
+16227  Added class hierachy support to CompareToBuilder.reflectionC  
+16228  Added class hierachy support to HashCodeBuilder.reflectionHa  
+16284  MethodUtils: Removed unused code/unused local vars.  
+16341  No Javadoc for NestableDelegate  
+16622  Removed compile warning in FastDateFormat  
+16669  JavaDoc Errata  
+16676  StackOverflow due to ToStringBuilder  
+16689  ExceptionUtils new methods.  
+16690  Specify initial size for Enum's HashMap.  
+16787  Removed compile warning in ObjectUtils  
+17250  [Lang] Should ToStringBuilder.reflectionToString handle arra  
+17654  EnumUtils nit: The import java.io.Serializable is never used  
+17882  Add join(..., char c) to StringUtils (and some performance f  
+18077  StringUtils.chomp does not match Perl  
+18723  RandomStringUtils infloops with length < 1  
+18836  test.lang fails if compiled with non iso-8859-1 locales  
+18948  Resurrect the WordWrapUtils from commons-sandbox/utils  
+19296  [Lang] What to do with FastDateFormat unused private constru  
+19364  [Lang] time unit tests fail on Sundays  
+19756  [lang] java.lang.ExceptionInInitializerError thrown by JVMRa  
+19880  [lang] patch and test case fixing problem with RandomStringU  
+20165  [LANG] SystemUtils does not play nice in an Applet  
+20538  [lang] NumberUtils.isNumber allows illegal trailing characte  
+20592  [lang] RandomStringUtils.randomAlpha methods omit 'z'  
+20603  [lang] Make NestableDelegate methods public instead of packa  
+20632  Refactored reflection feature of ToStringBuilder into new Re  
+20652  StringUtils.chopNewLine - StringIndexOutOfBoundsException  
+21021  [PATCH] reduce object creation in ToStringBuilder  
+21068  [lang] [PATCH] NumberUtils min/max, BooleanUtils.xor, and Ar  
+21099  [lang][PATCH] Unused field 'startFinal' in DateIterator  
+21715  The javadoc says "Mac" instead of "OS/2"
+21734  [PATCH] all NumberUtils.createXXX(String) methods handle null
+21750  [lang] StringUtils javadoc and test enhancements
+21758  [lang] lang.builder classes javadoc edits (mostly typo fixes)
+21797  [lang] Add javadoc examples and tests for StringUtils
+21809  [lang] maven-beta10 checkstyle problem
+21904  NumberUtils.createBigDecimal("") NPE in Sun 1.3.1_08
+21952  [lang] Improved tests, javadoc for CharSetUtils, StringEscapeUtils
+22091  Adding tolerance to double[] search methods in ArrayUtils
+22094  A small, but important javadoc fix for Fraction proper whole/numerator
+22095  [lang] Javadoc, tests improvements for CharSet, CharSetUtils
+22098  [lang] Improve util.Validate tests
+22245  [lang] test.time fails in Japanese (non-us) locale.
+22286  [lang] Missing @since tags
+22367  Typo in documentation
+22386  [lang] Improve javadoc and overflow behavior of Fraction
+
+
+DEPRECATIONS:
+
+lang:
+    NumberRange:
+        now deprecated, see math subpackage
+    NumberUtils:
+        now deprecated, see math subpackage
+
+
+CHANGES:   [In 'diff' format]
+
+Jar changes
+===========
+> org.apache.commons.lang.math.Range
+> org.apache.commons.lang.math.FloatRange
+> org.apache.commons.lang.math.NumberUtils
+> org.apache.commons.lang.math.JVMRandom
+> org.apache.commons.lang.math.IntRange
+> org.apache.commons.lang.math.LongRange
+> org.apache.commons.lang.math.DoubleRange
+> org.apache.commons.lang.math.NumberRange
+> org.apache.commons.lang.math.Fraction
+> org.apache.commons.lang.math.RandomUtils
+> org.apache.commons.lang.time.FastDateFormat
+> org.apache.commons.lang.time.DateUtils$DateIterator
+> org.apache.commons.lang.time.DateUtils
+> org.apache.commons.lang.time.FastDateFormat$UnpaddedMonthField
+> org.apache.commons.lang.time.FastDateFormat$StringLiteral
+> org.apache.commons.lang.time.FastDateFormat$TwelveHourField
+> org.apache.commons.lang.time.FastDateFormat$NumberRule
+> org.apache.commons.lang.time.FastDateFormat$CharacterLiteral
+> org.apache.commons.lang.time.FastDateFormat$TimeZoneNumberRule
+> org.apache.commons.lang.time.FastDateFormat$TimeZoneNameRule
+> org.apache.commons.lang.time.DateFormatUtils
+> org.apache.commons.lang.time.FastDateFormat$TwoDigitMonthField
+> org.apache.commons.lang.time.DurationFormatUtils
+> org.apache.commons.lang.time.FastDateFormat$TimeZoneDisplayKey
+> org.apache.commons.lang.time.FastDateFormat$UnpaddedNumberField
+> org.apache.commons.lang.time.FastDateFormat$PaddedNumberField
+> org.apache.commons.lang.time.StopWatch
+> org.apache.commons.lang.time.FastDateFormat$TwentyFourHourField
+> org.apache.commons.lang.time.FastDateFormat$Rule
+> org.apache.commons.lang.time.FastDateFormat$TwoDigitNumberField
+> org.apache.commons.lang.time.FastDateFormat$TextField
+> org.apache.commons.lang.time.FastDateFormat$Pair
+> org.apache.commons.lang.time.FastDateFormat$TwoDigitYearField
+> org.apache.commons.lang.util.IdentifierUtils$StringNumericIdentifierFactory
+> org.apache.commons.lang.util.IdentifierUtils$StringSessionIdentifierFactory
+> org.apache.commons.lang.util.IdentifierUtils$LongNumericIdentifierFactory
+> org.apache.commons.lang.util.IdentifierUtils$StringAlphanumericIdentifierFactory
+> org.apache.commons.lang.util.Validate
+> org.apache.commons.lang.util.LongIdentifierFactory
+> org.apache.commons.lang.util.IdentifierUtils$1
+> org.apache.commons.lang.util.StringIdentifierFactory
+> org.apache.commons.lang.util.IdentifierUtils
+> org.apache.commons.lang.util.IdentifierFactory
+> org.apache.commons.lang.util.BitField
+> org.apache.commons.lang.Entities
+> org.apache.commons.lang.Entities$LookupEntityMap
+> org.apache.commons.lang.NotImplementedException
+> org.apache.commons.lang.NullArgumentException
+< org.apache.commons.lang.ObjectUtils$1
+---
+> org.apache.commons.lang.StringPrintWriter
+> org.apache.commons.lang.UnhandledException
+> org.apache.commons.lang.Entities$HashEntityMap
+> org.apache.commons.lang.Entities$ArrayEntityMap
+> org.apache.commons.lang.Entities$EntityMap
+> org.apache.commons.lang.IntHashMap
+> org.apache.commons.lang.BooleanUtils
+> org.apache.commons.lang.IncompleteArgumentException
+> org.apache.commons.lang.Entities$PrimitiveEntityMap
+> org.apache.commons.lang.Entities$TreeEntityMap
+> org.apache.commons.lang.WordUtils
+> org.apache.commons.lang.StringEscapeUtils
+> org.apache.commons.lang.ArrayUtils
+> org.apache.commons.lang.Entities$BinaryEntityMap
+> org.apache.commons.lang.ClassUtils
+> org.apache.commons.lang.IntHashMap$Entry
+> org.apache.commons.lang.IllegalClassException
+> org.apache.commons.lang.builder.ReflectionToStringBuilder$1
+> org.apache.commons.lang.builder.ReflectionToStringBuilder
+> org.apache.commons.lang.Entities$MapIntMap
+
+
+Class changes
+=============
+org.apache.commons.lang.enum.EnumUtils
+--------------------
+< public abstract class org.apache.commons.lang.enum.EnumUtils extends java.lang.Object implements java.lang.Comparable, java.io.Serializable {
+---
+> public class org.apache.commons.lang.enum.EnumUtils extends java.lang.Object {
+>     public org.apache.commons.lang.enum.EnumUtils();
+
+org.apache.commons.lang.enum.Enum$Entry
+--------------------
+>     final java.util.Map unmodifiableMap;
+>     final java.util.List unmodifiableList;
+
+org.apache.commons.lang.enum.Enum
+--------------------
+>     protected transient java.lang.String iToString;
+>     static java.lang.Class class$org$apache$commons$lang$enum$ValuedEnum;
+>     public java.lang.Class getEnumClass();
+
+org.apache.commons.lang.enum.ValuedEnum
+--------------------
+>     static {};
+
+org.apache.commons.lang.StringUtils
+--------------------
+>     public static final java.lang.String EMPTY;
+>     public static boolean isEmpty(java.lang.String);
+>     public static boolean isNotEmpty(java.lang.String);
+>     public static boolean isBlank(java.lang.String);
+>     public static boolean isNotBlank(java.lang.String);
+<     public static java.lang.String deleteSpaces(java.lang.String);
+<     public static java.lang.String deleteWhitespace(java.lang.String);
+<     public static boolean isNotEmpty(java.lang.String);
+<     public static boolean isEmpty(java.lang.String);
+---
+>     public static java.lang.String trimToNull(java.lang.String);
+>     public static java.lang.String trimToEmpty(java.lang.String);
+>     public static java.lang.String strip(java.lang.String);
+>     public static java.lang.String stripToNull(java.lang.String);
+>     public static java.lang.String stripToEmpty(java.lang.String);
+>     public static java.lang.String strip(java.lang.String, java.lang.String);
+>     public static java.lang.String stripStart(java.lang.String, java.lang.String);
+>     public static java.lang.String stripEnd(java.lang.String, java.lang.String);
+>     public static java.lang.String stripAll(java.lang.String[])[];
+>     public static java.lang.String stripAll(java.lang.String[], java.lang.String)[];
+>     public static int indexOf(java.lang.String, char);
+>     public static int indexOf(java.lang.String, char, int);
+>     public static int indexOf(java.lang.String, java.lang.String);
+>     public static int indexOf(java.lang.String, java.lang.String, int);
+>     public static int lastIndexOf(java.lang.String, char);
+>     public static int lastIndexOf(java.lang.String, char, int);
+>     public static int lastIndexOf(java.lang.String, java.lang.String);
+>     public static int lastIndexOf(java.lang.String, java.lang.String, int);
+>     public static boolean contains(java.lang.String, char);
+>     public static boolean contains(java.lang.String, java.lang.String);
+>     public static int indexOfAny(java.lang.String, char[]);
+>     public static int indexOfAny(java.lang.String, java.lang.String);
+>     public static int indexOfAnyBut(java.lang.String, char[]);
+>     public static int indexOfAnyBut(java.lang.String, java.lang.String);
+>     public static boolean containsOnly(java.lang.String, char[]);
+>     public static boolean containsOnly(java.lang.String, java.lang.String);
+>     public static boolean containsNone(java.lang.String, char[]);
+>     public static boolean containsNone(java.lang.String, java.lang.String);
+>     public static java.lang.String substringBefore(java.lang.String, java.lang.String);
+>     public static java.lang.String substringAfter(java.lang.String, java.lang.String);
+>     public static java.lang.String substringBeforeLast(java.lang.String, java.lang.String);
+>     public static java.lang.String substringAfterLast(java.lang.String, java.lang.String);
+>     public static java.lang.String substringBetween(java.lang.String, java.lang.String);
+>     public static java.lang.String substringBetween(java.lang.String, java.lang.String, java.lang.String);
+>     public static java.lang.String getNestedString(java.lang.String, java.lang.String);
+>     public static java.lang.String getNestedString(java.lang.String, java.lang.String, java.lang.String);
+>     public static java.lang.String split(java.lang.String, char)[];
+>     public static java.lang.String join(java.lang.Object[]);
+>     public static java.lang.String join(java.lang.Object[], char);
+>     public static java.lang.String join(java.util.Iterator, char);
+>     public static java.lang.String deleteSpaces(java.lang.String);
+>     public static java.lang.String deleteWhitespace(java.lang.String);
+>     public static java.lang.String replaceChars(java.lang.String, char, char);
+>     public static java.lang.String replaceChars(java.lang.String, java.lang.String, java.lang.String);
+<     public static java.lang.String center(java.lang.String, int);
+<     public static java.lang.String center(java.lang.String, int, java.lang.String);
+---
+>     public static java.lang.String overlay(java.lang.String, java.lang.String, int, int);
+>     public static java.lang.String rightPad(java.lang.String, int, char);
+>     public static java.lang.String leftPad(java.lang.String, int, char);
+<     public static java.lang.String strip(java.lang.String);
+<     public static java.lang.String strip(java.lang.String, java.lang.String);
+<     public static java.lang.String stripAll(java.lang.String[])[];
+<     public static java.lang.String stripAll(java.lang.String[], java.lang.String)[];
+<     public static java.lang.String stripEnd(java.lang.String, java.lang.String);
+<     public static java.lang.String stripStart(java.lang.String, java.lang.String);
+---
+>     public static java.lang.String center(java.lang.String, int);
+>     public static java.lang.String center(java.lang.String, int, char);
+>     public static java.lang.String center(java.lang.String, int, java.lang.String);
+<     public static java.lang.String uncapitalise(java.lang.String);
+---
+>     public static java.lang.String capitalize(java.lang.String);
+>     public static java.lang.String uncapitalize(java.lang.String);
+>     public static java.lang.String uncapitalise(java.lang.String);
+<     public static java.lang.String getNestedString(java.lang.String, java.lang.String);
+<     public static java.lang.String getNestedString(java.lang.String, java.lang.String, java.lang.String);
+>     public static boolean isWhitespace(java.lang.String);
+>     public static java.lang.String reverseDelimited(java.lang.String, char);
+>     public static java.lang.String abbreviate(java.lang.String, int);
+>     public static java.lang.String abbreviate(java.lang.String, int, int);
+>     public static java.lang.String difference(java.lang.String, java.lang.String);
+>     public static int differenceAt(java.lang.String, java.lang.String);
+<     public static boolean containsOnly(java.lang.String, char[]);
+---
+>     static {};
+
+org.apache.commons.lang.ObjectUtils
+--------------------
+>     public static java.lang.StringBuffer appendIdentityToString(java.lang.StringBuffer, java.lang.Object);
+>     public static java.lang.String toString(java.lang.Object);
+>     public static java.lang.String toString(java.lang.Object, java.lang.String);
+<         org.apache.commons.lang.ObjectUtils.Null(org.apache.commons.lang.ObjectUtils$1);
+---
+>         org.apache.commons.lang.ObjectUtils.Null();
+>         static {};
+
+org.apache.commons.lang.exception.NestableDelegate
+--------------------
+>     public static boolean topDown;
+>     public static boolean trimStackFrames;
+<     org.apache.commons.lang.exception.NestableDelegate(org.apache.commons.lang.exception.Nestable);
+<     java.lang.String getMessage(int);
+<     java.lang.String getMessage(java.lang.String);
+<     java.lang.String getMessages()[];
+<     java.lang.Throwable getThrowable(int);
+<     int getThrowableCount();
+<     java.lang.Throwable getThrowables()[];
+<     int indexOfThrowable(java.lang.Class, int);
+---
+>     public org.apache.commons.lang.exception.NestableDelegate(org.apache.commons.lang.exception.Nestable);
+>     public java.lang.String getMessage(int);
+>     public java.lang.String getMessage(java.lang.String);
+>     public java.lang.String getMessages()[];
+>     public java.lang.Throwable getThrowable(int);
+>     public int getThrowableCount();
+>     public java.lang.Throwable getThrowables()[];
+>     public int indexOfThrowable(java.lang.Class, int);
+>     protected java.lang.String getStackFrames(java.lang.Throwable)[];
+>     protected void trimStackFrames(java.util.List);
+
+org.apache.commons.lang.exception.ExceptionUtils
+--------------------
+<     protected static final java.lang.String CAUSE_METHOD_NAMES[];
+<     protected static final java.lang.Object CAUSE_METHOD_PARAMS[];
+---
+>     static final java.lang.String WRAPPED_MARKER;
+<     protected org.apache.commons.lang.exception.ExceptionUtils();
+---
+>     public org.apache.commons.lang.exception.ExceptionUtils();
+>     public static void addCauseMethodName(java.lang.String);
+>     public static boolean isThrowableNested();
+>     public static boolean isNestedThrowable(java.lang.Throwable);
+>     public static void printRootCauseStackTrace(java.lang.Throwable);
+>     public static void printRootCauseStackTrace(java.lang.Throwable, java.io.PrintStream);
+>     public static void printRootCauseStackTrace(java.lang.Throwable, java.io.PrintWriter);
+>     public static java.lang.String getRootCauseStackTrace(java.lang.Throwable)[];
+>     public static void removeCommonFrames(java.util.List, java.util.List);
+>     public static java.lang.String getFullStackTrace(java.lang.Throwable);
+>     static java.util.List getStackFrameList(java.lang.Throwable);
+
+org.apache.commons.lang.CharRange
+--------------------
+< class org.apache.commons.lang.CharRange extends java.lang.Object {
+---
+> public final class org.apache.commons.lang.CharRange extends java.lang.Object implements java.io.Serializable {
+>     public org.apache.commons.lang.CharRange(char,boolean);
+<     public org.apache.commons.lang.CharRange(java.lang.String,java.lang.String);
+---
+>     public org.apache.commons.lang.CharRange(char,char,boolean);
+<     public void setStart(char);
+<     public void setEnd(char);
+<     public boolean isRange();
+<     public boolean inRange(char);
+<     public void setNegated(boolean);
+---
+>     public boolean contains(char);
+>     public boolean contains(org.apache.commons.lang.CharRange);
+>     public boolean equals(java.lang.Object);
+>     public int hashCode();
+>     static {};
+
+org.apache.commons.lang.ObjectUtils$1
+--------------------
+< Compiled from ObjectUtils.java
+< class org.apache.commons.lang.ObjectUtils$1 extends java.lang.Object {
+< }
+---
+> Class 'org.apache.commons.lang.ObjectUtils$1' has been removed
+
+org.apache.commons.lang.ObjectUtils$Null
+--------------------
+<     org.apache.commons.lang.ObjectUtils.Null(org.apache.commons.lang.ObjectUtils$1);
+---
+>     org.apache.commons.lang.ObjectUtils.Null();
+>     static {};
+
+org.apache.commons.lang.SystemUtils
+--------------------
+>     public static final java.lang.String FILE_ENCODING;
+>     public static final java.lang.String JAVA_RUNTIME_NAME;
+>     public static final java.lang.String JAVA_RUNTIME_VERSION;
+>     public static final java.lang.String JAVA_VM_INFO;
+>     public static final java.lang.String USER_COUNTRY;
+>     public static final java.lang.String USER_LANGUAGE;
+>     public static final float JAVA_VERSION_FLOAT;
+>     public static final int JAVA_VERSION_INT;
+>     public static final boolean IS_OS_AIX;
+>     public static final boolean IS_OS_HP_UX;
+>     public static final boolean IS_OS_IRIX;
+>     public static final boolean IS_OS_LINUX;
+>     public static final boolean IS_OS_MAC;
+>     public static final boolean IS_OS_MAC_OSX;
+>     public static final boolean IS_OS_OS2;
+>     public static final boolean IS_OS_SOLARIS;
+>     public static final boolean IS_OS_SUN_OS;
+>     public static final boolean IS_OS_WINDOWS;
+>     public static final boolean IS_OS_WINDOWS_2000;
+>     public static final boolean IS_OS_WINDOWS_95;
+>     public static final boolean IS_OS_WINDOWS_98;
+>     public static final boolean IS_OS_WINDOWS_ME;
+>     public static final boolean IS_OS_WINDOWS_NT;
+>     public static final boolean IS_OS_WINDOWS_XP;
+>     public static boolean isJavaVersionAtLeast(int);
+
+org.apache.commons.lang.SerializationUtils
+--------------------
+>     public org.apache.commons.lang.SerializationUtils();
+
+org.apache.commons.lang.RandomStringUtils
+--------------------
+>     public static java.lang.String random(int, int, int, boolean, boolean, char[], java.util.Random);
+
+org.apache.commons.lang.CharSet
+--------------------
+< public class org.apache.commons.lang.CharSet extends java.lang.Object {
+---
+> public class org.apache.commons.lang.CharSet extends java.lang.Object implements java.io.Serializable {
+>     public static final org.apache.commons.lang.CharSet EMPTY;
+>     public static final org.apache.commons.lang.CharSet ASCII_ALPHA;
+>     public static final org.apache.commons.lang.CharSet ASCII_ALPHA_LOWER;
+>     public static final org.apache.commons.lang.CharSet ASCII_ALPHA_UPPER;
+>     public static final org.apache.commons.lang.CharSet ASCII_NUMERIC;
+>     protected static final java.util.Map COMMON;
+>     public static org.apache.commons.lang.CharSet getInstance(java.lang.String);
+>     protected org.apache.commons.lang.CharSet(java.lang.String);
+<     public boolean contains(char);
+>     public org.apache.commons.lang.CharRange getCharRanges()[];
+>     public boolean contains(char);
+>     public boolean equals(java.lang.Object);
+>     public int hashCode();
+>     static {};
+
+org.apache.commons.lang.CharSetUtils
+--------------------
+>     public static java.lang.String keep(java.lang.String, java.lang.String);
+>     public static java.lang.String keep(java.lang.String, java.lang.String[]);
+
+org.apache.commons.lang.builder.ToStringBuilder
+--------------------
+<     public org.apache.commons.lang.builder.ToStringBuilder(java.lang.Object);
+<     public org.apache.commons.lang.builder.ToStringBuilder(java.lang.Object,org.apache.commons.lang.builder.ToStringStyle);
+<     public org.apache.commons.lang.builder.ToStringBuilder(java.lang.Object,org.apache.commons.lang.builder.ToStringStyle,java.lang.StringBuffer);
+<     public static void setDefaultStyle(org.apache.commons.lang.builder.ToStringStyle);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.Object);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, java.lang.Object);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, java.lang.Object, boolean);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(long);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, long);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(int);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, int);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(short);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, short);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(char);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, char);
+---
+>     public static java.lang.String reflectionToString(java.lang.Object, org.apache.commons.lang.builder.ToStringStyle, boolean, java.lang.Class);
+>     public static void setDefaultStyle(org.apache.commons.lang.builder.ToStringStyle);
+>     public org.apache.commons.lang.builder.ToStringBuilder(java.lang.Object);
+>     public org.apache.commons.lang.builder.ToStringBuilder(java.lang.Object,org.apache.commons.lang.builder.ToStringStyle);
+>     public org.apache.commons.lang.builder.ToStringBuilder(java.lang.Object,org.apache.commons.lang.builder.ToStringStyle,java.lang.StringBuffer);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(boolean);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(boolean[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, byte);
+---
+>     public org.apache.commons.lang.builder.ToStringBuilder append(byte[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(char);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(char[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, double);
+---
+>     public org.apache.commons.lang.builder.ToStringBuilder append(double[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, float);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(boolean);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, boolean);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.Object[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, java.lang.Object[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, java.lang.Object[], boolean);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(long[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, long[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, long[], boolean);
+---
+>     public org.apache.commons.lang.builder.ToStringBuilder append(float[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(int);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, int[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, int[], boolean);
+---
+>     public org.apache.commons.lang.builder.ToStringBuilder append(long);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(long[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.Object);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.Object[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(short);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, short[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, short[], boolean);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(char[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, char[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, char[], boolean);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(byte[]);
+---
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, boolean);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, boolean[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, boolean[], boolean);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, byte);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(double[]);
+---
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, char);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, char[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, char[], boolean);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, double);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(float[]);
+---
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, float);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(boolean[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, boolean[]);
+<     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, boolean[], boolean);
+---
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, int);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, int[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, int[], boolean);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, long);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, long[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, long[], boolean);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, java.lang.Object);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, java.lang.Object, boolean);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, java.lang.Object[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, java.lang.Object[], boolean);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, short);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, short[]);
+>     public org.apache.commons.lang.builder.ToStringBuilder append(java.lang.String, short[], boolean);
+>     public org.apache.commons.lang.builder.ToStringBuilder appendAsObjectToString(java.lang.Object);
+>     public org.apache.commons.lang.builder.ToStringBuilder appendSuper(java.lang.String);
+>     public org.apache.commons.lang.builder.ToStringBuilder appendToString(java.lang.String);
+>     public org.apache.commons.lang.builder.ToStringStyle getStyle();
+>     public java.lang.Object getObject();
+
+org.apache.commons.lang.builder.StandardToStringStyle
+--------------------
+>     public boolean isUseShortClassName();
+>     public void setUseShortClassName(boolean);
+>     public boolean isFieldSeparatorAtStart();
+>     public void setFieldSeparatorAtStart(boolean);
+>     public boolean isFieldSeparatorAtEnd();
+>     public void setFieldSeparatorAtEnd(boolean);
+
+org.apache.commons.lang.builder.ToStringStyle
+--------------------
+>     public void appendSuper(java.lang.StringBuffer, java.lang.String);
+>     public void appendToString(java.lang.StringBuffer, java.lang.String);
+>     protected void removeLastFieldSeparator(java.lang.StringBuffer);
+>     protected void reflectionAppendArrayDetail(java.lang.StringBuffer, java.lang.String, java.lang.Object);
+>     protected boolean isUseShortClassName();
+>     protected void setUseShortClassName(boolean);
+>     protected boolean isFieldSeparatorAtStart();
+>     protected void setFieldSeparatorAtStart(boolean);
+>     protected boolean isFieldSeparatorAtEnd();
+>     protected void setFieldSeparatorAtEnd(boolean);
+
+org.apache.commons.lang.builder.HashCodeBuilder
+--------------------
+>     public static int reflectionHashCode(int, int, java.lang.Object, boolean, java.lang.Class);
+>     public org.apache.commons.lang.builder.HashCodeBuilder appendSuper(int);
+
+org.apache.commons.lang.builder.CompareToBuilder
+--------------------
+>     public static int reflectionCompare(java.lang.Object, java.lang.Object, boolean, java.lang.Class);
+>     public org.apache.commons.lang.builder.CompareToBuilder appendSuper(int);
+>     public org.apache.commons.lang.builder.CompareToBuilder append(java.lang.Object, java.lang.Object, java.util.Comparator);
+>     public org.apache.commons.lang.builder.CompareToBuilder append(java.lang.Object[], java.lang.Object[], java.util.Comparator);
+
+org.apache.commons.lang.builder.EqualsBuilder
+--------------------
+>     public static boolean reflectionEquals(java.lang.Object, java.lang.Object, boolean, java.lang.Class);
+>     public org.apache.commons.lang.builder.EqualsBuilder appendSuper(boolean);
+

Added: trunk/org.prorefactor.lib/jakarta/commons-lang/commons-lang.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-lang/commons-lang.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/jakarta/commons-lang/src.zip
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/jakarta/commons-lang/src.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/org.prorefactor.lib/plugin.xml
===================================================================
--- trunk/org.prorefactor.lib/plugin.xml	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.lib/plugin.xml	2005-05-13 21:37:59 UTC (rev 28)
@@ -13,9 +13,6 @@
       <library name="hsqldb/hsqldb.jar">
          <export name="*"/>
       </library>
-      <library name="hibernate/commons-lang-1.0.1.jar">
-         <export name="*"/>
-      </library>
       <library name="hibernate/commons-logging-1.0.4.jar">
          <export name="*"/>
       </library>
@@ -49,6 +46,9 @@
       <library name="jakarta/commons-io/commons-io.jar">
          <export name="*"/>
       </library>
+      <library name="jakarta/commons-lang/commons-lang.jar">
+         <export name="*"/>
+      </library>
    </runtime>
 
 </plugin>

Modified: trunk/org.prorefactor.refactor/.classpath
===================================================================
--- trunk/org.prorefactor.refactor/.classpath	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.refactor/.classpath	2005-05-13 21:37:59 UTC (rev 28)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src/"/>
-	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry exported="true" kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -29,9 +29,14 @@
 import java.util.List;
 import java.util.TreeMap;
 
+import org.apache.commons.collections.bidimap.DualHashBidiMap;
 import org.prorefactor.core.IConstants;
+import org.prorefactor.core.JPNode;
+import org.prorefactor.core.TokenTypes;
 import org.prorefactor.core.schema.Field;
 import org.prorefactor.core.schema.Table;
+import org.prorefactor.nodetypes.NodeFactory;
+import org.prorefactor.nodetypes.ProparseDirectiveNode;
 import org.prorefactor.refactor.source.CompileUnit;
 import org.prorefactor.treeparser.FieldBuffer;
 import org.prorefactor.treeparser.Symbol;
@@ -55,7 +60,7 @@
 		pubFile = new File(refpack.getProRefactorProjectDir() + "/pubs/" + relPath + ".pub");
 	}
 	
-	public static final int LAYOUT_VERSION = 2;
+	public static final int LAYOUT_VERSION = 3;
 
 	/** loadTo(PUBFILE_TIMESTAMP) - just check if the binary exists and
 	 * check that it is newer than the compile unit file. Does not read anything
@@ -72,18 +77,28 @@
 	public static final int IMPORTS = 30;
 	/** loadTo(EXPORTS) - new shared vars and public functions and procedures */
 	public static final int EXPORTS = 40;
-	/** loadTo(AST) - minimal node data for a functional syntax tree */
+	/** loadTo(AST) - just loads the node types - you almost certainly need STRINGS as well. */
 	public static final int AST = 50;
+	/** loadTo(STRINGS) - load the strings into the syntax tree. */
+	public static final int STRINGS = 60;
 	/** loadTo(END) - all binary file segments will be loaded. */
 	public static final int END = 100;
+	
+	/** Scratch JPNode attributes for storing string index. */
+	private static final int NODETEXT = 49001;
+	/** Scratch JPNode attributes for storing string index. */
+	private static final int NODECOMMENTS = 49002;
 
 	private ArrayList exportList;
 	private ArrayList fileList;
 	private ArrayList importList;
+	private DualHashBidiMap stringTable;
 	private File cuFile;
 	private File pubFile;
+	private JPNode tree;
 	private ProparseLdr parser = ProparseLdr.getInstance();
 	private RefactorSession refpack = RefactorSession.getInstance();
+	private String [] stringArray;
 	private TreeMap tableMap;
 
 	/** A record of symbol type and name, for import/export tables. */
@@ -114,6 +129,11 @@
 		fileList = new ArrayList();
 		importList = new ArrayList();
 		tableMap = new TreeMap();
+		stringTable = new DualHashBidiMap();
+		/* String index zero is not used.
+		 * This allows us to use 0 from JPNode.attrGet() to indicate "no string value present".
+		 */
+		stringIndex("");
 	}
 
 
@@ -138,6 +158,9 @@
 		writeSchemaSegment(out, allSymbols);
 		writeImportSegment(out, allSymbols);
 		writeExportSegment(out, allSymbols);
+		tree = cu.getTopNode();
+		writeTree(out, tree);
+		writeStrings(out);
 		out.close();
 		return cu;
 	}
@@ -223,6 +246,11 @@
 	}
 	
 	
+	
+	/** Return the JPNode syntax tree that was loaded with load() */
+	public JPNode getTree() { return tree; }
+	
+	
 
 	/** Same as loadTo(PUB.END) */
 	public boolean load() { return loadTo(END); }
@@ -253,6 +281,10 @@
 			if (lastSegmentToLoad==PUB.IMPORTS) return true;
 			readExportSegment(inStream);
 			if (lastSegmentToLoad==PUB.EXPORTS) return true;
+			tree = readTree(inStream);
+			if (lastSegmentToLoad==PUB.AST) return true;
+			readStrings(inStream);
+			setStrings(tree);
 		} catch (IOException e1) {
 			return false;
 		} finally {
@@ -312,6 +344,37 @@
 	
 	
 	
+	private void readStrings(ObjectInputStream in) throws IOException {
+		int size = in.readInt();
+		stringArray = new String[size];
+		for(int i = 0; i < size; i++) {
+			stringArray[i] = in.readUTF();
+		}
+	}
+	
+	
+	
+	private JPNode readTree(ObjectInputStream in) throws IOException {
+		int nodeClass = in.readInt();
+		if (nodeClass == -1) return null;
+		JPNode node = NodeFactory.createByIndex(nodeClass);
+		node.setType(in.readInt());
+		int key;
+		int value;
+		for (	key=in.readInt(), value=in.readInt()
+			;	key != -1
+			;	key=in.readInt(), value=in.readInt()
+			) {
+			node.attrSet(key, value);
+		}
+		node.setFirstChild(readTree(in));
+		node.setParentInChildren();
+		node.setNextSibling(readTree(in));
+		return node;
+	}
+	
+	
+	
 	/** Read the version, return false if the PUB file is out of date, true otherwise. */
 	private boolean readVersion(ObjectInputStream in) throws IOException {
 		if (in.readInt() != LAYOUT_VERSION) return false;
@@ -320,6 +383,30 @@
 	
 	
 	
+	private void setStrings(JPNode node) {
+		if (node==null) return;
+		int index;
+		if ((index=node.attrGet(NODETEXT)) > 0) node.setText(stringArray[index]);
+		if ((index=node.attrGet(NODECOMMENTS)) > 0) node.setComments(stringArray[index]);
+		if ((index=node.attrGet(IConstants.PROPARSEDIRECTIVE)) > 0)
+			((ProparseDirectiveNode)node).setDirectiveText(stringArray[index]);
+		setStrings(node.firstChild());
+		setStrings(node.nextSibling());
+	}
+	
+	
+	
+	private int stringIndex(String s) {
+		Integer index = (Integer) stringTable.getKey(s);
+		if (index==null) {
+			index = new Integer(stringTable.size()); // index is 0 if this is the first entry...
+			stringTable.put(index, s);
+		}
+		return index.intValue();
+	}
+	
+	
+	
 	private boolean testTimeStamps() {
 		long pubTime = pubFile.lastModified();
 		for (Iterator it = fileList.iterator(); it.hasNext();) {
@@ -374,6 +461,52 @@
 	
 	
 	
+	private void writeTree(ObjectOutputStream out, JPNode node) throws IOException {
+		out.writeInt(node.getSubtypeIndex());
+		out.writeInt(node.getType());
+		if ( ! TokenTypes.isKeyword(node.getType()) ) {
+			out.writeInt(NODETEXT);
+			out.writeInt(stringIndex(node.getText()));
+		}
+		String comments = node.getComments();
+		if (comments != null) {
+			out.writeInt(NODECOMMENTS);
+			out.writeInt(stringIndex(comments));
+		}
+		if (node.attrGet(IConstants.STATEHEAD) == IConstants.TRUE) {
+			out.writeInt(IConstants.STATEHEAD);
+			out.writeInt(IConstants.TRUE);
+			out.writeInt(IConstants.STATE2);
+			out.writeInt(node.getState2());
+		}
+		int attrVal;
+		if ( (attrVal = node.attrGet(IConstants.STORETYPE)) > 0 ) {
+			out.writeInt(IConstants.STORETYPE);
+			out.writeInt(attrVal);
+		}
+		if (node instanceof ProparseDirectiveNode) {
+			out.writeInt(IConstants.PROPARSEDIRECTIVE);
+			out.writeInt(stringIndex(((ProparseDirectiveNode)node).getDirectiveText()));
+		}
+		if ( (attrVal = node.attrGet(IConstants.OPERATOR)) > 0 ) {
+			out.writeInt(IConstants.OPERATOR);
+			out.writeInt(attrVal);
+		}
+		if ( (attrVal = node.attrGet(IConstants.INLINE_VAR_DEF)) > 0 ) {
+			out.writeInt(IConstants.INLINE_VAR_DEF);
+			out.writeInt(attrVal);
+		}
+		out.writeInt(-1);
+		out.writeInt(-1); // Terminate the attribute key/value pairs.
+		JPNode next;
+		if ( (next = node.firstChild()) != null ) writeTree(out, next);
+		else out.writeInt(-1);
+		if ( (next = node.nextSibling()) != null ) writeTree(out, next);
+		else out.writeInt(-1);
+	}
+	
+	
+	
 	private void writeSchemaSegment(ObjectOutputStream out, List allSymbols) throws IOException {
 		for (Iterator it = allSymbols.iterator(); it.hasNext();) {
 			Object obj = it.next();
@@ -411,6 +544,16 @@
 		tableMap.put(lowerName, tableRef);
 		return tableRef;
 	}
+	
+	
+	
+	private void writeStrings(ObjectOutputStream out) throws IOException {
+		int size = stringTable.size();
+		out.writeInt(size);
+		for(int i = 0; i < size; i++) {
+			out.writeUTF((String) stringTable.get(new Integer(i)));
+		}
+	}
 
 
 

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/unittest/PUBTest.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/unittest/PUBTest.java	2005-05-06 21:01:36 UTC (rev 27)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/unittest/PUBTest.java	2005-05-13 21:37:59 UTC (rev 28)
@@ -15,6 +15,7 @@
 import java.io.File;
 import java.util.ArrayList;
 
+import org.prorefactor.core.JPNode;
 import org.prorefactor.core.TokenTypes;
 import org.prorefactor.core.unittest.UnitTestBase2;
 import org.prorefactor.refactor.PUB;
@@ -85,6 +86,17 @@
 		assertTrue(exp.progressType == TokenTypes.FRAME);
 		assertTrue(exp.symbolName.equals("myFrame"));
 		
+		// Test that there are comments in front of the first real node
+		JPNode topNode = pub.getTree();
+		assertTrue(topNode.firstNaturalChild().getComments().length() > 2);
+		
+		// Test that the ID nodes have text.
+		JPNode [] idNodes = topNode.query(TokenTypes.ID);
+		for (int i = 0; i < idNodes.length; i++) {
+			JPNode node = idNodes[i];
+			assertTrue(node.getText().length() > 0);
+		}
+		
 	}
 
 }



From johnallengreen at sheep.berlios.de  Tue May 17 18:29:30 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Tue, 17 May 2005 18:29:30 +0200
Subject: [Prorefactor-svn] r30 - in trunk: org.prorefactor.antlr org.prorefactor.core/src/org/prorefactor/core org.prorefactor.lib org.prorefactor.lib/stringtemplate org.prorefactor.refactor/src/org/prorefactor/refactor
Message-ID: <200505171629.j4HGTUmS023053@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-17 18:29:26 +0200 (Tue, 17 May 2005)
New Revision: 30

Added:
   trunk/org.prorefactor.antlr/LICENSE.txt
   trunk/org.prorefactor.antlr/README.txt
   trunk/org.prorefactor.antlr/antlr.jar
   trunk/org.prorefactor.antlr/antlrsrc.zip
   trunk/org.prorefactor.antlr/version.txt
   trunk/org.prorefactor.lib/stringtemplate/
   trunk/org.prorefactor.lib/stringtemplate/doc.html
   trunk/org.prorefactor.lib/stringtemplate/release.html
   trunk/org.prorefactor.lib/stringtemplate/src.zip
   trunk/org.prorefactor.lib/stringtemplate/stringtemplate.jar
Modified:
   trunk/org.prorefactor.antlr/.classpath
   trunk/org.prorefactor.antlr/plugin.xml
   trunk/org.prorefactor.core/src/org/prorefactor/core/TokenTypes.java
   trunk/org.prorefactor.lib/.classpath
   trunk/org.prorefactor.lib/build.properties
   trunk/org.prorefactor.lib/plugin.xml
   trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java
Log:
Updated antlr to 2.7.5.
Removed antlr src directory, added antlr src.zip.
In TokenTypes, added default text for operators and punctuation, so that we aren't storing text strings for those nodes in the PUB files.
In TokenTypes, renamed isKeyword and getKeywordText to hasDefaultText and getDefaultText.
Added StringTemplate to ProRefactor's libraries.

Modified: trunk/org.prorefactor.antlr/.classpath
===================================================================
--- trunk/org.prorefactor.antlr/.classpath	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.antlr/.classpath	2005-05-17 16:29:26 UTC (rev 30)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry exported="true" sourcepath="antlrsrc.zip" kind="lib" path="antlr.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Added: trunk/org.prorefactor.antlr/LICENSE.txt
===================================================================
--- trunk/org.prorefactor.antlr/LICENSE.txt	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.antlr/LICENSE.txt	2005-05-17 16:29:26 UTC (rev 30)
@@ -0,0 +1,31 @@
+
+SOFTWARE RIGHTS
+
+ANTLR 1989-2004 Developed by Terence Parr
+Partially supported by University of San Francisco & jGuru.com
+
+We reserve no legal rights to the ANTLR--it is fully in the
+public domain. An individual or company may do whatever
+they wish with source code distributed with ANTLR or the
+code generated by ANTLR, including the incorporation of
+ANTLR, or its output, into commerical software.
+
+We encourage users to develop software with ANTLR. However,
+we do ask that credit is given to us for developing
+ANTLR. By "credit", we mean that if you use ANTLR or
+incorporate any source code into one of your programs
+(commercial product, research project, or otherwise) that
+you acknowledge this fact somewhere in the documentation,
+research report, etc... If you like ANTLR and have
+developed a nice tool with the output, please mention that
+you developed it using ANTLR. In addition, we ask that the
+headers remain intact in our source code. As long as these
+guidelines are kept, we expect to continue enhancing this
+system and expect to make other tools available as they are
+completed.
+
+The primary ANTLR guy:
+
+Terence Parr
+parrt at cs.usfca.edu
+parrt at antlr.org

Added: trunk/org.prorefactor.antlr/README.txt
===================================================================
--- trunk/org.prorefactor.antlr/README.txt	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.antlr/README.txt	2005-05-17 16:29:26 UTC (rev 30)
@@ -0,0 +1,362 @@
+                            A N T L R 
+======================================================================
+ *SOFTWARE RIGHTS*
+
+ ANTLR 1989-2004 Developed by Terence Parr
+ Partially supported by University of San Francisco & jGuru.com
+
+ We reserve no legal rights to the ANTLR--it is fully in the
+ public domain. An individual or company may do whatever
+ they wish with source code distributed with ANTLR or the
+ code generated by ANTLR, including the incorporation of
+ ANTLR, or its output, into commerical software.
+
+ We encourage users to develop software with ANTLR. However,
+ we do ask that credit is given to us for developing
+ ANTLR. By "credit", we mean that if you use ANTLR or
+ incorporate any source code into one of your programs
+ (commercial product, research project, or otherwise) that
+ you acknowledge this fact somewhere in the documentation,
+ research report, etc... If you like ANTLR and have
+ developed a nice tool with the output, please mention that
+ you developed it using ANTLR. In addition, we ask that the
+ headers remain intact in our source code. As long as these
+ guidelines are kept, we expect to continue enhancing this
+ system and expect to make other tools available as they are
+ completed.
+
+ The primary ANTLR guy:
+
+ Terence Parr
+ parrt at cs.usfca.edu
+ parrt at antlr.org
+
+______________________________________________________________________
+
+WELCOME TO ANTLR!
+
+If you have problems or think you have found a bug in ANTLR, see the
+section BUGS in the ANTLR manual.
+
+Please consult the INSTALL.txt file for information on tested
+configurations.  If you have a comment about an already tested
+configuration, or have tried ANTKR on a new configuration, please let 
+us know as described in INSTALL.txt. Free software only works if we 
+all help out.
+
+Finally, we cannot guarantee that this release will not completely 
+wipe out all of your work from your system.  We do some simple testing 
+before each release, but you are completely on your own.  We recommend
+testing this release on a source repository that is not critical to 
+your work.  
+
+         THIS SOFTWARE IS SUPPLIED COMPLETELY "AS IS".  
+                       NO WARRANTY....
+
+Thanks for your support!
+
+  -The ANTLR Team-
+
+______________________________________________________________________
+
+WHAT IS ANTLR?
+
+ ANTLR, (AN)other (T)ool for (L)anguage (R)ecognition - formerly known 
+ as PCCTS - is a language tool that provides a framework for 
+ constructing recognizers, compilers, and translators from grammatical 
+ descriptions containing actions in the following languages:
+
+  Java, 
+  C++, 
+  C# or
+  Python
+ 
+ (You can use PCCTS 1.xx to generate C-based parsers).
+
+ Computer language translation has become a common task. While 
+ compilers and tools for traditional computer languages (such as C or 
+ Java) are still being built, their number is dwarfed by the thousands 
+ of mini-languages for which recognizers and translators are being 
+ developed. Programmers construct translators for database formats, 
+  graphical data files (e.g., PostScript, AutoCAD), text processing
+ files (e.g., HTML, SGML).  ANTLR is designed to handle all of your 
+ translation tasks.
+
+ Prof. Terence Parr has been working on ANTLR since 1989 and, together
+ with his colleagues, has made a number of fundamental contributions
+ to parsing theory and language tool construction, leading to the 
+ resurgence of LL(k)-based recognition tools.
+
+ Have a look at the history section at the end of this document on 
+ how ANTLR has evolved over time. For  most  up-to-date informaton 
+ read http://www.antlr.org/history.html.
+______________________________________________________________________
+
+UPGRADING?
+
+ See
+
+   http://www.antlr.org/blog/CHANGES-2.7.5.txt
+
+ for a description of features new in this version. There are no
+ incompatibilties known to a previous 2.7.x installation. If you found
+ a problem please let us know.
+
+______________________________________________________________________
+
+
+INSTALLATION?
+
+ Please read the INSTALL.txt file for installation instructions. The
+ brief summary is:
+
+  $ ./configure 
+  $ make
+  $ make test         # optional
+  $ su root           # optional
+  $ make install
+
+______________________________________________________________________
+
+ANTLR IS INSTALLED - WHAT'S NEXT?
+
+ Please read "doc/getting-started.html" on what you are supposed to
+ do. Here's a very brief summary for the impatient:
+
+ ANTLR is a command line tool. To run ANTLR you need to have JAVA
+ installed. The basic steps are:
+
+  a. write a grammar file - mygrammar.g
+
+  b. run ANTLR like
+
+       $ CLASSPATH=antlr.jar
+
+       $ java antlr.Tool mygrammar.g
+
+  c. write a driver program using source code generated by ANTLR, ie.
+     Main.java, main.cpp, Main.cs or main.py
+
+  d. link generated code, your driver code, ANTLR's core library and
+     any additional library you are using together to get an 
+     executable
+
+  f. run the executable on arbitrary input to be parsed
+
+ For a set of standard examples have a look into directory "examples"
+ and appropriate subdirectories.
+
+______________________________________________________________________
+
+WANT TO KNOW MORE?
+  
+ The documentation is in the "doc" subdirectory and "index.html" is 
+ the main entry point. 
+
+ Further information available at
+
+ http://www.antlr.org
+
+______________________________________________________________________
+
+WHO CONTRIBUTED TO THIS MESS?
+
+ Project Lead and Supreme Dictator Terence Parr, University of San 
+ Franciso
+
+ Help with initial coding John Lilly, Empathy Software 
+
+ C++ code generator by Peter Wells and Ric Klaren
+
+ C# code generation by Micheal Jordan, Kunle Odutola and Anthony 
+ Oguntimehin. 
+
+ Python's universe has been extended by Wolfgang H?felinger and Marq 
+ Kole
+
+ Substantial intellectual effort donated by Loring Craymer, Monty 
+ Zukowski, Jim Coker, Scott Stanchfield, John Mitchell, Chapman 
+ Flack (UNICODE, streams)
+
+ Source changes for Eclipse and NetBeans by Marco van Meegen and 
+ Brian Smith
+
+ Infrastructure support from Perforce - The world's best source 
+ code control system
+
+
+______________________________________________________________________
+
+WANNA KNOW ABOUT ANTLR's HISTORY?
+
+ The PCCTS project began as a parser-generator project for a graduate 
+ course at Purdue University in the Fall of 1988 taught by Hank Dietz
+ "translator-writing systems". Under the guidance of Professor Dietz, 
+ the parser generator, ANTLR (originally called YUCC), continued after
+ the termination of the course and eventually became the subject of 
+ Terence Parr?s Master?s thesis. Originally, lexical analysis was 
+ performed via a simple scanner generator which was soon replaced by 
+ Will Cohen?s DLG in the Fall of 1989 (DFA-based lexical-analyzer 
+ generator, also an offshoot of the graduate translation course). 
+
+ The alpha version of ANTLR was totally rewritten resulting in 1.00B. 
+ Version 1.00B was released via an internet newsgroup (comp.compilers) 
+ posting in February of 1990 and quickly gathered a large following. 
+ 1.00B generated only LL(1) parsers, but allowed the merged 
+ description of lexical and syntactic analysis. It had rudimentary 
+ attribute handling similar to that of YACC and did not incorporate 
+ rule parameters or return values; downward inheritance was very 
+ awkward. 1.00B-generated parsers terminated upon the first syntax 
+ error. Lexical classes (modes) were not allowed and DLG did not have
+ an interactive mode. 
+
+ Upon starting his Ph.D. at Purdue in the Fall of 1990, Terence Parr
+ began the second total rewrite of ANTLR. The method by which grammars
+ may be practically analyzed to generate LL(k) lookahead information 
+ was discovered in August of 1990 just before Terence?s return to 
+ Purdue. Version 1.00 incorporated this algorithm and included the AST
+ mechanism, lexical classes, error classes, and automatic error 
+ recovery; code quality and portability were higher. In February of 
+ 1992 1.00 was released via an article in SIGPLAN Notices. Peter Dahl,
+ then Ph.D. candidate, and Professor Matt O?Keefe (both at the 
+ University of Minnesota) tested this version extensively. Dana 
+ Hoggatt (Micro Data Base Systems, Inc.) tested 1.00 heavily. 
+
+ Version 1.06 was released in December 1992 and represented a large 
+ feature enhancement over 1.00. For example, rudimentary semantic 
+ predicates were introduced, error messages were significantly 
+ improved for k>1 lookahead and ANTLR parsers could indicate that 
+ lookahead fetches were to occur only when necessary for the parse 
+ (normally, the lookahead "pipe" was constantly full). Russell Quong
+ joined the project in the Spring of 1992 to aid in the semantic 
+ predicate design. Beginning and advanced tutorials were created and
+ released as well. A makefile generator was included that sets up 
+ dependencies and such correctly for ANTLR and DLG. Very few 1.00 
+ incompatibilities were introduced (1.00 was quite different from 
+ 1.00B in some areas). 
+
+ Version 1.10 was released on August 31, 1993 after Terence?s release
+ from Purdue and incorporated bug fixes, a few feature enhancements 
+ and a major new capability -- an arbitrary lookahead operator 
+ (syntactic predicate), "(a)?b". This feature was codesigned with 
+ Professor Russell Quong also at Purdue. To support infinite 
+ lookahead, a preprocessor flag, ZZINF_LOOK, was created that forced
+ the ANTLR() macro to tokenize all input prior to parsing. Hence, at 
+ any moment, an action or predicate could see the entire input 
+ sentence. The predicate mechanism of 1.06 was extended to allow 
+ multiple predicates to be hoisted; the syntactic context of a 
+ predicate could also be moved along with the predicate. 
+
+ In February of 1994, SORCERER was released. This tool allowed the
+ user to parse child-sibling trees by specifying a grammar rather than
+ building a recursive-descent tree walker by hand. Aaron Sawdey at The
+ University of Minnesota became a second author of SORCERER after the 
+ initial release. On April 1, 1994, PCCTS 1.20 was released. This was 
+ the first version to actively support C++ output. It also included 
+ important fixes regarding semantic predicates and (..)+ subrules. 
+ This version also introduced token classes, the "not" operator, and 
+ token ranges. 
+
+ On June 19, 1994, SORCERER 1.00B9 was released. Gary Funck of 
+ Intrepid Technology joined the SORCERER team and provided very 
+ valuable suggestions regarding the "transform" mode of SORCERER. 
+
+ On August 8, 1994, PCCTS 1.21 was released. It mainly cleaned up the
+ C++ output and included a number of bug fixes. 
+
+ From the 1.21 release forward, the maintenance and support of all 
+ PCCTS tools was picked up by Parr Research Corporation. 
+
+ A sophisticated error handling mechanism called "parser exception 
+ handling" was released for version 1.30. 1.31 fixed a few bugs. 
+
+ Release 1.33 is the version corresponding to the initial book release. 
+
+ ANTLR 2.0.0 came out around May 1997 and was partially funded so 
+ Terence hired John Lilley, a maniac coder and serious ANTLR hacker, 
+ to build much of the initial version. Terence did the grammar 
+ analyzer, naturally. 
+
+ John Mitchell, Jim Coker, Scott Stanchfield, and Monty Zukowski 
+ donate lots of brain power to ANTLR 2.xx in general. 
+
+ ANTLR 2.1.0, July 1997, mainly improved parsing performance, 
+ decreased parser memory requirements, and added a lot of cool lexer
+ features including a case-insensitivity option. 
+
+ ANTLR 2.2.0, December 1997, saw the introduction of the new 
+ http://www.antlr.org website.  This release also added grammar 
+ inheritance, enhanced AST support, and enhanced lexical translation
+ support (each lexical rule now was considered to return a Token 
+ object even when referenced by another lexical rule). 
+
+ ANTLR 2.3.0, June 1998, was the first version to have Peter Wells
+ C++ code generator. 
+
+ ANTLR 2.4.0, September 1998, introduced the ParseView parser debugger
+ by Scott Stanchfield.  This version also had a semi-functional -html
+ option to generate HTML from your grammar for reading purposes. Scott
+ and Terence updated the file I/O to be JDK 1.1. 
+
+ ANTLR 2.5.0, November 1998, introduced the filter option for the lexer
+ that lets ANTLR behave like SED or AWK. 
+
+ ANTLR 2.6.0, March 1999, introduced token streams. Chapman Flack, 
+ Purdue Graduate student, pounded me at the right moment about streams,
+ nudging me in the right direction. 
+
+ MageLang Institute currently provides support and continues 
+ development of ANTLR. 
+
+ MageLang becomes jGuru.com as we quit doing Java training and start 
+ building the jGuru Java developer's website. 
+
+ 2.7.0 released January 19, 2000 had the following enhancements:
+
+  * Nongreedy subrules 
+  * Heterogeneous trees 
+  * Element options.  To support heterogeneous trees, elements such 
+    as token references may now include options. 
+  * Exception hierarchy redesign 
+  * XML serialization 
+  * Improved C++ code generator 
+  * New Sather code generator 
+
+ 2.7.1 released October 1, 2000 had the following enhancements 
+
+  * ANTLR now allows UNICODE characters because Terence made case-
+    statement expressions more efficient ;)  See the unicode example 
+    in the distribution and the brief blurb in the documentation. 
+  * Massively improved C++ code generator (Thanks to Ric Klaren). 
+  * Added automatic column setting support. 
+  * Ter added throws to tree and regular parsers . 
+
+ 2.7.2 release January 19, 2003 was mainly a bug fix release, 
+ 
+  * but also included a C# code generator by Micheal Jordan, Kunle 
+    Odutola and Anthony Oguntimehin. :) 
+  * I (who, Ter?) added an antlr.build.Tool 'cause I hate ANT. This
+    release does UNICODE properly now. Added limited lexical lookahead
+    hoisting. Sather code generator disappears. Source changes for 
+    Eclipse and NetBeans by Marco van Meegen and Brian Smith. 
+
+ 2.7.3 released March 22, 2004 was mainly a bug fix release, 
+
+  * but included the parse-tree/derivation code to aid in debugging 
+  * plus the cool TokenStreamRewriteEngine that makes rewriting or 
+    tweaking input files particularly easy. 
+
+ 2.7.4 released May 9, 2004 was mainly a bug fix release.
+
+ 2.7.5 release Xmas 2004 had the following enhancements:
+
+  * A Python code generator has been implemented and contributed
+    by Wolfang Haefelinger and Marq Kole.
+
+  * A new make/autoconf framework as been contributed by Wolfgang
+    Haefelinger
+
+  * A MSI based installer has been contributed by Wolfgang Haefelinger. 
+
+======================================================================
+             README.txt - last update December 18th, 2004

Added: trunk/org.prorefactor.antlr/antlr.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.antlr/antlr.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.antlr/antlrsrc.zip
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.antlr/antlrsrc.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/org.prorefactor.antlr/plugin.xml
===================================================================
--- trunk/org.prorefactor.antlr/plugin.xml	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.antlr/plugin.xml	2005-05-17 16:29:26 UTC (rev 30)
@@ -3,7 +3,7 @@
 <plugin
    id="org.prorefactor.antlr"
    name="Antlr"
-   version="2.7.4"
+   version="2.7.5"
    provider-name="antlr.org via prorefactor.org">
 
    <runtime>

Added: trunk/org.prorefactor.antlr/version.txt
===================================================================
--- trunk/org.prorefactor.antlr/version.txt	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.antlr/version.txt	2005-05-17 16:29:26 UTC (rev 30)
@@ -0,0 +1 @@
+Antlr version 2.7.5

Modified: trunk/org.prorefactor.core/src/org/prorefactor/core/TokenTypes.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/core/TokenTypes.java	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.core/src/org/prorefactor/core/TokenTypes.java	2005-05-17 16:29:26 UTC (rev 30)
@@ -43,7 +43,7 @@
 		info.isNatural = true;
 		allTokens[1087] = info;
 
-		assignKeywordsText();
+		assignDefaultText();
 	}
 	
 	private static TokenInfo getInfo(int tokenType) {
@@ -57,9 +57,9 @@
 	/** For integer token types that represent a keyword in the
 	 * syntax, this returns the full keyword text/name.
 	 * @return null if invalid token type or is not a keyword according to Proparse.
-	 * @see #isKeyword(int)
+	 * @see #hasDefaultText(int)
 	 */
-	public static String getKeywordText(int tokenType) {
+	public static String getDefaultText(int tokenType) {
 		TokenInfo info = getInfo(tokenType);
 		if (info==null) return null;
 		return info.keywordText;
@@ -94,7 +94,7 @@
 	 * a keyword type, ID is not.
 	 * See Proparse's node attribute documentation for NODE_TYPE_KEYWORD.
 	 */
-	public static boolean isKeyword(int tokenType) {
+	public static boolean hasDefaultText(int tokenType) {
 		TokenInfo info = getInfo(tokenType);
 		if (info==null) return false;
 		return (info.keywordText != null);
@@ -106,7 +106,36 @@
 	}
 
 	
-	private static void assignKeywordsText() {
+	private static void assignDefaultText() {
+
+		// Operators and punctuation
+		allTokens[SLASH].keywordText = "/";
+		allTokens[LEXCOLON].keywordText = ":";
+		allTokens[OBJCOLON].keywordText = ":";
+		allTokens[LEXAT].keywordText = "@";
+		allTokens[LEFTBRACE].keywordText = "[";
+		allTokens[RIGHTBRACE].keywordText = "]";
+		allTokens[CARET].keywordText = "^";
+		allTokens[COMMA].keywordText = ",";
+		allTokens[EXCLAMATION].keywordText = "!";
+		allTokens[EQUAL].keywordText = "=";
+		allTokens[LEFTPAREN].keywordText = "(";
+		allTokens[RIGHTPAREN].keywordText = ")";
+		allTokens[SEMI].keywordText = ";";
+		allTokens[STAR].keywordText = "*";
+		allTokens[UNKNOWNVALUE].keywordText = "?";
+		allTokens[BACKTICK].keywordText = "`";
+		allTokens[NAMEDOT].keywordText = ".";
+		allTokens[PERIOD].keywordText = ".";
+		allTokens[GTOREQUAL].keywordText = ">=";
+		allTokens[RIGHTANGLE].keywordText = ">";
+		allTokens[GTORLT].keywordText = "<>";
+		allTokens[LTOREQUAL].keywordText = "<=";
+		allTokens[LEFTANGLE].keywordText = "<";
+		allTokens[PLUS].keywordText = "+";
+		allTokens[MINUS].keywordText = "-";
+
+		// Keywords
 		allTokens[AACBIT].keywordText = "_CBIT";
 		allTokens[AACONTROL].keywordText = "_CONTROL";
 		allTokens[AALIST].keywordText = "_LIST";

Modified: trunk/org.prorefactor.lib/.classpath
===================================================================
--- trunk/org.prorefactor.lib/.classpath	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.lib/.classpath	2005-05-17 16:29:26 UTC (rev 30)
@@ -15,5 +15,6 @@
 	<classpathentry exported="true" sourcepath="jakarta/commons-collections/src.zip" kind="lib" path="jakarta/commons-collections/commons-collections.jar"/>
 	<classpathentry exported="true" sourcepath="jakarta/commons-io/src.zip" kind="lib" path="jakarta/commons-io/commons-io.jar"/>
 	<classpathentry exported="true" sourcepath="jakarta/commons-lang/src.zip" kind="lib" path="jakarta/commons-lang/commons-lang.jar"/>
+	<classpathentry exported="true" sourcepath="stringtemplate/src.zip" kind="lib" path="stringtemplate/stringtemplate.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

Modified: trunk/org.prorefactor.lib/build.properties
===================================================================
--- trunk/org.prorefactor.lib/build.properties	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.lib/build.properties	2005-05-17 16:29:26 UTC (rev 30)
@@ -9,7 +9,8 @@
                jakarta/,\
                readme.txt,\
                bin/,\
-               prorefactor.lib.jar
+               prorefactor.lib.jar,\
+               stringtemplate/
 src.includes = .classpath,\
                .project,\
                build.properties,\
@@ -33,7 +34,8 @@
                xml-apis.jar,\
                readme.txt,\
                jakarta/,\
-               bin/
+               bin/,\
+               stringtemplate/
 jars.compile.order = prorefactor.lib.jar
 source.prorefactor.lib.jar = jakarta/commons-io-1.0/src/
 output.prorefactor.lib.jar = bin/

Modified: trunk/org.prorefactor.lib/plugin.xml
===================================================================
--- trunk/org.prorefactor.lib/plugin.xml	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.lib/plugin.xml	2005-05-17 16:29:26 UTC (rev 30)
@@ -49,6 +49,9 @@
       <library name="jakarta/commons-lang/commons-lang.jar">
          <export name="*"/>
       </library>
+      <library name="stringtemplate/stringtemplate.jar">
+         <export name="*"/>
+      </library>
    </runtime>
 
 </plugin>

Added: trunk/org.prorefactor.lib/stringtemplate/doc.html
===================================================================
--- trunk/org.prorefactor.lib/stringtemplate/doc.html	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.lib/stringtemplate/doc.html	2005-05-17 16:29:26 UTC (rev 30)
@@ -0,0 +1,1871 @@
+<HTML>
+<HEAD>
+<body bgcolor=#FFFFFF text=#000000>
+<title>StringTemplate Documentation</title>
+</HEAD>
+<BODY>
+<H1>StringTemplate Documentation</H1>
+
+
+<P>Brought to you by that maniac that brings you
+<A HREF="http://www.antlr.org"><B> ANTLR</B></A>!
+
+<P>Terence Parr <BR>
+University of San Francisco <BR>
+<TT>parrt at cs.usfca.edu</TT> <BR>
+<em>Copyright 2003-2005</em> <BR>
+<A HREF="http://www.stringtemplate.org"><B>http://www.stringtemplate.org</B></A> <BR>
+(StringTemplate released under BSD License)
+
+<P>Version 2.1, January 22, 2005
+
+<P>Note that the <TT>TestStringTemplates.java</TT> file has many tests that are
+an excellent set of examples.  Also, I highly recommend you read the
+(academic-oriented) paper,
+<A HREF="http://www.cs.usfca.edu/~parrt/papers/mvc.templates.pdf"><B> Enforcing
+Model-View Separation in Template Engines</B></A>.  There are some more
+examples including nested menu generation that will be of interest.
+<H2>Acknowledgements</H2>
+
+
+<P>Tom Burns (CEO jGuru.com) co-designed <TT>StringTemplate</TT> and listened to
+me think out loud incessantly.  I would also like to thank Monty
+Zukowski for planting the <TT>template</TT> "meme" in my head back in the mid
+1990's.  Loring Craymer and Monty both are helping me hone these ideas
+for use in source-to-source language translation.  Matthew Ford has done a
+huge amount of thinking about StringTemplate and has submitted numerous
+suggestions and patches.  Anthony Casalena at <A HREF="http://www.squarespace.com"><B>http://www.squarespace.com</B></A> has been a big help beta-testing <TT>StringTemplate</TT>.
+<H2>Introduction</H2>
+
+
+<P>A <TT>StringTemplate</TT> is a "document" with holes in it where you can
+stick values.  <TT>StringTemplate</TT> breaks up your template into chunks of
+text and attribute expressions, which are by default enclosed in
+dollar signs <TT>$</TT><em>attribute-expression</em><TT>$</TT> (to make them easy to see in
+HTML files).  <TT>StringTemplate</TT> ignores everything outside of attribute
+expressions, treating it as just text to spit out when you call
+<TT>StringTemplate.toString()</TT>.  For example, the following template has two chunks, a literal and a reference to attribute <TT>name</TT>:
+
+<FONT SIZE=2><PRE>
+Hello, $name$
+</PRE></FONT>
+
+
+
+<P>Using templates in Java code is very easy. Here is the requisite example that prints "<TT>Hello, World</TT>":
+
+<FONT SIZE=2><PRE>
+StringTemplate hello = new StringTemplate("Hello, $name$");
+hello.setAttribute("name", "World");
+System.out.println(hello.toString());
+</PRE></FONT>
+
+
+
+<P><TT>StringTemplate</TT> is not a "system" or "engine" or "server"; it's a
+library with two primary classes of interest: <TT>StringTemplate</TT> and
+<TT>StringTemplateGroup</TT>.  You can directly create a <TT>StringTemplate</TT> in
+Java code, you can load a template from a file, and you can load a
+single file with many templates (a template group file).
+
+<P><TT>StringTemplate</TT> evolved over years developing the following sites:
+<UL>
+<LI><A HREF="http://www.jguru.com"><B>http://www.jguru.com</B></A>
+</LI>
+<LI><A HREF="http://www.knowspam.net"><B>http://www.knowspam.net</B></A>
+</LI>
+<LI><A HREF="http://www.peerscope.com"><B>http://www.peerscope.com</B></A>
+</LI>
+<LI><A HREF="http://www.antlr.org"><B>http://www.antlr.org</B></A>
+</LI>
+
+</UL>
+
+<P>The need for dynamically-generated web pages, such as the book description pages at Amazon.com, has led to the development of numerous template engines in an attempt to make web application development easier, improve flexibility, reduce maintenance costs, and allow parallel code and HTML development.  These enticing benefits, which have driven the proliferation of template engines, derive entirely from a single principle: separating the specification of a page's business logic and data computations from the specification of how a page displays such information. With separate encapsulated specifications, template engines promote component reuse, pluggable site "looks", single-points-of-change for common components, and high overall system clarity.  
+
+<P>StringTemplate distinguishes itself by strictly enforcing the separation of business logic from display. After examining hundreds of template files that I created over years of development, I found that I needed only the following four basic canonical operations:
+<UL>
+<LI>attribute reference; e.g., <TT>$phoneNumber$</TT>
+</LI>
+<LI>template reference (like #include or macro expansion); e.g., <TT>$searchbox()$</TT>
+</LI>
+<LI>conditional include of subtemplate (an IF statement); e.g., <TT>$if(title)$&lt;title&gt;$title$&lt;/title&gt;$endif$</TT>
+</LI>
+<LI>template application to list of attributes; e.g., <TT>$names:bold()$</TT>
+</LI>
+
+</UL>
+
+<P>where template references can be recursive.  Things like setting variables, loops, arbitrary method calls into the model etc... are simply unnecessary and lead to entangled specifications.
+
+<P>While <TT>StringTemplate</TT> evolved while I was building websites, in the back of my mind I kept wondering how useful it would be in my research area (parser generators and other code
+generators).  With the 2.0 release I have augmented <TT>StringTemplate</TT>
+to better support text code generators such as auto-indentation and
+template group files.  Along with the group file format, you will see formal arguments for templates so that many previously-undetected errors can be trapped such as referencing an attribute that is not set by the controller.
+<H2>Defining Templates</H2>
+
+<H3>Creating Templates With Java Code</H3>
+
+
+<P>Here is a simple piece of Java that creates and uses a template on the fly:
+
+<FONT SIZE=2><PRE>
+StringTemplate query =
+  new StringTemplate("SELECT $column$ FROM $table$;");
+query.setAttribute("column", "name");
+query.setAttribute("table", "User");
+</PRE></FONT>
+
+
+
+<P>where <TT>StringTemplate</TT> considers anything in <TT>$...$</TT> to be something
+it needs to pay attention to.  By setting attributes, you are
+"pushing" values into the template for use when the template is
+printed out.  The attribute values are set by referencing their names.
+Invoking <TT>query.toString()</TT> would yield
+
+<FONT SIZE=2><PRE>
+SELECT name FROM User;
+</PRE></FONT>
+
+
+
+<P>You can set an attribute multiple times, which simply means that the
+attribute is multi-valued.  For example, adding another
+<TT>setAttribute()</TT> call makes attribute <TT>column</TT> multi-valued:
+
+<FONT SIZE=2><PRE>
+StringTemplate query =
+  new StringTemplate("SELECT $column$ FROM $table$;");
+query.setAttribute("column", "name");
+query.setAttribute("column", "email");
+query.setAttribute("table", "User");
+</PRE></FONT>
+
+
+
+<P>Invoking <TT>query.toString()</TT> would now yield
+
+<FONT SIZE=2><PRE>
+SELECT nameemail FROM User;
+</PRE></FONT>
+
+
+
+<P>Ooops...there is no separator between the multiple values.  If you want a comma, say, between the column names, then change the template to record that formatting information:
+
+<FONT SIZE=2><PRE>
+StringTemplate query =
+  new StringTemplate("SELECT $column; separator=\",\"$ FROM $table$;");
+query.setAttribute("column", "name");
+query.setAttribute("column", "email");
+query.setAttribute("table", "User");
+</PRE></FONT>
+
+
+
+<P>Note that the right-hand-side of the separator specification in this case is a string literal; therefore, I have escaped the double-quotes as the template is specified in a Java string.  In general, the right-hand-side can be any attribute expression.  Invoking <TT>query.toString()</TT> would now yield
+
+<FONT SIZE=2><PRE>
+SELECT name,email FROM User;
+</PRE></FONT>
+
+
+
+<P>Attributes can be any object at all.  <TT>StringTemplate</TT> calls <TT>toString()</TT> on each object as it writes the template out.  The separator is not used unless the attribute is multi-valued.
+<H3>Loading Templates From Files</H3>
+
+
+<P>To load a template from the disk you must use a <TT>StringTemplateGroup</TT>
+that will manage all the templates you load, caching them so you do
+not waste time talking to the disk for each template fetch request
+(you can change it to not cache; see below).  You may have multiple
+template groups.  Here is a simple example that loads the previous SQL
+template from file <TT>/tmp/theQuery.st</TT>:
+
+<FONT SIZE=2><PRE>
+SELECT $column; separator=","$ FROM $table$;
+</PRE></FONT>
+
+
+
+<P>The Java code creates a <TT>StringTemplateGroup</TT> called <TT>myGroup</TT> rooted
+at <TT>/tmp</TT> so that requests for template <TT>theQuery</TT> forces a load of
+file <TT>/tmp/theQuery.st</TT>.
+
+<FONT SIZE=2><PRE>
+StringTemplateGroup group =
+  new StringTemplateGroup("myGroup", "/tmp");
+StringTemplate query = group.getInstanceOf("theQuery");
+query.setAttribute("column", "name");
+query.setAttribute("column", "email");
+query.setAttribute("table", "User");
+</PRE></FONT>
+
+
+
+<P>If you have a directory hierarchy of templates such as file
+<TT>/tmp/jguru/bullet.st</TT>, you would reference them relative to the root;
+in this case, you would ask for template <TT>jguru/bullet()</TT>.
+
+<P><B>Note</B>: StringTemplate strips whitespace from the front and back of
+all loaded template files.  You can add, for example, <TT>&lt;\n&gt;</TT> at the
+end of the file to get an extra carriage return.
+<H3>Loading Templates From CLASSPATH</H3>
+
+
+<P>When deploying applications or providing a library for use by other programmers, you will not know where your templates files live specifically on the disk.  You will, however, know relative to the classpath where your templates reside.  For example, if your code is in package <TT>com.mycompany.server</TT> you might put your templates in a <TT>templates</TT> subdirectory of <TT>server</TT>.  If you do not specify an absolute directory with the <TT>StringTemplateGroup</TT> constructor, future loads via that group will happen relative to the <TT>CLASSPATH</TT>.  For example, to load template file <TT>page.st</TT> you would do the following:
+
+<FONT SIZE=2><PRE>
+// Look for templates in CLASSPATH as resources
+StringTemplateGroup group = new StringTemplateGroup("mygroup");
+StringTemplate st = group.getInstanceOf("com/mycompany/server/templates/page");
+</PRE></FONT>
+
+
+
+<P>If <TT>page.st</TT> references, say, <TT>searchbox</TT> template, it must be fully qualified as:
+
+<FONT SIZE=2><PRE>
+&lt;font size=2&gt;SEARCH&lt;/font&gt;: $com/mycompany/server/templates/page/searchbox()$
+</PRE></FONT>
+
+
+
+<P>This is inconvenient and I may add the invoking template's path prefix automatically in the future.
+<H2>StringTemplate Group Files</H2>
+
+
+<P>2.0 introduces the notion of a group file that has two main attractions.  First, it allows you to define lots of small templates more conveniently because they may all be defined within a single file.  Second, you may specify formal template arguments that help <TT>StringTemplate</TT> detect errors (such as setting unknown attributes) and make the templates easier to read.  Here is a sample group file (I'm using <TT>&lt;...&gt;</TT> delimiters) with two templates, <TT>vardef</TT> and <TT>method</TT>, that could be used to generate C files:
+
+<FONT SIZE=2><PRE>
+group simple;
+
+vardef(type,name) ::= "&lt;type&gt; &lt;name&gt;;"
+
+method(type,name,args) ::= &lt;&lt;
+&lt;type&gt; &lt;name&gt;(&lt;args; separator=","&gt;) {
+  &lt;statements; separator="\n"&gt;
+}
+&gt;&gt;
+</PRE></FONT>
+
+
+
+<P>Single line templates are enclosed in double quotes while multi-line templates are enclosed in double angle-brackets. Every template must define arguments even if the formal argument list if blank.
+
+<P>Using templates in a group file is straightforwards.  A <TT>StringTemplateGroup</TT> constructor accepts a <TT>Reader</TT> so you can pass in a string or file or whatever:
+
+<FONT SIZE=2><PRE>
+String templates =
+   "group simple; vardef(type,name) ..."; // templates from above
+StringTemplateGroup group = new StringTemplateGroup(new StringReader(templates));
+StringTemplate t = group.getInstanceOf("vardef");
+t.setAttribute("type", "int");
+t.setAttribute("name", "foo");
+System.out.println(t);
+</PRE></FONT>
+
+
+
+<P>The output would be: "<TT>int foo;</TT>".
+<H3>Formal argument error handling</H3>
+
+
+<P>When using a group file format to specify templates, you must specify the formal arguments for that template.  If you try to set an attribute that is not specifically formally defined that template, you will get a <TT>NoSuchElementException</TT>.
+<H3>Newline handling</H3>
+
+
+<P>The first newline following the <TT>&lt;&lt;</TT> in a template definition is
+ignored as it is usually used just to get the first line of text for
+the template at the start of a line.  In other words, if you want to
+have a blank line at the start of your template, use:
+
+<FONT SIZE=2><PRE>
+foo() ::= &lt;&lt;
+
+2nd line is not blank, but first is
+&gt;&gt;
+</PRE></FONT>
+
+
+
+<P>or
+
+<FONT SIZE=2><PRE>
+foo() ::= &lt;&lt;&lt;\n&gt;
+same as before; newline then this line
+&gt;&gt;
+</PRE></FONT>
+
+
+
+<P>The last newline before the <TT>&gt;&gt;</TT> is also ignored and is included in
+the output.  To add a final newline, add an extra line or <TT>&lt;\n&gt;</TT>
+before the <TT>&gt;&gt;</TT>:
+
+<FONT SIZE=2><PRE>
+foo() ::= &lt;&lt;
+rodent
+
+&gt;&gt;
+</PRE></FONT>
+
+
+
+<P>or
+
+<FONT SIZE=2><PRE>
+foo() ::= &lt;&lt;
+rodent&lt;\n&gt;
+&gt;&gt;
+</PRE></FONT>
+
+
+
+<P>Template:
+
+<FONT SIZE=2><PRE>
+foo() ::= &lt;&lt;
+rodent
+&gt;&gt;
+</PRE></FONT>
+
+
+
+<P>on the other hand, is identical to
+
+<FONT SIZE=2><PRE>
+foo() ::= "rodent"
+</PRE></FONT>
+
+
+<H3>Group file format</H3>
+
+
+<FONT SIZE=2><PRE>
+group
+    :	"group" name:ID SEMI (template)*
+    ;
+
+template
+    :	name:ID LPAREN (args)? RPAREN DEFINED_TO_BE TEMPLATE
+    |   ID DEFINED_TO_BE ID // alias one template to be another
+    ;
+
+args:	ID (COMMA ID)*
+    ;
+</PRE></FONT>
+
+
+
+<TABLE cellspacing=0 border=1>
+<TR><TD><B>An aside</B>: All along, during my website construction days, I kept in mind that any text output follows a format and, thus, output sentences conform to a language.  Consequently, a grammar should describe the output rather than a bunch of ad hoc print statements in code.  This helped me formalize the study of templates because I could compare templates (output grammars) to well established ideas from formal language theory and context-free grammars.  This allowed me to show, among other things, that <TT>StringTemplate</TT> can easily generate any document describable with an XML DTD even though it is deliberately limited.  The group file format should look very much like a grammar to you.
+</TD></TR>
+</TABLE>
+
+
+<P>See the scoping rules section for information on how formal arguments affect attribute look up.
+
+<P>I use <TT>.stg</TT> file extension, which you might also want to use.
+<H2>Functionality Summary</H2>
+
+<H3>Attribute References</H3>
+
+<H4>Named attributes</H4>
+
+
+<P>The most common thing in a template besides plain text is a simple named attribute reference such as:
+
+<FONT SIZE=2><PRE>
+Your email: $email$
+</PRE></FONT>
+
+
+
+<P>The template will look up the value of <TT>email</TT> and insert it into the output stream when you ask the template to print itself out.  If <TT>email</TT> has no value, then it evaluates to the empty string and nothing is printed out for that attribute expression.
+<H4>Property references</H4>
+
+
+<P>If a named attribute is an aggregate with a property (ala JavaBeans), you may reference that property using <em>attribute</em>.<em>property</em>.  For example:
+
+<FONT SIZE=2><PRE>
+Your name: $person.name$
+Your email: $person.email$
+</PRE></FONT>
+
+
+
+<P><TT>StringTemplate</TT> ignores the actual object type stored in attribute
+<TT>person</TT> and simply invokes <TT>getName()</TT> and <TT>getEmail()</TT> via
+reflection.  As a special case, StringTemplate tries <TT>x.isFoo()</TT> for
+<TT>x.foo</TT> if <TT>x</TT> is <TT>Boolean</TT>.
+
+<P>Because the type is ignored, you can pass in whatever existing Java aggregate (class) you have such as <TT>User</TT> or <TT>Person</TT>:
+
+<FONT SIZE=2><PRE>
+User u = database.lookupPerson("parrt at jguru.com");
+st.setAttribute("person", u);
+</PRE></FONT>
+
+
+
+<P>Or, if a suitable aggregate doesn't exist, you can make a connector or "glue" object and pass that in instead:
+
+<FONT SIZE=2><PRE>
+st.setAttribute("person", new Connector());
+</PRE></FONT>
+
+
+
+<P>where <TT>Connector</TT> is defined as:
+
+<FONT SIZE=2><PRE>
+public class Connector {
+    public String getName() { return "Terence"; }
+    public String getEmail() { return "parrt at jguru.com"; }
+}
+</PRE></FONT>
+
+
+
+<P>The ability to reference aggregrate properties saves you the trouble
+of having to pull out the properties with Java code like this:
+
+<FONT SIZE=2><PRE>
+User u = database.lookupPerson("parrt at jguru.com");
+st.setAttribute("name", u.getName());
+st.setAttribute("email", u.getEmail());
+</PRE></FONT>
+
+
+
+<P>and having template:
+
+<FONT SIZE=2><PRE>
+Your name: $name$
+Your email: $email$
+</PRE></FONT>
+
+
+
+<P><B>Warning</B>: The latter is more widely applicable and totally decoupled
+from code and logic; i.e., it's "better" but much less convenient.  Be
+very careful that the property methods do not have any side-effects
+like updating a counter or whatever.  This breaks the rule of order of
+evaluation independence.
+<H4>Map key/value pair access</H4>
+
+
+<P>You may pass in instances of type <TT>HashMap</TT> and <TT>Hashtable</TT> but cannot
+pass in objects implementing the <TT>Map</TT> because that would allow all
+sorts of wacky stuff like database access.   Rather than creating an
+aggregate object (though I make it easier for you with the automatic
+aggregate creation in the next section) you can pass in a <TT>HashMap</TT>
+that has keys referencable within templates.  For example, 
+
+<FONT SIZE=2><PRE>
+StringTemplate a = new StringTemplate("$user.name$, $user.phone$");
+HashMap user = new HashMap();
+user.put("name", "Terence");
+user.put("name", "none-of-your-business");
+a.setAttribute("user", user);
+String results = a.toString();
+</PRE></FONT>
+
+
+
+<P>yields a result of "Terence, none-of-your-business".
+<H4>Automatic aggregate creation</H4>
+
+
+<P>While Java anonymous inner classes are supposed to make creating and passing around aggregates easy, it turns out they have a nasty weakness: they are created with protections such that they are not visible outside their package.  In other words, if you want to avoid creating a separate class and want to use an anonymous class, <TT>StringTemplate</TT> will receive an illegal access exception when trying to access the (public) property methods via reflection.  It stunned me too, but after hours of frustration, I can only conclude this is inescapable.  Anonymous classes are created with non-public access.  Anyway, I found a workaround that is better by augmenting <TT>StringTemplate</TT> slightly.  You may pass in an aggregrate attribute name to <TT>setAttribute()</TT> now:
+
+<FONT SIZE=2><PRE>
+StringTemplate st =
+        new StringTemplate("$items:{$it.last$, $it.first$\n}$");
+st.setAttribute("items.{first,last}", "John", "Smith");
+st.setAttribute("items.{first,last}", "Baron", "Von Munchhausen");
+String expecting =
+        "Smith, John\n" +
+        "Von Munchhausen, Baron\n";
+</PRE></FONT>
+
+
+
+<P>Note that the template, <TT>st</TT>, expects the <TT>items</TT> to be aggregates with properties <TT>first</TT> and <TT>last</TT>.  By using attribute name
+
+<FONT SIZE=2><PRE>
+items.{first,last}
+</PRE></FONT>
+
+
+
+<P>You are telling <TT>StringTemplate</TT> to take the following two arguments as properties <TT>first</TT> and <TT>last</TT>.  
+
+<P>I have created variants of the <TT>setAttribute()</TT> method to handle from 2 to 5 properties.  This is really handy. :)
+<H3>Template References</H3>
+
+
+<P>You may reference other templates to have them included just like the C language preprocessor <TT>#include</TT> construct behaves.  For example, if you are building a web page (<TT>page.st</TT>) that has a search box, you might want the search box stored in a separate template file, say, <TT>searchbox.st</TT>.  This has two advantages:
+<OL>
+<LI>You can reuse the template over and over (no cut/paste)
+</LI>
+<LI>You can change one template and all search boxes change on the whole site.
+</LI>
+
+</OL>
+
+<P>Using method call syntax, just reference the foreign template:
+
+<FONT SIZE=2><PRE>
+&lt;html&gt;
+&lt;body&gt;
+...
+$searchbox()$
+...
+&lt;/body&gt;
+&lt;/html&gt;
+</PRE></FONT>
+
+
+
+<P>The invoking Java code would still just create the overall page and the enclosing page template would automatically create an instance of the referenced template and insert it:
+
+<FONT SIZE=2><PRE>
+StringTemplateGroup group =
+  new StringTemplateGroup("webpages", "/usr/local/site/templates");
+StringTemplate page = group.getInstanceOf("page");
+</PRE></FONT>
+
+
+
+<P>If the template you want to reference, say <TT>searchbox</TT>, is in a subdirectory of the <TT>StringTemplateGroup</TT> root directory called <TT>misc</TT>, then you must reference the template as: <TT>misc/searchbox()</TT>.
+
+<P>The included template may access attributes.  How can you set the attribute of an included template?  There are two ways: inheriting attributes and passing parameters.
+<H4>Accessing Attributes Of Enclosing Template</H4>
+
+
+<P>Any included template can reference the attributes of the enclosing template instance.  So if <TT>searchbox</TT> references an attribute called <TT>resource</TT>:
+
+<FONT SIZE=2><PRE>
+&lt;form ...&gt;
+...
+&lt;input type=hidden name=resource value=$resource$&gt;
+...
+&lt;/form&gt;
+</PRE></FONT>
+
+
+
+<P>you could set attribute <TT>resource</TT> in the enclosing template <TT>page</TT>:
+
+<FONT SIZE=2><PRE>
+StringTemplate page = group.getInstanceOf("page");
+page.setAttribute("resource", "faqs");
+</PRE></FONT>
+
+
+
+<P>This "inheritance" of attributes feature is particularly handy for setting generally useful attributes like <TT>siteFontTag</TT>. 
+<H4>Passing Parameters To Another Template</H4>
+
+
+<P>Another, more obvious, way to set the attributes of an included template is to pass in values as parameters, making them look like C macro invocations rather than includes.  The syntax looks like a set of attribute assignments:
+
+<FONT SIZE=2><PRE>
+&lt;html&gt;
+&lt;body&gt;
+...
+$searchbox(resource="faqs")$
+...
+&lt;/body&gt;
+&lt;/html&gt;
+</PRE></FONT>
+
+
+
+<P>where I am setting the attribute of the included <TT>searchbox</TT> to be the
+string literal <TT>"faqs"</TT>.
+
+<P>The right-hand-side of the assignment may be any expression such as an attribute reference or even a reference to another template like this:
+
+<FONT SIZE=2><PRE>
+$boldMe(item=copyrightNotice())$
+</PRE></FONT>
+
+
+<H3>Attribute Expressions</H3>
+
+
+<P>When setting parameters or testing IF conditionals, you may find it handy to use the plus "string concatenate" operator.  For example, when building web pages, you will find it useful to create a template called <TT>link</TT> and then use it to generate HTML link tags; you may want to change the way every link looks on your site and it's convenient to have one place to change things.  The template might look like:
+
+<FONT SIZE=2><PRE>
+&lt;a href="$url$"&gt;&lt;b&gt;$title$&lt;/b&gt;&lt;/a&gt;
+</PRE></FONT>
+
+
+
+<P>Then in a page template you might reference:
+
+<FONT SIZE=2><PRE>
+...$link(url="http://www.jguru.com", title="jGuru")$...
+</PRE></FONT>
+
+
+
+<P>or you could use attributes to set the link parameters:
+
+<FONT SIZE=2><PRE>
+...$link(url=person.homePage, title=person.name)$...
+</PRE></FONT>
+
+
+
+<P>Sometimes you may want to compute the URL; usually it is enough to concatenate strings:
+
+<FONT SIZE=2><PRE>
+...$link(url="/faq/view?ID="+faqid, title=faqtitle)$...
+</PRE></FONT>
+
+
+
+<P>where <TT>faqid</TT> and <TT>faqtitle</TT> are attributes you would have to set for
+the template that referenced <TT>link</TT>.
+
+<P>You may parenthesize any expression:
+
+<FONT SIZE=2><PRE>
+...$link(url=("/faq/view?ID="+faqid), title=faqtitle)$...
+</PRE></FONT>
+
+
+<H3>Template Application</H3>
+
+
+<P>Imagine a simple template called <TT>bold</TT>:
+
+<FONT SIZE=2><PRE>
+&lt;b&gt;$item$&lt;/b&gt;
+</PRE></FONT>
+
+
+
+<P>Just as with template <TT>link</TT> described above, you can reference it from a template by invoking it like a method call:
+
+<FONT SIZE=2><PRE>
+$bold(item=name)$
+</PRE></FONT>
+
+
+
+<P>What if you want something bold and italicized?  You could simply nest the template reference:
+
+<FONT SIZE=2><PRE>
+$bold(item=italics(item=name))$
+</PRE></FONT>
+
+
+
+<P>where template <TT>italics</TT> is defined as:
+
+<FONT SIZE=2><PRE>
+&lt;i&gt;$item$&lt;/i&gt;
+</PRE></FONT>
+
+
+
+<P>using a different attribute with the same name, <TT>item</TT>; the attributes have different values just like you would expect if these template references where Java method calls and <TT>item</TT> were a local variable.  Parameters and attribute references are scoped like a programming language.
+
+<P>Think about what you are really trying to say here.  You want to say "make name italics and then make it bold", or "apply italics to the name and then apply bold."  There is an "apply template" syntax that is a literal translation:
+
+<FONT SIZE=2><PRE>
+$name:italics():bold()$
+</PRE></FONT>
+
+
+
+<P>where the templates are applied in the order specified from left to right.  This is much more clear, particularly if you had three templates to apply:
+
+<FONT SIZE=2><PRE>
+$name:courierFont():italics():bold()$
+</PRE></FONT>
+
+
+
+<P>For this syntax to work, however, the applied templates have to reference a standard attribute because you are not setting the attribute in a parameter assignment.  In general for syntax <em>expr</em>:<em>template</em>(), an attribute called <TT>it</TT> is set to the value of <em>expr</em>.  So, the definition of <TT>bold</TT> (and analogously <TT>italics</TT>), would have to be:
+
+<FONT SIZE=2><PRE>
+&lt;b&gt;$it$&lt;/b&gt;
+</PRE></FONT>
+
+
+
+<P>to pick up the value of <TT>name</TT> in our examples above.
+<H4>Applying Templates To Multi-Valued Attributes</H4>
+
+
+<P>Where template application really shines though is when an attribute is multi-valued.  One of the most common web page generation issues is making lists of items either as bullet lists or table rows etc...  Applying a template to a multi-valued attribute means that you want the template applied to each of the values.
+
+<P>Consider a list of names (i.e., you set attribute <TT>names</TT> multiple times) that you want in a bullet list.  If you have a template called <TT>listItem</TT>:
+
+<FONT SIZE=2><PRE>
+&lt;li&gt;$it$&lt;/li&gt;
+</PRE></FONT>
+
+
+
+<P>then you can do this:
+
+<FONT SIZE=2><PRE>
+&lt;ul&gt;
+$names:listItem()$
+&lt;/ul&gt;
+</PRE></FONT>
+
+
+
+<P>and each name will appear as a bullet item. For example, if you set <TT>names</TT> to <TT>"Terence"</TT>, <TT>"Tom"</TT>, and <TT>"Jim"</TT>, then you would see:
+
+<FONT SIZE=2><PRE>
+&lt;ul&gt;
+&lt;li&gt;Terence&lt;/li&gt;
+&lt;li&gt;Tom&lt;/li&gt;
+&lt;li&gt;Jim&lt;/li&gt;
+&lt;/ul&gt;
+</PRE></FONT>
+
+
+
+<P>in the output.
+
+<P>Whenever you apply a template to an attribute or multi-valued attribute, the default attribute <TT>it</TT> is set.  Another attribute <TT>i</TT> (of type <TT>Integer</TT>) is also set to the value's index number starting from 1.  For example, if you wanted to make your own style of numbered list, you could reference <TT>i</TT> to get the index:
+
+<FONT SIZE=2><PRE>
+$names:numberedListItem()$
+</PRE></FONT>
+
+
+
+<P>where template <TT>numberedListItem</TT> is defined as:
+
+<FONT SIZE=2><PRE>
+$i$. $it$&lt;br&gt;
+</PRE></FONT>
+
+
+
+<P>In this case, the output would be:
+
+<FONT SIZE=2><PRE>
+1. Terence&lt;br&gt;
+2. Tom&lt;br&gt;
+3. Jim&lt;br&gt;
+</PRE></FONT>
+
+
+
+<P>If there is only one attribute value, then <TT>i</TT> will be 1.
+<H4>Applying Multiple Templates To Multi-Valued Attributes</H4>
+
+
+<P>The result of applying a template to a multi-valued attribute is another multi-valued attribute containing the results of the application.  You may apply another template to the results of the first template application, which comes in handy when you need to format the elements of a list before they go into the list.  For example, to bold the elements of a list do the following (given the appropriate template definitions from above):
+
+<FONT SIZE=2><PRE>
+$names:bold():listItem()$
+</PRE></FONT>
+
+ 
+
+<P>If you actually want to apply a template to the combined (string) result of a previous template application, enclose the previous application in parenthesis.  The parenthesis will force immediate evaluation of the template application, resulting in a string.  For example,
+
+<FONT SIZE=2><PRE>
+$(names:bold()):listItem()$
+</PRE></FONT>
+
+ 
+
+<P>results in a single list item full of a bunch of bolded names.  Without the parenthesis, you get a list of items that are bolded.
+<H4>Applying Alternating Templates To Multi-Valued Attributes</H4>
+
+
+<P>When generating lists of things, you often need to change the color or other formatting instructions depending on the list position.  For example, you might want to alternate the color of the background for the elements of a list.  The easiest and most natural way to specify this is with an alternating list of templates to apply to an expression of the form: <TT>$</TT><em>expr</em>:<em>t1</em>(),<em>t2</em>(),...,<em>tN</em>()<TT>$</TT>.  To make an alternating list of blue and green names, you might say:
+
+<FONT SIZE=2><PRE>
+$names:blueListItem(),greenListItem()$
+</PRE></FONT>
+
+
+
+<P>where presumably <TT>blueListItem</TT> template is an HTML <TT>&lt;table&gt;</TT> or something that lets you change background color.   <TT>names[0]</TT> would get <TT>blueListItem()</TT> applied to it, <TT>names[1]</TT> would get <TT>greenListItem()</TT>, and <TT>names[2]</TT> would get <TT>blueListItem()</TT>, etc...
+
+<P>If <TT>names</TT> is single-valued, then <TT>blueListItem()</TT> is applied and that's it.
+<H4>Applying Anonymous Templates</H4>
+
+
+<P>Some templates are so simple or so unlikely to be reused that it seems a waste of time making a separate template file and then referencing it.  <TT>StringTemplate</TT> provides <em>anonymous subtemplates</em> to handle this case.  The templates are anonymous in the sense that they are not named; they are directly applied in a single instance.
+
+<P>For example, to show a name list do the following:
+
+<FONT SIZE=2><PRE>
+&lt;ul&gt;
+$names:{&lt;li&gt;$it$&lt;/li&gt;}$
+&lt;/ul&gt;
+</PRE></FONT>
+
+
+
+<P>where anything enclosed in curlies is an anonymous subtemplate if, of course, it's within an attribute expression.  Note that in the subtemplate, I must enclose the <TT>it</TT> reference in the template expression delimiters.  You have started a new template exactly like the surrounding template and you must distinguish between text and attribute expressions.
+
+<P>You can apply multiple templates very conveniently.  Here is the bold list of names again with anonymous templates:
+
+<FONT SIZE=2><PRE>
+&lt;ul&gt;
+$names:{&lt;b&gt;$it$&lt;/b&gt;}:{&lt;li&gt;$it$&lt;/li&gt;}$
+&lt;/ul&gt;
+</PRE></FONT>
+
+
+
+<P>The output would look like:
+
+<FONT SIZE=2><PRE>
+&lt;ul&gt;
+&lt;li&gt;&lt;b&gt;Terence&lt;/b&gt;&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;Tom&lt;/b&gt;&lt;/li&gt;
+&lt;li&gt;&lt;b&gt;Jim&lt;/b&gt;&lt;/li&gt;
+&lt;/ul&gt;
+</PRE></FONT>
+
+
+
+<P>Anonymous templates work on single-valued attributes as well.
+<H4>Indirect template references</H4>
+
+
+<P>Sometimes the name of the template you would like to include is itself
+a variable.  So, rather than using "<TT>&lt;item:format()&gt;</TT>" you want the
+name of the template, <TT>format</TT>, to be a variable rather than a
+literal.  Just enclose the template name in parenthesis to indicate
+you want the immediate value of that attribute and then add <TT>()</TT> like
+a normal template invocation and you get "<TT>&lt;item:(someFormat)()&gt;</TT>",
+which means "look up attribute <TT>someFormat</TT> and use its value as a
+template name; appy to <TT>item</TT>."  This deliberately looks similar to
+the C function call indirection through a function pointer (e.g.,
+"<TT>(*fp)()</TT>" where fp is a pointer to a function).  A better way to look at
+it though is that the <TT>(someFormat)</TT> implies <em>immediately evaluate someFormat and use as the template name</em>.
+
+<P>Usually this "variable template" situation occurs when you have a list
+of items to format and each element may require a different template.
+Rather than have the controller code create a bunch of instances, one
+could consider it better to have <TT>StringTemplate</TT> do the creation--the
+controller just names what format to use.
+
+<P>Consider generating a list of Java declarations that are initialized to 0, false, null, etc...  One solution is to define a template for <TT>int</TT>, <TT>Object</TT>, <TT>Array</TT>, etc... declarations and then pass in an aggregate object that has the variable declaration object and the format.  In a template group file you might have:
+
+<FONT SIZE=2><PRE>
+group Java;
+
+file(variables,methods) ::= &lt;&lt;
+&lt;variables:{&lt;it.decl:(it.format)()&gt;}; separator="\n"&gt;
+&lt;methods&gt;
+&gt;&gt;
+intdecl() ::= "int &lt;it.name&gt; = 0;"
+intarray() ::= "int[] &lt;it.name&gt; = null;"
+</PRE></FONT>
+
+
+
+<P>Your code might look like:
+
+<FONT SIZE=2><PRE>
+StringTemplateGroup group =
+        new StringTemplateGroup(new StringReader(templates),
+                AngleBracketTemplateLexer.class);
+StringTemplate f = group.getInstanceOf("file");
+f.setAttribute("variables.{decl,format}", new Decl("i","int"), "intdecl");
+f.setAttribute("variables.{decl,format}", new Decl("a","int-array"), "intarray");
+System.out.println("f="+f);
+String expecting = ""+newline+newline;
+</PRE></FONT>
+
+
+
+<P>For this simple unit test, I used the following dummy decl class:
+
+<FONT SIZE=2><PRE>
+public static class Decl {
+    String name;
+    String type;
+    public Decl(String name, String type) {this.name=name; this.type=type;}
+    public String getName() {return name;}
+    public String getType() {return type;}
+}
+</PRE></FONT>
+
+
+
+<P>The value of <TT>f.toString()</TT> is:
+
+<FONT SIZE=2><PRE>
+int i = 0;
+int[] a = null;
+</PRE></FONT>
+
+
+
+<P>Missing attributes (i.e., <TT>null</TT> valued attributes) used as indirect
+template attribute generate nothing just like referencing a missing
+attribute.
+<H3>Conditionally Included Subtemplates (IF statements)</H3>
+
+
+<P>There are many situations when you want to conditionally include some text or another template.  <TT>StringTemplate</TT> provides simple IF-statements to let you specify conditional includes.  For example, in a dynamic web page you usually want a slightly different look depending on whether or not the viewer is "logged in" or not.  Without a conditional include, you would need two templates: <TT>page_logged_in</TT> and <TT>page_logged_out</TT>.  You can use a single <TT>page</TT> definition with <TT>if(</TT><em>expr</em><TT>)</TT> attribute actions instead:
+
+<FONT SIZE=2><PRE>
+&lt;html&gt;
+...
+&lt;body&gt;
+$if(member)$
+$gutter/top_gutter_logged_in()$
+$else$
+$gutter/top_gutter_logged_out()$
+$endif$
+...
+&lt;/body&gt;
+&lt;/html&gt;
+</PRE></FONT>
+
+ 
+
+<P>where template <TT>top_gutter_logged_in</TT> is located in the <TT>gutter</TT> subdirectory of my <TT>StringTemplateGroup</TT>.
+
+<P>IF actions test the presence or absence of an attribute unless the
+object is a <TT>Boolean</TT>, in which case it tests the attribute for
+<TT>true</TT>/<TT>false</TT>.  The only operator allowed is "not" and means either
+"not present" or "not true".  For example,
+"<TT>$if(!member)$...$endif$</TT>".
+<H4>Whitespace in conditionals issue</H4>
+
+
+<P>There is a simple, but not perfect rule: kill a single newline <B>after</B>
+<TT>&lt;if&gt;</TT>, <TT>&lt;&lt;</TT>, <TT>&lt;else&gt;</TT>, and <TT>&lt;endif&gt;</TT> (but for <TT>&lt;endif&gt;</TT> only if it's
+on a line by itself) . Kill newlines <B>before</B> <TT>&lt;else&gt;</TT> and <TT>&lt;endif&gt;</TT>
+and <TT>&gt;&gt;</TT>.  For example,
+
+<FONT SIZE=2><PRE>
+a &lt;if(foo)&gt;big&lt;else&gt;small&lt;endif&gt; dog
+</PRE></FONT>
+
+
+
+<P>is identical to:
+
+<FONT SIZE=2><PRE>
+a &lt;if(foo)&gt;
+big
+&lt;else&gt;
+small
+&lt;endif&gt;
+ dog
+</PRE></FONT>
+
+
+
+<P>It is very difficult to get the newline rule to work "properly"
+because sometimes you want newlines and sometimes you don't.  I
+decided to chew up as many as is reasonable and then let you
+explicitly say <TT>&lt;\n&gt;</TT> when you need to.
+<H3>Template visualization</H3>
+
+
+<P>Sometimes you use or define templates improperly.  Either you set an
+attribute that is not used or forget to set one or reference the wrong
+template etc...  I have made a toy visualization tool via that shows
+both the attributes and the way <TT>StringTemplate</TT> breaks up your
+template into chunks.  It properly handles <TT>StringTemplate</TT> objects as
+attributes and other nested structures.  Here is the way to launch a
+Swing frame to view your template:
+
+<FONT SIZE=2><PRE>
+StringTemplate st = ...;
+StringTemplateTreeView viz =
+    new StringTemplateTreeView("sample",st);
+viz.setVisible(true);
+</PRE></FONT>
+
+
+
+<P>Here is a snapshot (note that due some weird font thing on my os x
+box, the first <TT>&lt;html&gt;</TT> text chunk is missing in the display.) :( The
+display is associated with the fill-a-table example below.
+
+<P> <img src="page.treeview.jpg"  > 
+
+<P>If you turn on "lint mode" via <TT>StringTemplate.setLintMode(true)</TT> then
+you may access attribute <TT>attributes</TT>, which is a text string that
+recursively dumps out types, properties, etc... It does not print out
+their values.
+<H2>Functionality Summary</H2>
+
+
+<TABLE cellspacing=0 border=1>
+<TR><TD>
+<B>Syntax</B> </TD><TD> <B>Description</B>
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>attribute</em>&gt;
+</TD><TD> Evaluates to the value of <em>attribute</em><TT>.toString()</TT> if it exists else empty string.
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>multi-valued-attribute</em>&gt;
+</TD><TD> Concatenation of <TT>toString()</TT> invoked on each element.  If <em>multi-valued-attribute</em> is missing this evaluates to the empty string.
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>multi-valued-attribute</em>; separator=<em>expr</em>&gt;
+</TD><TD> Concatenation of <TT>toString()</TT> invoked on each element separated by <em>expr</em>. 
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>template</em>(<em>argument-list</em>)&gt;
+</TD><TD> Include <em>template</em>.  The <em>argument-list</em> is a list of attribute assignments where each assignment is of the form <em>attribute</em>=<em>expr</em>.
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>(expr)</em>(<em>argument-list</em>)&gt;
+</TD><TD> Include <em>template</em> whose name is computed via <em>expr</em>.  The <em>argument-list</em> is a list of attribute assignments where each assignment is of the form <em>attribute</em>=<em>expr</em>.  Example <TT>$(titleFont)()$</TT> looks up <TT>titleFont</TT>'s value and uses that as template name.  Can also apply an indirect template to an attribute.
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>attribute</em>:<em>template</em>(<em>argument-list</em>)&gt;
+</TD><TD> Apply <em>template</em> to <em>attribute</em>.  The optional <em>argument-list</em> is evaluated before application so that you can set attributes within <em>template</em>.  The default attribute <TT>it</TT> is set to the value of <em>attribute</em>.  Example: <TT>$data:bold()</TT> applies <TT>bold()</TT> to <TT>data</TT>'s value.  If <em>attribute</em> is multi-valued, then the optional <em>argument-list</em> is evaluated before each application so that you can set attributes within <em>template</em>.  Also, the default attribute <TT>it</TT> is set to the value of each element in turn.
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>attribute</em>:<em>(expr)</em>(<em>argument-list</em>)&gt;
+</TD><TD> Apply <em>template</em>, whose name is computed from <em>expr</em>, to <em>attribute</em>.  The optional <em>argument-list</em> is evaluated before application so that you can set attributes within <em>template</em>.  The default attribute <TT>it</TT> is set to the value of <em>attribute</em>.  Example <TT>$data:(name)()$</TT> looks up <TT>name</TT>'s value and uses that as template name to apply to <TT>data</TT>.
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>multi-valued-attribute</em>:<em>t1</em>(<em>argument-list</em>): ... :<em>tN</em>(<em>argument-list</em>)&gt;
+</TD><TD> Apply multiple templates in order from left to right.  The result of a template application upon a multi-valued attribute is another multi-valued attribute.  The overall expression evaluates to the concatenation of all elements of the final multi-valued attribute resulting from <em>templateN</em>'s application. 
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>attribute</em>:{<em>anonymous-template</em>}&gt;
+</TD><TD> Concatenate the results of applying a template with no name to each element of <em>multi-valued-attribute</em>.
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;<em>attribute</em>:<em>t1</em>(),<em>t2</em>(),...,<em>tN</em>()&gt;
+</TD><TD> Apply an alternating list of templates to the elements of <em>attribute</em>.
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;if(<em>attribute</em>)&gt;<em>subtemplate</em>
+&lt;else&gt;<em>subtemplate2</em>
+&lt;endif&gt;
+</TD><TD> If <em>attribute</em> has a value or is a <TT>true</TT> <TT>Boolean</TT> object, include <em>subtemplate</em> else include <em>subtemplate2</em>.  These conditionals may be nested.
+</TD>
+</TR>
+<TR>
+<TD>
+&lt;if(!<em>attribute</em>)&gt;<em>subtemplate</em>&lt;endif&gt;
+</TD><TD> If <em>attribute</em> has no value or is a <TT>false</TT> <TT>Boolean</TT> object, include <em>subtemplate</em>.  These conditionals may be nested.
+</TD>
+</TR>
+<TR>
+<TD>
+<TT>\$</TT> or <TT>\&lt;</TT> </TD><TD> escaped delimiter prevents <TT>$</TT> or <TT>&lt;</TT> from starting an attribute
+expression and results in that single character.
+</TD>
+</TR>
+<TR>
+<TD>
+<TT>&lt;\ &gt;</TT>, <TT>&lt;\n&gt;</TT>, <TT>&lt;\t&gt;</TT>, <TT>&lt;\r&gt;</TT> </TD><TD> special characters: space, newline,
+tab, carriage return.
+</TD>
+</TR>
+<TR>
+<TD>
+<TT>&lt;! comment !&gt;</TT>, <TT>$! comment !$</TT> </TD><TD> Comments, ignored by StringTemplate.
+</TD></TR>
+</TABLE>
+
+<H2>Setting the Expression Delimiters</H2>
+
+
+<P>By default, expressions in a template are delimited by dollar signs:
+<TT>$...$</TT>.  This works great for the most common case of HTML generation
+because the attribute expressions are clearly highlighted in the text.
+Sometimes, with other formats like SQL statement generation, you may
+want to change the template expression delimiters to avoid a conflict
+and to make the expressions stand out.
+
+<P>As of 2.0, the start and stop strings are limited to either <TT>$...$</TT> or <TT>&lt;...&gt;</TT> (unless you build your own lexical analyzer to break apart templates into chunks).
+
+<P>To use the angle bracket delimiters you must create a <TT>StringTemplateGroup</TT>:
+
+<FONT SIZE=2><PRE>
+StringTemplateGroup group =
+  new StringTemplateGroup("sqlstuff", "/tmp", AngleBracketTemplateLexer.class);
+StringTemplate query =
+  new StringTemplate(group, "SELECT &lt;column&gt; FROM &lt;table&gt;;");
+query.setAttribute("column", "name");
+query.setAttribute("table", "User");
+</PRE></FONT>
+
+
+
+<P>All templates created through the group or in anyway associated with
+the group will assume your the angle bracket delimiters.  It's smart to be
+consistent across all files of similar type such as "all HTML
+templates use <TT>$...$</TT>" and "all SQL templates use <TT>&lt;...&gt;</TT>".
+<H2>Caching</H2>
+
+
+<P>By default templates are loaded from disk just once.  During
+development, however, it is convenient to turn caching off.  Also, you
+may want to turn off caching so that you can quickly update a running
+site.  You can set a simple refresh interval using
+<TT>StringTemplateGroup.setRefreshInterval(...)</TT>.  When the interval is
+reached, all templates are thrown out.  Set interval to 0 to refresh
+constantly (no caching).  Set the interval to a huge number like
+<TT>Integer.MAX_INT</TT> to have no refreshing at all.
+<H2>Template Inheritance</H2>
+
+
+<P>Recall that a StringTemplateGroup is a collection of related templates such as all templates associated with the look of a web site. If you want to design a similar look for that site (such as for premium users), you don't really want to cut-n-paste the original template files for use in the new look. Changes to the original will not be propogated to the new look.
+
+<P>Just like you would do with a class definition, a template group may inherit templates from  another group, the <em>supergroup</em>.  If template <em>t</em> is not found in a group, it is looked up in the supergroup, if present.  This works regardless of whether you use a group file format or load templates from the disk via a <TT>StringTemplateGroup</TT> object.  Currently you cannot use the group file syntax to specify a supergroup.  I am investigating how this should work.  In the meantime, you must explicitly set the super.
+
+<P>From my unit tests, here is a simple inheritance of a template, <TT>bold</TT>:
+
+<FONT SIZE=2><PRE>
+StringTemplateGroup supergroup = new StringTemplateGroup("super");
+StringTemplateGroup subgroup = new StringTemplateGroup("sub");
+supergroup.defineTemplate("bold", "&lt;b&gt;$it$&lt;/b&gt;");
+subgroup.setSuperGroup(supergroup);
+StringTemplate st = new StringTemplate(subgroup, "$name:bold()$");
+st.setAttribute("name", "Terence");
+String expecting = "&lt;b&gt;Terence&lt;/b&gt;";
+</PRE></FONT>
+
+
+
+<P>The supergroup has a bold definition but the subgroup does not.  Referencing <TT>$name:bold()$</TT> works because subgroup looks into its supergroup if it is not found.
+
+<P>You may override templates:
+
+<FONT SIZE=2><PRE>
+supergroup.defineTemplate("bold", "&lt;b&gt;$it$&lt;/b&gt;");
+subgroup.defineTemplate("bold", "&lt;strong&gt;$it$&lt;/strong&gt;");
+</PRE></FONT>
+
+
+
+<P>And you may refer to a template in a supergroup via <TT>super.</TT><em>template</em><TT>()</TT>:
+
+<FONT SIZE=2><PRE>
+StringTemplateGroup group = new StringTemplateGroup(...);
+StringTemplateGroup subGroup = new StringTemplateGroup(...);
+subGroup.setSuperGroup(group);
+group.defineTemplate("page", "$font()$:text");
+group.defineTemplate("font", "Helvetica");
+subGroup.defineTemplate("font", "$super.font()$ and Times");
+StringTemplate st = subGroup.getInstanceOf("page");
+</PRE></FONT>
+
+
+
+<P>The string <TT>st.toString()</TT> results in "<TT>Helvetica and Times:text</TT>".
+
+<P>Just like object-oriented programming languages, <TT>StringTemplate</TT> has polymorphism.  That is, template names are looked up dynamically relative to the invoking templates group.  The classic demonstration of dynamic message sends in Java, for example, would be the following example that catches my students all the time: ;)
+
+<FONT SIZE=2><PRE>
+class A {
+  public void page() {bold();}
+  public void bold() {System.out.println("A.bold");}
+}
+class B extends A {
+  public void bold() {System.out.println("B.bold");}
+}
+...
+A a = new B();
+a.page();
+</PRE></FONT>
+
+
+
+<P>This prints "<TT>B.bold</TT>" not "<TT>A.bold</TT>" because the receiver determines how to answer a message not the type of the variable.  So, I have created a <TT>B</TT> object meaning that any message, such as <TT>bold()</TT>, invoked will first look in class <TT>B</TT> for <TT>bold()</TT>.
+
+<P>Similarly, a template's group determines where it starts looking for a template.  In this case, both super and sub groups define a <TT>bold</TT> template mirroring the Java above.  Because I create template <TT>st</TT> as a member of the <TT>subGroup</TT> and reference to <TT>bold</TT> starts looking in <TT>subGroup</TT> even though <TT>page</TT> is the template referring to <TT>bold</TT>.
+
+<FONT SIZE=2><PRE>
+StringTemplateGroup group = new StringTemplateGroup("super");
+StringTemplateGroup subGroup = new StringTemplateGroup("sub");
+subGroup.setSuperGroup(group);
+group.defineTemplate("bold", "&lt;b&gt;$it$&lt;/b&gt;");
+group.defineTemplate("page", "$name:bold()$");
+subGroup.defineTemplate("bold", "&lt;strong&gt;$it$&lt;/strong&gt;");
+StringTemplate st = subGroup.getInstanceOf("page");
+st.setAttribute("name", "Ter");
+String expecting = "&lt;strong&gt;Ter&lt;/strong&gt;";
+</PRE></FONT>
+
+
+<H2>Template And Attribute Lookup Rules</H2>
+
+<H3>Template lookup</H3>
+
+
+<P>When you request a named template via <TT>StringTemplateGroup.getInstanceOf()</TT> or within a template, there is a specific sequence used to locate the template.
+
+<P>If a template, <em>t</em>, references another template and <em>t</em> is not specifically associated with any group, <em>t</em> is implicitly associated with a default group whose root directory is "<TT>.</TT>", the current directory.  The referenced template will be looked up in the current directory.
+
+<P>If a template <em>t</em> is associated with a group, but was not defined via a group file format, lookup a referenced template in the group's template table.  If not there, look for it on the disk under the group's root dir or via the <TT>CLASSPATH</TT> (it might have appeared dynamically on disk).  If not found, recursively look at any supergroup of the group.  If not found at all, record this fact and don't look again on the disk until refresh interval.
+
+<P>If the template's associated group was defined via a group file, then that group is searched first.  If not found, the template is looked up in any supergroup.  The refresh interval is not used for group files because the group file is considered complete and enduring.
+<H3>Attribute scoping rules</H3>
+
+
+<P>A <TT>StringTemplate</TT> is a list of chunks, text literals and attribute expressions, and an attributes table.  To render a template to string, the chunks are written out in order; the expressions are evaluated only when asked to during rendering.  Attributes referenced in expressions are looked up using a very specific sequence similar to an inheritance mechanism.
+
+<P>When you nest a template within another, such as when a <TT>page</TT> template references a <TT>searchbox</TT> template, the nested template may see any attributes of the enclosing instance or its enclosing instances.  This mechanism is called <em>dynamic scoping</em>.  Contrast this with <em>lexical scoping</em> used in most programming languages like Java where a method may not see the variables defined in invoking methods.  Dynamic scoping is very natural for templates.  For example, if <TT>page</TT> has an attribute/value pair <TT>font</TT>/<TT>Times</TT> then <TT>searchbox</TT> could reference <TT>$font$</TT> when nested within a <TT>page</TT> instance.
+
+<P>Reference to attribute <em>a</em> in template <em>t</em> is resolved as follows:
+<OL>
+<LI>Look in <em>t</em>'s attribute table
+</LI>
+<LI>Look in <em>t</em>'s arguments
+</LI>
+<LI>Look in <em>t</em>'s enclosing template instance
+</LI>
+
+</OL>
+
+<P>This process is recursively executed until <em>a</em> is found or there are no more enclosing template instances.
+
+<P>When using a group file format to specify templates, you must specify the formal arguments for that template.  If you try to access an attribute that is not formally defined in that template or an enclosing template, you will get a <TT>NoSuchElementException</TT>.
+
+<P>When building code generators with <TT>StringTemplate</TT>, large heavily nested template tree structures are commonplace and, due to dynamic attribute scoping, a nested template could inadvertently use an attribute from an enclosing scope.  This could lead to infinite recursion during rendering.  To prevent this, formal arguments on template <em>t</em> hide any attribute value with that name in any enclosing scope.  Here is a test case that illustrates the point.  
+
+<FONT SIZE=2><PRE>
+String templates =
+        "group test;" +newline+
+        "block(stats) ::= \"{$stats$}\""
+        ;
+StringTemplateGroup group =
+        new StringTemplateGroup(new StringReader(templates));
+StringTemplate b = group.getInstanceOf("block");
+b.setAttribute("stats", group.getInstanceOf("block"));
+String expecting ="{{}}";
+</PRE></FONT>
+
+
+
+<P>Even though <TT>block</TT> has a <TT>stats</TT> value that refers to itself, there is no recursion because each instance of <TT>block</TT> hides the <TT>stats</TT> value from above since <TT>stats</TT> is a formal argument.
+
+<P>Sometimes self-recursive (hence infinitely recursive) structures occur through programming error and they are nasty to track down.  If you turn on "lint mode", <TT>StringTemplate</TT> will attempt to find cases where a template instance is being evaluated during the evaluation of itself.  For example, here is a test case that causes and traps infinite recursion.
+
+<FONT SIZE=2><PRE>
+String templates =
+        "group test;" +newline+
+        "block(stats) ::= \"$stats$\"" +
+        "ifstat(stats) ::= \"IF true then $stats$\"\n"
+        ;
+StringTemplate.setLintMode(true);
+StringTemplateGroup group =
+        new StringTemplateGroup(new StringReader(templates));
+StringTemplate b = group.getInstanceOf("block");
+StringTemplate ifstat = group.getInstanceOf("ifstat");
+b.setAttribute("stats", ifstat); // block has if stat
+ifstat.setAttribute("stats", b); // but make the "if" contain block
+try {
+    String result = b.toString();
+}
+catch (IllegalStateException ise) {
+    ...
+}
+</PRE></FONT>
+
+
+
+<P>The nested template stack trace from <TT>ise.getMessage()</TT> will be similar to:
+
+<FONT SIZE=2><PRE>
+infinite recursion to &lt;ifstat([stats])@4&gt; referenced in &lt;block([stats])@3&gt;; stack trace:
+&lt;ifstat([stats])@4&gt;, attributes=[stats=&lt;block()@3&gt;]&gt;
+&lt;block([stats])@3&gt;, attributes=[stats=&lt;ifstat()@4&gt;], references=[stats]&gt;
+&lt;ifstat([stats])@4&gt; (start of recursive cycle)
+...
+</PRE></FONT>
+
+
+<H3>Lazy evaluation</H3>
+
+
+<P>Attributes are <em>lazily evaluated</em> in the sense that referencing <em>a</em> does not actually invoke the lookup mechanism described here until the template is asked to render itself to text.  Lazy evaluation is surprising useful in both the web and code generation worlds because such order decoupling allows code to set attributes when it is convenient or efficient not necessarily before templates reference those attributes.  For example, a complicated web page consisting of many nested templates all may reference <TT>$userName$</TT>, but the value of <TT>userName</TT> does not need to be set until right before the entire page is rendered to text via <TT>toString()</TT>.  Even applying a template to a multi-valued attribute does not actually lookup and evaluate attributes until the entire overall template tree structure is rendered.  Applying a template to an attribute yields a template not a string.  You may ask the resulting template for its attributes even though!
  they have not been computed.
+<H2>Output Filters</H2>
+
+
+<P>2.0 introduces the notion of a <TT>StringTemplateWriter</TT>.  All text rendered from a template goes through one of these writers before being placed in the output buffer.  I added this primarily for auto-indentation for code generation, but it also could be used to remove whitespace (as a compression) from HTML output.  If you don't care about indentation, you can simply implement <TT>write()</TT>:
+
+<FONT SIZE=2><PRE>
+public interface StringTemplateWriter {
+    void pushIndentation(String indent);
+
+    String popIndentation();
+
+    void write(String str) throws IOException;
+}
+</PRE></FONT>
+
+
+
+<P>Here is a "pass through" writer that is already defined:
+
+<FONT SIZE=2><PRE>
+/** Just pass through the text */
+public class NoIndentWriter extends AutoIndentWriter {
+    public NoIndentWriter(Writer out) {
+        super(out);
+    }
+
+    public void write(String str) throws IOException {
+	    out.write(str);
+    }
+}
+</PRE></FONT>
+
+
+
+<P>Use it like this:
+
+<FONT SIZE=2><PRE>
+StringWriter out = new StringWriter();
+StringTemplateGroup group =
+                new StringTemplateGroup("test");
+group.defineTemplate("bold", "&lt;b&gt;$x$&lt;/b&gt;");
+StringTemplate nameST = new StringTemplate(group, "$name:bold(x=name)$");
+nameST.setAttribute("name", "Terence");
+// write to 'out' with no indentation
+nameST.write(new NoIndentWriter(out));
+System.out.println("output: "+out.toString());
+</PRE></FONT>
+
+
+
+<P>Instead of using <TT>nameST.toString()</TT>, which calls <TT>write</TT> with a string write and returns its value, manually invoke <TT>write</TT> with your writer.
+
+<P>If you want to always use a particular output filter, then use
+
+<FONT SIZE=2><PRE>
+StringTemplateGroup.setStringTemplateWriter(Class userSpecifiedWriterClass);
+</PRE></FONT>
+
+
+
+<P>The <TT>StringTemplate.toString()</TT> method is sensitive to the group's
+writer class.
+<H3>Auto-indentation</H3>
+
+
+<P><TT>StringTemplate</TT> 2.0 has auto-indentation on by default.  To turn it off, use <TT>NoIndentWriter</TT> rather than (the default) <TT>AutoIndentWriter</TT>.
+
+<P>At the simplest level, the indentation looks like a simple column count:
+
+<FONT SIZE=2><PRE>
+My dogs' names 
+  $names; separator="\n"$
+The last, unindented line
+</PRE></FONT>
+
+
+
+<P>will yield output like:
+
+<FONT SIZE=2><PRE>
+My dog's names
+  Fido
+  Rex
+  Stinky
+The last, unindented line
+</PRE></FONT>
+
+
+
+<P>where the last line gets "unindented" after displaying the list.  <TT>StringTemplate</TT> tracks the characters to the left of the <TT>$</TT> or <TT>&lt;</TT> rather than the column number so that if you indent with tabs versus spaces, you'll get the same indentation in the output.
+
+<P>When there are nested templates, <TT>StringTemplate</TT> tracks the combined
+indentation:
+
+<FONT SIZE=2><PRE>
+// &lt;user&gt; is indented two spaces
+main(user) ::= &lt;&lt;
+Hi
+\t$user:quote(); separator="\n"$
+&gt;&gt;
+
+quote ::= " '$it$'"
+</PRE></FONT>
+
+
+
+<P>In this case, you would get output like:
+
+<FONT SIZE=2><PRE>
+Hi
+\t 'Bob'
+\t 'Ephram'
+\t 'Mary'
+</PRE></FONT>
+
+
+
+<P>where the combined indentation is tab plus space for the attribute
+references in template <TT>quote</TT>.  Expression <TT>$user$</TT> is indented by 1 tab and hence any attribute
+generated from it (in this case the <TT>$attr$</TT> of <TT>quote()</TT>) must have
+at least the tab.
+
+<P>Consider generating nested statement lists as in C.  Any statements
+inside must be nested 4 spaces.  Here are two templates that could
+take care of this:
+
+<FONT SIZE=2><PRE>
+function(name,body) ::= &lt;&lt;
+void $name$() $body$
+&gt;&gt;
+
+slist(statements) ::= &lt;&lt;
+{
+    $statements; separator="\n"$
+}&gt;&gt;
+</PRE></FONT>
+
+
+
+<P>Your code would create a <TT>function</TT> template instance and an <TT>slist</TT>
+instance, which gets passed to the <TT>function</TT> template as attribute
+<TT>body</TT>.  The following Java code:
+
+<FONT SIZE=2><PRE>
+StringTemplate f = group.getInstanceOf("function");
+f.setAttribute("name", "foo");
+StringTemplate body = group.getInstanceOf("slist");
+body.setAttribute("statements", "i=1;");
+StringTemplate nestedSList = group.getInstanceOf("slist");
+nestedSList.setAttribute("statements", "i=2;");
+body.setAttribute("statements", nestedSList);
+body.setAttribute("statements", "i=3;");
+f.setAttribute("body", body);
+</PRE></FONT>
+
+
+
+<P>should generate something like:
+
+<FONT SIZE=2><PRE>
+void foo() {
+    i=1;
+    {
+        i=2;
+    }
+    i=3;
+}
+</PRE></FONT>
+
+
+
+<P>Indentation can only occur at the start of a line so indentation is
+only tracked in front of attribute expressions following a newline.
+
+<P>The one exception to indentation is that naturally, <TT>$if$</TT> actions do
+not cause indentation as they do not result in any output.  However,
+the subtemplates (THEN and ELSE clauses) will see indentations.  For
+example, in the following template, the two subtemplates are indented
+by exactly 1 space each:
+
+<FONT SIZE=2><PRE>
+     $if(foo)$
+ $x$
+\t\t$else
+ $y$
+$endif$
+</PRE></FONT>
+
+
+<H2>Examples</H2>
+
+
+<P>You should look at
+<TT>org.antlr.stringtemplate.test.TestStringTemplate.java</TT>, which
+contains a many tests.
+<H3>Fill-a-Table Example</H3>
+
+
+<P>The manner in which a template engine handles filling an HTML table
+with data often provides good insight into its programming and design
+strategy.  It illustrates the interaction of the model and view via
+the controller.  Using <TT>StringTemplate</TT>, the view may not access the
+model directly; rather the view is the passive recipient of data from
+the model.
+
+<P>First, imagine we have objects of type <TT>User</TT> that we will pull from a
+simulated database:
+
+<FONT SIZE=2><PRE>
+public static class User {
+    String name;
+    int age;
+    public User(String name, int age) {
+        this.name = name;
+        this.age = age;
+    }
+    public String getName() { return name; }
+    public int getAge() { return age; }
+}
+</PRE></FONT>
+
+
+
+<P>Our database is just a static list:
+
+<FONT SIZE=2><PRE>
+static User[] users = new User[] {
+    new User("Boris", 39),
+    new User("Natasha", 31),
+    new User("Jorge", 25),
+    new User("Vladimir", 28)
+};
+</PRE></FONT>
+
+
+
+<P>Here is my simple overall page design template, <TT>page.st</TT>:
+
+<FONT SIZE=2><PRE>
+&lt;html&gt;
+&lt;head&gt;
+&lt;title&gt;$title$&lt;/title&gt;
+&lt;/head&gt;
+&lt;body&gt;
+&lt;h1&gt;$title$&lt;/h1&gt;
+
+$body$
+
+&lt;/body&gt;
+&lt;/html&gt;
+</PRE></FONT>
+
+
+
+<P>The body attribute of <TT>page.st</TT> will be set to the following template
+<TT>users.inline.st</TT> by my web server infrastructure (part of the controller):
+
+<FONT SIZE=2><PRE>
+&lt;table border=1&gt;
+$users:{
+  &lt;tr&gt;
+    &lt;td&gt;$it.name$&lt;/td&gt;&lt;td&gt;$it.age$&lt;/td&gt;
+  &lt;/tr&gt;
+}$
+&lt;/table&gt;
+</PRE></FONT>
+
+
+
+<P>Again, <TT>it</TT> is the default attribute passed to a template when you
+apply that template to an attribute or attributes.  <TT>it.name</TT> gets
+the <TT>name</TT> property, if it exists, from the <TT>it</TT> object ala
+JavaBeans.  That is, <TT>StringTemplate</TT> uses reflection to call the
+<TT>getName()</TT> method on the incoming object.  By using reflection, I
+avoid a type dependence between model and view.
+
+<P>Now, imagine the server and templates are set up to format data.  My
+page definition is part of the controller that pulls data from the
+model (the database) and pushes into the view (the template).  That is
+all the page definition should do--interpret the data and set some
+attributes in the view.  The view only formats data and does no
+interpretation.
+
+<FONT SIZE=2><PRE>
+public static class UserListPage extends SamplePage {
+    /** This "controller" pulls from "model" and pushes to "view" */
+    public void generateBody(StringTemplate bodyST) throws Exception {
+        User[] list = users; // normally pull from database
+        // filter list if you want here (not in template)
+        bodyST.setAttribute("users", list);
+    }
+
+    public String getTitle() { return "User List"; }
+}
+</PRE></FONT>
+
+
+
+<P>Notice that the controller and model have no HTML in them at all and
+that the template has no code with side-effects or logic that can
+break the model-view separation.  If you wanted to only see users with
+age &lt; 30, you would filter the list in <TT>generateBody()</TT> rather than
+alter your template.  The template only displays information once the
+controller pulls the right data from the model.
+
+<P>Pushing factorization further, you could make a <TT>row.st</TT> component in
+order to reuse the table row HTML:
+
+<FONT SIZE=2><PRE>
+&lt;tr&gt;
+  &lt;td&gt;$it.name$&lt;/td&gt;&lt;td&gt;$it.age$&lt;/td&gt;
+&lt;/tr&gt;
+</PRE></FONT>
+
+
+
+<P>Then the user list template reduces to the more readable:
+
+<FONT SIZE=2><PRE>
+&lt;table border=1&gt;
+$users:row()$
+&lt;/table&gt;
+</PRE></FONT>
+
+
+
+<P>Naturally, you could go one step further and make another component
+for the entire table (putting it in file <TT>table.st</TT>):
+
+<FONT SIZE=2><PRE>
+&lt;table border=1&gt;
+$elements:row()$
+&lt;/table&gt;
+</PRE></FONT>
+
+
+
+<P>then the body template would simply be:
+
+<FONT SIZE=2><PRE>
+$table(elements=users)$
+</PRE></FONT>
+
+
+<H2>Complete Grammar</H2>
+
+
+<P><TT>StringTemplate</TT> has multiple grammars that describe templates at varying degrees of detail.  At the grossest level of granularity, the <TT>group.g</TT> grammar accepts a list of templates with formal template arguments.  Each of these templates is broken up into chunks of literal text and attribute expressions via <TT>template.g</TT>.  The default lexer uses <TT>$...$</TT> delimiters, but the <TT>angle.bracket.template.g</TT> lexer provides <TT>&lt;...&gt;</TT> delimiters.  Each of the attribute expression chunks is processed by <TT>action.g</TT>.  It builds trees (ASTs) representing the operation indicated in the expression.  These ASTs represent the "precompiled" templates, which are evaluated by the tree grammar <TT>eval.g</TT> each time a <TT>StringTemplate</TT> is rendered to string with <TT>toString()</TT>.
+
+<P>The grammar files are:
+<UL>
+<LI><TT>group.g</TT>: read a group file full of templates
+</LI>
+<LI><TT>template.g</TT>: break an individual template into chunks
+</LI>
+<LI><TT>angle.bracket.template.g</TT>: <TT>&lt;...&gt;</TT> template lexer
+</LI>
+<LI><TT>action.g</TT>: parse attribute expressions into ASTs
+</LI>
+<LI><TT>eval.g</TT>: evaluate expression ASTs during <TT>toString()</TT>
+</LI>
+
+</UL>
+
+<P>Anything outside of the <TT>StringTemplate</TT> start/stop delimiters is ignored.  The ANTLR grammar inside the attribute action is:
+
+<FONT SIZE=2><PRE>
+action
+    :   templatesExpr (SEMI optionList)?
+    |   "if" LPAREN ifCondition RPAREN
+    ;
+
+optionList
+    :   "separator" ASSIGN expr
+    ;
+
+ifCondition
+    :   ifAtom
+    |   NOT ifAtom
+    ;
+
+ifAtom
+    :   expr
+    ;
+
+expr:   atom (PLUS atom)*
+    ;
+
+atom:   attribute
+    |   templateInclude
+    |   LPAREN expr RPAREN  // regular old parens
+    ;
+
+templatesExpr
+    :   expr ( COLON template (COMMA template)* )*
+    ;
+
+nonAlternatingTemplateExpr
+    :   expr ( COLON template )*
+    ;
+
+template
+    :   (   namedTemplate       // foo()
+        |   anonymousTemplate   // {foo}
+        )
+    ;
+
+namedTemplate
+    :   ID argList
+    ;
+
+anonymousTemplate
+    :   ANONYMOUS_TEMPLATE
+    ;
+
+attribute
+    :   ID
+    |   objPropertyRef
+    |   STRING
+    |   INT
+    ;
+
+templateInclude
+    :   ID argList
+    |   "super" DOT ID argList
+    ;
+
+objPropertyRef
+    :   ID (DOT ID)+
+    ;
+
+argList
+    :   LPAREN RPAREN
+    |   LPAREN argumentAssignment (COMMA argumentAssignment)* RPAREN
+    ;
+
+argumentAssignment
+    :   ID ASSIGN nonAlternatingTemplateExpr
+    ;
+</PRE></FONT>
+
+
+
+<P>An identifier is:
+
+<FONT SIZE=2><PRE>
+ID  :	('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'/')*
+    ;
+</PRE></FONT>
+
+
+
+<P>Strings are double-quoted with optional embedded escaped characters that are translated (escapes are not translated outside of strings; for example, text outside of attribute expressions do not get escape chars translated except <TT>\\$</TT>, <TT>\\&lt;</TT> and <TT>\\&gt;</TT>).
+
+<FONT SIZE=2><PRE>
+STRING
+    :   '"' (ESC_CHAR | ~'"')* '"'
+    ;
+</PRE></FONT>
+
+
+
+<P>Anonymous templates are enclosed in curlies:
+
+<FONT SIZE=2><PRE>
+ANONYMOUS_TEMPLATE
+    :   '{' (ESC_CHAR | ~'}')* '}'
+    ;
+</PRE></FONT>
+
+
+
+<P>The translated escapes are:
+
+<FONT SIZE=2><PRE>
+ESC_CHAR
+    :   '\\'
+        (   'n'
+        |   'r'
+        |   't'
+        |   'b'
+        |   'f'
+        |   '"'
+        |   '\\'
+        )
+     ;
+</PRE></FONT>
+
+
+
+<P>but other escapes are allowed and ignored.
+
+<P>The other unspecified operators are:
+
+<FONT SIZE=2><PRE>
+COMMA  : ',' ;
+DOT    : '.' ;
+ASSIGN : '=' ;
+COLON  : ':' ;
+PLUS   : '+' ;
+SEMI   : ';' ;
+NOT    : '!' ;
+LPAREN : '(' ;
+RPAREN : ')' ;
+</PRE></FONT>
+
+
+<H2>A Common Syntax Question</H2>
+
+
+<P>Why have a template like:
+ 
+
+<FONT SIZE=2><PRE>
+Check this faq entry: $link(url="/faq/view?ID="+id, title="A FAQ")$.
+</PRE></FONT>
+
+
+
+<P>instead of 
+
+<FONT SIZE=2><PRE>
+Check this faq entry: $link(url="/faq/view?ID="+$id$, title="A FAQ")$.
+</PRE></FONT>
+
+
+
+<P>using <TT>$id$</TT> instead of <TT>id</TT> for that attribute reference?  The
+simplest answer is that you are already within the scope of an
+attribute expression between the <TT>$...$</TT> and hence <TT>StringTemplate</TT>
+knows that <TT>id</TT> must be a reference to an attribute by the grammar
+alone.  The template delimiters mark the beginning and end of what
+<TT>StringTemplate</TT> cares about.
+
+<P>Another way to look at it is the following.  Surely syntax (i) makes
+the most sense:
+
+<P>(i)   <TT>SELECT $col+blort$ FROM $table$</TT>
+
+<P>(ii)  <TT>SELECT $$col$+$blort$$ FROM $table$</TT>
+
+<P>(iii) <TT>SELECT $col$+$blort$ FROM $table$</TT>
+
+<P>Syntax (ii) is rather verbose and redundant wouldn't you say?  Syntax
+(iii) doesn't even work because the + is outside the realm of
+<TT>StringTemplate</TT> delimiters.
+
+<P></BODY>
+</HTML>

Added: trunk/org.prorefactor.lib/stringtemplate/release.html
===================================================================
--- trunk/org.prorefactor.lib/stringtemplate/release.html	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.lib/stringtemplate/release.html	2005-05-17 16:29:26 UTC (rev 30)
@@ -0,0 +1,101 @@
+<HTML>
+<HEAD>
+<body bgcolor=#FFFFFF text=#000000>
+<title>StringTemplate 2.1 Release Notes</title>
+</HEAD>
+<BODY>
+<H1>StringTemplate 2.1 Release Notes</H1>
+
+
+<P>Brought to you by that maniac that brings you
+<A HREF="http://www.antlr.org"><B> ANTLR</B></A>!
+
+<P>Terence Parr <BR>
+University of San Francisco <BR>
+<TT>parrt at cs.usfca.edu</TT> <BR>
+<em>Copyright 2003-2005</em> <BR>
+<A HREF="http://www.stringtemplate.org"><B>http://www.stringtemplate.org</B></A> <BR>
+(StringTemplate released under BSD License)
+
+<P>Version 2.1, January 22, 2005
+
+<P>2.1 is a bug fix and small feature enhancement release.  2.1 should be
+a drop-in replacement for those using <TT>StringTemplate</TT> for websites.
+Some newline handling differences exist, particularly for
+those using the group file format.  (If you are generating code not
+html, you will note some newlines are missing that used to be there;
+see the use of <TT>&lt;\n&gt;</TT> below).
+<H2>Enhancements</H2>
+
+<UL>
+<LI>Added 
+
+<FONT SIZE=2><PRE>
+/** Specify a StringTemplateWriter implementing class to use for
+ *  filtering output
+ */
+public void setStringTemplateWriter(Class c) {
+	userSpecifiedWriter = c;
+}
+</PRE></FONT>
+
+
+and made StringTemplate.toString() sensitive to it.
+</LI>
+<LI>added support for nonlocal file encodings; added property
+fileCharEncoding.  The template loading routines are now sensitive to
+this property. Defaults to the file.encoding system property.
+</LI>
+<LI>updated testing harness to be same as ANTLR 3.0's which is more
+sophisticated.
+</LI>
+<LI>addressed whitespace at begin/end of template .st file issue.
+Decided to let it continue to strip all front/back whitespace and then
+make you add it directly.  This is a simple rule and can be made to do
+what you want.  It is consistent with the strip newline before &gt;&gt;
+rule too.
+</LI>
+<LI>newlines ignored before &lt;else&gt; and &lt;endif&gt;.  Rule is: kill a single
+newline after &lt;if&gt;, &lt;&lt;, &lt;else&gt;, and &lt;endif&gt; (but for &lt;endif&gt; only if
+it's on a line by itself) . Kill newlines before &lt;else&gt; and &lt;endif&gt;
+and &gt;&gt;.  the newline immediately preceding &gt;&gt; in a template group file
+is tossed out just like the newline right after the &lt;&lt;
+</LI>
+<LI>added &lt;n&gt;, &lt;r&gt;, &lt;t&gt;, &lt; &gt; (space char)
+</LI>
+<LI>added $!...!$ and &lt;!...!&gt; comments (version 2.1b3)
+</LI>
+<LI>allow HashMap, Hashtable precisely but not Map in attribute.property lookup
+</LI>
+<LI>Attribute <TT>attributes$</TT> is a text string when lint mode is on that
+recursively dumps out types, properties, etc... (no values)
+</LI>
+<LI>Templates track their embedded instances; can ask for embedded
+</LI>
+<LI>added isXXX accessor properties so x.special invokes x.getSpecial
+then x.isSpecial if not successful.
+</LI>
+<LI>Empty output for a single attribute expression one a line by itself gets no newline (i.e., you don't get a blank line).
+</LI>
+
+</UL>
+<H2>Bug Fixes</H2>
+
+<UL>
+<LI>bug in st.attribute...if no attributes table, got null ptr exception
+</LI>
+<LI>fixed n refs in TestStringTemplate unit tests to be portable newline reference.
+</LI>
+<LI>STG.templateIsDefinedInThisGroup -&gt; isDefinedInThisGroup
+</LI>
+<LI>added isDefined(name) that checks whole hierarchy
+</LI>
+<LI>trap all antlr generated errors now and send to listener.
+</LI>
+<LI>Made null indirect template generate nothing; used to generate
+null-ptr exception.
+</LI>
+
+</UL>
+</BODY>
+</HTML>

Added: trunk/org.prorefactor.lib/stringtemplate/src.zip
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/stringtemplate/src.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/org.prorefactor.lib/stringtemplate/stringtemplate.jar
===================================================================
(Binary files differ)


Property changes on: trunk/org.prorefactor.lib/stringtemplate/stringtemplate.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java	2005-05-13 21:40:06 UTC (rev 29)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/refactor/PUB.java	2005-05-17 16:29:26 UTC (rev 30)
@@ -464,7 +464,7 @@
 	private void writeTree(ObjectOutputStream out, JPNode node) throws IOException {
 		out.writeInt(node.getSubtypeIndex());
 		out.writeInt(node.getType());
-		if ( ! TokenTypes.isKeyword(node.getType()) ) {
+		if ( ! TokenTypes.hasDefaultText(node.getType()) ) {
 			out.writeInt(NODETEXT);
 			out.writeInt(stringIndex(node.getText()));
 		}



From johnallengreen at sheep.berlios.de  Tue May 17 18:32:35 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Tue, 17 May 2005 18:32:35 +0200
Subject: [Prorefactor-svn] r31 - trunk/org.prorefactor.antlr
Message-ID: <200505171632.j4HGWZqj028210@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-17 18:32:17 +0200 (Tue, 17 May 2005)
New Revision: 31

Removed:
   trunk/org.prorefactor.antlr/build.properties
   trunk/org.prorefactor.antlr/src/
Log:
Removed antlr src directory.

Deleted: trunk/org.prorefactor.antlr/build.properties
===================================================================
--- trunk/org.prorefactor.antlr/build.properties	2005-05-17 16:29:26 UTC (rev 30)
+++ trunk/org.prorefactor.antlr/build.properties	2005-05-17 16:32:17 UTC (rev 31)
@@ -1,10 +0,0 @@
-bin.includes = plugin.xml,\
-               *.html,\
-               antlr.jar,\
-               antlrsrc.zip
-src.includes = *.html,\
-               src/,\
-               plugin.xml
-jars.compile.order = antlr.jar
-source.antlr.jar = src/
-output.antlr.jar = bin/



From johnallengreen at sheep.berlios.de  Tue May 17 21:02:25 2005
From: johnallengreen at sheep.berlios.de (John Green at BerliOS)
Date: Tue, 17 May 2005 21:02:25 +0200
Subject: [Prorefactor-svn] r32 - in trunk: org.prorefactor.core/src/org/prorefactor/treeparser01 org.prorefactor.core/src/org/prorefactor/treeparserbase org.prorefactor.doc org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/pub org.prorefactor.refactor/src/org/prorefactor/treeparser03
Message-ID: <200505171902.j4HJ2P3j014007@sheep.berlios.de>

Author: johnallengreen
Date: 2005-05-17 21:02:19 +0200 (Tue, 17 May 2005)
New Revision: 32

Modified:
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/ProParserTokenTypes.txt
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01TokenTypes.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01TokenTypes.txt
   trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParser.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.java
   trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.txt
   trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/ProParserTokenTypes.txt
   trunk/org.prorefactor.doc/manual.xml
   trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/pub/test01.p.pub
   trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/ProParserTokenTypes.txt
   trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03.java
   trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03TokenTypes.java
   trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03TokenTypes.txt
Log:
Rebuilt the treeparsers.
Updated the user/developer manual with new/improved instructions for building tree parsers.

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/ProParserTokenTypes.txt
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/ProParserTokenTypes.txt	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/ProParserTokenTypes.txt	2005-05-17 19:02:19 UTC (rev 32)
@@ -1086,3 +1086,7 @@
 SYMMETRICENCRYPTIONKEY=1089
 SYMMETRICSUPPORT=1090
 TRANSINITPROCEDURE=1091
+BIGINT=1092
+TIMESTAMP=1093
+FIXCHAR=1094
+Last_Token_Number=1095

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01.java	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01.java	2005-05-17 19:02:19 UTC (rev 32)
@@ -1,4 +1,4 @@
-// $ANTLR 2.7.4: "treeparser01.g" -> "TreeParser01.java"$
+// $ANTLR 2.7.5 (20050128): "treeparser01.g" -> "TreeParser01.java"$
 
 	package org.prorefactor.treeparser01;
 

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01TokenTypes.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01TokenTypes.java	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01TokenTypes.java	2005-05-17 19:02:19 UTC (rev 32)
@@ -1,4 +1,4 @@
-// $ANTLR 2.7.4: "treeparser01.g" -> "TreeParser01.java"$
+// $ANTLR 2.7.5 (20050128): "treeparser01.g" -> "TreeParser01.java"$
 
 	package org.prorefactor.treeparser01;
 

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01TokenTypes.txt
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01TokenTypes.txt	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparser01/TreeParser01TokenTypes.txt	2005-05-17 19:02:19 UTC (rev 32)
@@ -1,4 +1,4 @@
-// $ANTLR 2.7.4: treeparser01.g -> TreeParser01TokenTypes.txt$
+// $ANTLR 2.7.5 (20050128): treeparser01.g -> TreeParser01TokenTypes.txt$
 TreeParser01    // output token vocab name
 LEXDATE=4
 NAMEDOT=5

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParser.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParser.java	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParser.java	2005-05-17 19:02:19 UTC (rev 32)
@@ -1,11 +1,10 @@
-// $ANTLR 2.7.4: "JPTreeParser.g" -> "JPTreeParser.java"$
+// $ANTLR 2.7.5 (20050128): "JPTreeParser.g" -> "JPTreeParser.java"$
 
 	package org.prorefactor.treeparserbase;
 
 	import org.prorefactor.core.IJPNode;
-import org.prorefactor.treeparser.IJPTreeParser;
+	import org.prorefactor.treeparser.IJPTreeParser;
 
-
 import antlr.TreeParser;
 import antlr.Token;
 import antlr.collections.AST;

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.java
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.java	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.java	2005-05-17 19:02:19 UTC (rev 32)
@@ -1,11 +1,10 @@
-// $ANTLR 2.7.4: "JPTreeParser.g" -> "JPTreeParser.java"$
+// $ANTLR 2.7.5 (20050128): "JPTreeParser.g" -> "JPTreeParser.java"$
 
 	package org.prorefactor.treeparserbase;
 
 	import org.prorefactor.core.IJPNode;
-import org.prorefactor.treeparser.IJPTreeParser;
+	import org.prorefactor.treeparser.IJPTreeParser;
 
-
 public interface JPTreeParserTokenTypes {
 	int EOF = 1;
 	int NULL_TREE_LOOKAHEAD = 3;
@@ -1094,10 +1093,10 @@
 	int SYMMETRICENCRYPTIONKEY = 1089;
 	int SYMMETRICSUPPORT = 1090;
 	int TRANSINITPROCEDURE = 1091;
-	int SYMMETRICENCRYPTIONALGORITHM = 10877;
-	int PARAM = 10878;
 	int BIGINT = 1092;
 	int TIMESTAMP = 1093;
 	int FIXCHAR = 1094;
-	int Last_Token_Number = 1094;
+	int Last_Token_Number = 1095;
+	int SYMMETRICENCRYPTIONALGORITHM = 10877;
+	int PARAM = 10878;
 }

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.txt
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.txt	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/JPTreeParserTokenTypes.txt	2005-05-17 19:02:19 UTC (rev 32)
@@ -1,4 +1,4 @@
-// $ANTLR 2.7.4: JPTreeParser.g -> JPTreeParserTokenTypes.txt$
+// $ANTLR 2.7.5 (20050128): JPTreeParser.g -> JPTreeParserTokenTypes.txt$
 JPTreeParser    // output token vocab name
 LEXDATE=4
 NAMEDOT=5
@@ -1085,9 +1085,9 @@
 SYMMETRICENCRYPTIONKEY=1089
 SYMMETRICSUPPORT=1090
 TRANSINITPROCEDURE=1091
-SYMMETRICENCRYPTIONALGORITHM=10877
-PARAM=10878
 BIGINT=1092
 TIMESTAMP=1093
 FIXCHAR=1094
-Last_Token_Number=1094
+Last_Token_Number=1095
+SYMMETRICENCRYPTIONALGORITHM=10877
+PARAM=10878

Modified: trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/ProParserTokenTypes.txt
===================================================================
--- trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/ProParserTokenTypes.txt	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.core/src/org/prorefactor/treeparserbase/ProParserTokenTypes.txt	2005-05-17 19:02:19 UTC (rev 32)
@@ -1089,4 +1089,4 @@
 BIGINT=1092
 TIMESTAMP=1093
 FIXCHAR=1094
-Last_Token_Number=1094
+Last_Token_Number=1095

Modified: trunk/org.prorefactor.doc/manual.xml
===================================================================
--- trunk/org.prorefactor.doc/manual.xml	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.doc/manual.xml	2005-05-17 19:02:19 UTC (rev 32)
@@ -1177,43 +1177,43 @@
     </section>
 
     <section>
-      <title>Building Tree Parsers</title>
+      <title>Building the Tree Parsers</title>
 
+      <para>There are a few tree parsers which come within their own packages
+      in ProRefactor, each serving its own purpose. You can use any of these
+      as examples for your own tree parser, but a copy of the
+      <literal>treeparserbase</literal> package should normally be your
+      starting point. The <literal>treeparser01</literal> package gives plenty
+      of examples of how to add action code to the tree parser.</para>
+
+      <para>Antlr is a parser-generator which reads a <filename>.g</filename>
+      grammar file in order to generate the Java source code for the tree
+      parser.</para>
+
       <para>We use Ant to do the build, but Ant has to be able to find Antlr.
       Choose <guilabel>Window &gt; Preferences &gt; Ant &gt; Runtime &gt;
-      Classpath</guilabel>. Select <guilabel>Global Entries</guilabel>. Add
-      the <filename>bin</filename> directory of your antlr project if you are
-      working with the Subversion repository source, or add the
-      <filename>plugins/org.prorefactor.antlr/antlr.jar</filename> file
-      otherwise. Ignore the warning about <quote>tools.jar</quote>.</para>
+      Classpath</guilabel>. Select <guilabel>Global Entries</guilabel>. Click
+      <guibutton>Add Jars...</guibutton>, and select
+      <filename>org.prorefactor.antlr/antlr.jar</filename> file. Click
+      <guibutton>Add Variable...</guibutton> and enter <literal>
+      ${workspace_loc:/org.prorefactor.core/bin/}</literal>. This is required
+      because there is additional post-processing which must be done after
+      Antlr has generated the source for the tree parser. You can close this
+      Preferences window now.</para>
 
-      <para>There is additional post-processing which must be done after Antlr
-      has generated the source for the tree parser. Because of this, a little
-      bit of careful configuration of the launch configuration for
-      <filename>build.xml</filename> is required. If you look at the source
-      for <filename>build.xml</filename> (for example, look at the package
-      <literal>org.prorefactor.treeparserbase</literal>), you will see that
-      after Antlr is launched, a <classname>PostProcessor</classname> class is
-      called. The Java/Ant session must have that
-      <classname>PostProcessor</classname> in its class path.</para>
+      <para>In the package which contains the tree parser, select the
+      <filename>build.xml</filename> file. Right-click, and choose
+      <guimenuitem>Run &gt; Ant Build...</guimenuitem> to get the properties
+      dialog.</para>
 
-      <para>Select the <filename>build.xml</filename> file, right-click,
-      choose <guimenuitem>Run &gt; Ant Build...</guimenuitem> to get the
-      properties dialog.</para>
+      <para>Choose the <guilabel>Refresh</guilabel> tab, and enable the
+      automatic refresh of the containing folder. Now when you choose
+      <guimenuitem>Run &gt; Ant Build</guimenuitem>, the refresh and
+      re-compile will be done automatically.</para>
 
-      <para>In the <guilabel>Classpath</guilabel> tab, choose the
-      <guibutton>Add Folders...</guibutton> button, and add the
-      <filename>org.prorefactor.core/bin</filename> folder.</para>
-
       <para>Leave the JRE set to launch a separate JRE. Running from the same
       JRE as the workspace does not set up the class path correctly for our
       needs.</para>
-
-      <para>Also in the same properties dialog, choose the
-      <guilabel>Refresh</guilabel> tab, and enable the automatic refresh of
-      the containing folder. Now when you choose <guimenuitem>Run &gt; Ant
-      Build</guimenuitem>, the refresh and re-compile will be done
-      automatically.</para>
     </section>
 
     <section>

Modified: trunk/org.prorefactor.refactor/prorefactor/projects/sports2000/pubs/data/pub/test01.p.pub
===================================================================
(Binary files differ)

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/ProParserTokenTypes.txt
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/ProParserTokenTypes.txt	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/ProParserTokenTypes.txt	2005-05-17 19:02:19 UTC (rev 32)
@@ -1086,3 +1086,7 @@
 SYMMETRICENCRYPTIONKEY=1089
 SYMMETRICSUPPORT=1090
 TRANSINITPROCEDURE=1091
+BIGINT=1092
+TIMESTAMP=1093
+FIXCHAR=1094
+Last_Token_Number=1095

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03.java	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03.java	2005-05-17 19:02:19 UTC (rev 32)
@@ -1,11 +1,10 @@
-// $ANTLR 2.7.4: "treeparser03.g" -> "TreeParser03.java"$
+// $ANTLR 2.7.5 (20050128): "treeparser03.g" -> "TreeParser03.java"$
 
 	package org.prorefactor.treeparser03;
 
 	import org.prorefactor.core.IJPNode;
-import org.prorefactor.treeparser.IJPTreeParser;
+	import org.prorefactor.treeparser.IJPTreeParser;
 
-
 import antlr.TreeParser;
 import antlr.Token;
 import antlr.collections.AST;

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03TokenTypes.java
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03TokenTypes.java	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03TokenTypes.java	2005-05-17 19:02:19 UTC (rev 32)
@@ -1,11 +1,10 @@
-// $ANTLR 2.7.4: "treeparser03.g" -> "TreeParser03.java"$
+// $ANTLR 2.7.5 (20050128): "treeparser03.g" -> "TreeParser03.java"$
 
 	package org.prorefactor.treeparser03;
 
 	import org.prorefactor.core.IJPNode;
-import org.prorefactor.treeparser.IJPTreeParser;
+	import org.prorefactor.treeparser.IJPTreeParser;
 
-
 public interface TreeParser03TokenTypes {
 	int EOF = 1;
 	int NULL_TREE_LOOKAHEAD = 3;
@@ -1094,6 +1093,10 @@
 	int SYMMETRICENCRYPTIONKEY = 1089;
 	int SYMMETRICSUPPORT = 1090;
 	int TRANSINITPROCEDURE = 1091;
+	int BIGINT = 1092;
+	int TIMESTAMP = 1093;
+	int FIXCHAR = 1094;
+	int Last_Token_Number = 1095;
 	int SYMMETRICENCRYPTIONALGORITHM = 10877;
 	int PARAM = 10878;
 }

Modified: trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03TokenTypes.txt
===================================================================
--- trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03TokenTypes.txt	2005-05-17 16:32:17 UTC (rev 31)
+++ trunk/org.prorefactor.refactor/src/org/prorefactor/treeparser03/TreeParser03TokenTypes.txt	2005-05-17 19:02:19 UTC (rev 32)
@@ -1,4 +1,4 @@
-// $ANTLR 2.7.4: treeparser03.g -> TreeParser03TokenTypes.txt$
+// $ANTLR 2.7.5 (20050128): treeparser03.g -> TreeParser03TokenTypes.txt$
 TreeParser03    // output token vocab name
 LEXDATE=4
 NAMEDOT=5
@@ -1085,5 +1085,9 @@
 SYMMETRICENCRYPTIONKEY=1089
 SYMMETRICSUPPORT=1090
 TRANSINITPROCEDURE=1091
+BIGINT=1092
+TIMESTAMP=1093
+FIXCHAR=1094
+Last_Token_Number=1095
 SYMMETRICENCRYPTIONALGORITHM=10877
 PARAM=10878



